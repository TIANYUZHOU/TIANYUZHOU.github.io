{"pages":[{"title":"关于：","text":"不想当程序员的摄影师不是好搬砖工我是天宇同学 一名摄影爱好者 现就读于某大学计算机系 坚信兴趣是最好的老师 我热衷于一切美好事物： 生活、编程、摄影、摄像、视频制作... PS：你可以点击我的图库查看我拍摄的照片 欢迎进入我博客，你可以浏览我的文章 也可以点击我的主页——歌单标签——听我收藏的音乐 你可以通过点击每篇文章的首图或“阅读更多”进入该文章 进入文章后可以在文章末尾添加评论和你的网址 .mypic{ line-height:32px; height:32px; width:80px; color:#ffffff; background-color:#ededed; font-size:15px; font-weight:normal; font-family:Arial; background:-webkit-gradient(linear, left top, left bottom, color-start(0.05, #4a8cf7), color-stop(1, #3672d2)); background:-moz-linear-gradient(top, #4a8cf7 5%, #3672d2 100%); background:-o-linear-gradient(top, #4a8cf7 5%, #3672d2 100%); background:-ms-linear-gradient(top, #4a8cf7 5%, #3672d2 100%); background:linear-gradient(to bottom, #4a8cf7 5%, #3672d2 100%); background:-webkit-linear-gradient(top, #4a8cf7 5%, #3672d2 100%); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#4a8cf7', endColorstr='#3672d2',GradientType=0); border:0px solid #dcdcdc; -webkit-border-top-left-radius:8px; -moz-border-radius-topleft:8px; border-top-left-radius:8px; -webkit-border-top-right-radius:8px; -moz-border-radius-topright:8px; border-top-right-radius:8px; -webkit-border-bottom-left-radius:8px; -moz-border-radius-bottomleft:8px; border-bottom-left-radius:8px; -webkit-border-bottom-right-radius:8px; -moz-border-radius-bottomright:8px; border-bottom-right-radius:8px; -moz-box-shadow:0px 10px 13px -10px #1b4588; -webkit-box-shadow:0px 10px 13px -10px #1b4588; box-shadow:0px 10px 13px -10px #1b4588; text-align:center; display:inline-block; text-decoration:none; } .mypic:hover{ background-color:#f5f5f5; background:-webkit-gradient(linear, left top, left bottom, color-start(0.05, #3672d2), color-stop(1, #4a8cf7)); background:-moz-linear-gradient(top, #3672d2 5%, #4a8cf7 100%); background:-o-linear-gradient(top, #3672d2 5%, #4a8cf7 100%); background:-ms-linear-gradient(top, #3672d2 5%, #4a8cf7 100%); background:linear-gradient(to bottom, #3672d2 5%, #4a8cf7 100%); background:-webkit-linear-gradient(top, #3672d2 5%, #4a8cf7 100%); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#3672d2', endColorstr='#4a8cf7',GradientType=0); }","link":"/about/index.html"},{"title":"歌单","text":"","link":"/playist/index.html"}],"posts":[{"title":"C++内联函数","text":"C++类中的内联函数 C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 隐式内联 1234567891011121314class Person{public: Person(const string &amp;name) { Name = name; } void printName()//printName 定义在类里面是隐式内联函数 { cout &lt;&lt; Name &lt;&lt; endl; }private: string Name;}; 在类里面显示声明，在类外面定义 1234567891011121314151617class Person{public: Person(const string &amp;name) { Name = name; } inline void printName();//成员被函数前加了inline是显式内联函数 //在类里面显式声明private: string Name;};void Person::printName(){//在类外面定义 cout &lt;&lt; Name &lt;&lt; endl;} “追加”内联 12345678910111213141516class Person{public: Person(const string &amp;name) { Name = name; } void printName(); //在类里面没有显式声明private: string Name;};inline void Person::printName()//成员被函数前加了inline是显式内联函数{//在类外面显式定义 cout &lt;&lt; Name &lt;&lt; endl;} 转自CSDNC++类里面的哪些成员函数是内联函数？","link":"/2020/03/27/C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"title":"HTML5+CSS+JS学习笔记","text":"关于HTML HTML，全称“Hyper Text Markup Language（超文本标记语言）”，简单来说，网页就是用HTML语言制作的。 HTML5是Web中核心语言HTML的规范，用户使用任何手段进行网页浏览时看到的内容原本都是HTML格式的，在浏览器中通过一些技术处理将其转换成为了可识别的信息。 最小的HTML5文档 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;文档内容......&lt;/body&gt;&lt;/html&gt; 注意：对于中文网页需要使用&lt;meta charset=&quot;utf-8&quot;&gt;声明编码，否则会出现乱码。 一、HTML5基本标签1.HTML标签整个网页是从 &lt;html&gt;这里开始的，然后到&lt;/html&gt;结束。 2.head标签head标签代表页面的“头”，定义一些特殊内容，多数内容在浏览器中不可见。 head标签 解释 &lt;title&gt; 定义网页的标题 &lt;meta&gt; 定义网页的基本信息（供搜索引擎） &lt;style&gt; 定义CSS样式 &lt;link&gt; 链接外部CSS文件或脚本文件 &lt;script&gt; 定义脚本语言 &lt;base&gt; 定义页面所有链接的基础定位（用得很少） 3.body标签body标签代表页面的“身”，定义网页展示内容，在浏览器中往往可见。 二、段落与文字1.段落标签 标签 语义 说明 &lt;h1&gt;~&lt;h6&gt; header 标题 &lt;p&gt; paragraph 段落 &lt;br&gt; break 换行 &lt;hr&gt; horizontal rule 水平线 &lt;div&gt; division 分割（块元素） &lt;span&gt; span 区域（行内元素） 2.文本格式化标签 标签 语义 说明 &lt;st&gt; strong（加强） 加粗 &lt;em&gt; emphasized（强调） 斜体 &lt;cite&gt; cite（引用） 斜体 &lt;sup&gt; superscripted（上标） 上标 &lt;sub&gt; subscripted（下标） 下标 3.块元素和行内元素 HTML元素根据浏览器表现形式分为两类：①块元素；②行内元素 块元素特点： 独占一行，排斥其他元素跟其位于同一行，包括块元素和行内元素； 块元素内部可以容纳其他块元素或行元素； 常见块元素：h1~h6、p、hr、div 行内元素特点： 可以与其他行内元素位于同一行； 行内内部可以容纳其他行内元素，但不可以容纳块元素，不然会出现无法预知的效果； 常见行内元素有：strong、em、span 三、列表 标签 语义 说明 ol ordered list 有序列表 ul unordered list 无序列表 dl definition list 定义列表 1.有序列表123456789&lt;ol&gt; &lt;li&gt;有序列表项&lt;/li&gt; &lt;li&gt;有序列表项&lt;/li&gt; &lt;li&gt;有序列表项&lt;/li&gt;&lt;/ol&gt; type属性值 列表项的序号类型 1 1、2、3…… a a、b、c…… A A、B、C…… i i、ii、iii…… I I、II、III…… 学习CSS之后，有序列表列表项符号更常用list-style-type属性定义。 2.无序列表123456789&lt;ul type=&quot;列表项符号&quot;&gt; &lt;li&gt;无序列表项&lt;/li&gt; &lt;li&gt;无序列表项&lt;/li&gt; &lt;li&gt;无序列表项&lt;/li&gt;&lt;/ul&gt; type属性值 列表项的序号类型 disc 默认值，实心圆“●” circle 空心圆“○” square 实心正方形“■” 学习CSS之后，无序列表列表项符号更常用list-style-type属性定义。 3.定义列表123456789&lt;dl&gt; &lt;dt&gt;定义名词&lt;/dt&gt; &lt;dd&gt;定义描述&lt;/dd&gt; ……&lt;/dl&gt; &lt;dl&gt;即“definition list（定义列表）”，&lt;dt&gt;即“definition term（定义名词）”，而&lt;dd&gt;即“definition description（定义描述）”。 在该语法中，&lt;dl&gt;标记和&lt;/dl&gt;标记分别定义了定义列表的开始和结束，&lt;dt&gt;后面添加要解释的名词，而在&lt;dd&gt;后面则添加该名词的具体解释。","link":"/2020/01/30/HTML5-CSS-JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"UIE迁移","text":"UIE模型UIE模型是指Unified Information Extraction，即通用信息抽取模型。该模型是由Yaojie Lu等人在ACL-2022中提出的通用信息抽取统一框架，实现了实体抽取、关系抽取、事件抽取、情感分析等任务的统一建模，并使得不同任务间具备良好的迁移和泛化能力。 模型迁移一般模型迁移，需要经历以下步骤： 模型代码迁移 这一步需要进行API接口映射（比如把Pytorch实现的模型代码映射成使用MindSpore的API接口实现，如果所需API在目标框架中没有或者区别较大就可能需要自己实现了） 模型/模块验证 完成模型代码迁移后，必然少不了对其进行验证。在预训练权重迁移之前，如果模型结构比较简单，可以手动构造Tensor并且手动替代随机初始化权重等随机因素，然后将模型实例设置为预测模式，进行初步的输入输出验证（输出Tensor的shape应该相等、值应该误差在1e-5/1e-3/5e-3内），这样可以验证出模型/模块的基本结构和前向计算过程是否正确。 预训练权重迁移 当然最正确最有效的验证方式，是将模型的预训练权重加载到模型中，然后将模型设为预测模式，进行前向推理比较输出Tensor的shape和值，并且一个完整的模型迁移过程通常本来就需要将预训练权重迁移也进行迁移。 这时就出现一个问题，我们知道不同的深度学习框架除了API有所区别外，保存权重（也就是模型的参数）的格式也有所不同。该如何转换呢？ 实际上，模型的权重（参数）就是一堆数值矩阵，在模型结构一致的情况下可能出现的区别也就在权重矩阵的维度以及它们的名称上。因此，要实现迁移，只需要将它们的参数名字以及维度转化成适应目标框架的形式即可。（因此分析出两个框架之间的参数名称和权重维度对应关系非常重要！） 迁移过程主要记录遇到的坑 框架 PaddleNLP-&gt;MindNLP 模型代码迁移 paddle.nn.MultiHeadAttention与mindspore.nn.MultiheadAttention paddle.nn.MultiHeadAttention的attention mask的输入维度：[batch_size，n_head，sequence_length，sequence_length] mindspore.nn.MultiheadAttention的的attention mask的输入维度： [batch_size * n_head, sequence_length，sequence_length] 尾部两个sequence_length维度分别代表源序列长度和目标序列长度 因此在MindNLP中需要对attention mask加一步tile操作， 将Tensor维度变成第二种形式。 123456789# paddle 中的 attention maskattention_mask = paddle.unsqueeze( (input_ids == self.pad_token_id).astype(self.pooler.dense.weight.dtype) * -1e4, axis=[1, 2])# mindspore 中的 attention maskattention_mask = ((input_ids == self.pad_token_id).astype(self.pooler.dense.weight.dtype) * -1e4).unsqueeze(1).unsqueeze(2)attention_mask = ops.tile(attention_mask, (1, self.nheads, seq_length, 1)).reshape(-1, seq_length, seq_length)# 注意：mindspore 的 unsqueeze 一次只支持增加一维，但可以使用链式调用 权重迁移 坑同样出现在MultiHeadAttention当中，首先来看看源码： 1234567891011121314151617# paddle MultiHeadAttention 中参数定义self.q_proj = Linear(embed_dim, embed_dim, weight_attr, bias_attr=bias_attr)self.k_proj = Linear(self.kdim, embed_dim, weight_attr, bias_attr=bias_attr)self.v_proj = Linear(self.vdim, embed_dim, weight_attr, bias_attr=bias_attr)# mindspore MultiHeadAttention 中参数定义if not self._qkv_same_embed_dim: self.q_proj_weight = Parameter(initializer(XavierUniform(), (embed_dim, embed_dim)), 'q_proj_weight') self.k_proj_weight = Parameter(initializer(XavierUniform(), (embed_dim, self.kdim)), 'k_proj_weight') self.v_proj_weight = Parameter(initializer(XavierUniform(), (embed_dim, self.vdim)), 'v_proj_weight') self.in_proj_weight = Noneelse: self.in_proj_weight = Parameter(initializer(XavierUniform(), (3 * embed_dim, embed_dim)), 'in_proj_weight') self.q_proj_weight = None self.k_proj_weight = None self.v_proj_weight = None 首先可以看到，在paddle中，qkv参数是直接用全连接层定义的，而在mindspore中使用的是Parameter，当然实际上两种方式的效果一样所以这一点区别不重要。 重点在于，在mindspore中，如果qkv的维度相同的话，它会把原本的qkv对应的三个参数矩阵拼接成一个in_proj_weight，也就是esle部分的代码所做的事。因此，在checkpoint转化时，也需要将这三个参数矩阵进行拼接融合成一个。 下面分别打印在两个框架中实现的模型的参数名及权重维度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# paddle实现UIE的权重ernie.embeddings.word_embeddings.weight[40000, 768]ernie.embeddings.position_embeddings.weight[2048, 768]ernie.embeddings.token_type_embeddings.weight[4, 768]ernie.embeddings.task_type_embeddings.weight[3, 768]ernie.embeddings.layer_norm.weight[768]ernie.embeddings.layer_norm.bias[768]ernie.encoder.layers.0.self_attn.q_proj.weight[768, 768]ernie.encoder.layers.0.self_attn.q_proj.bias[768]ernie.encoder.layers.0.self_attn.k_proj.weight[768, 768]ernie.encoder.layers.0.self_attn.k_proj.bias[768]ernie.encoder.layers.0.self_attn.v_proj.weight[768, 768]ernie.encoder.layers.0.self_attn.v_proj.bias[768]ernie.encoder.layers.0.self_attn.out_proj.weight[768, 768]ernie.encoder.layers.0.self_attn.out_proj.bias[768]ernie.encoder.layers.0.linear1.weight[768, 3072]ernie.encoder.layers.0.linear1.bias[3072]ernie.encoder.layers.0.linear2.weight[3072, 768]ernie.encoder.layers.0.linear2.bias[768]ernie.encoder.layers.0.norm1.weight[768]ernie.encoder.layers.0.norm1.bias[768]ernie.encoder.layers.0.norm2.weight[768]ernie.encoder.layers.0.norm2.bias[768]...ernie.pooler.dense.weight[768, 768]ernie.pooler.dense.bias[768]linear_start.weight[768, 1]linear_start.bias[1]linear_end.weight[768, 1]linear_end.bias[1] # mindspore实现UIE的权重ernie.embeddings.word_embeddings.embedding_table[40000, 768]ernie.embeddings.position_embeddings.embedding_table[2048, 768]ernie.embeddings.token_type_embeddings.embedding_table[4, 768]ernie.embeddings.task_type_embeddings.embedding_table[3, 768]ernie.embeddings.layer_norm.gamma[768]ernie.embeddings.layer_norm.beta[768]ernie.encoder.layers.0.self_attn.in_proj_weight[2304, 768]ernie.encoder.layers.0.self_attn.in_proj_bias[2304]ernie.encoder.layers.0.self_attn.out_proj.weight[768, 768]ernie.encoder.layers.0.self_attn.out_proj.bias[768]ernie.encoder.layers.0.linear1.weight[3072, 768]ernie.encoder.layers.0.linear1.bias[3072]ernie.encoder.layers.0.linear2.weight[768, 3072]ernie.encoder.layers.0.linear2.bias[768]ernie.encoder.layers.0.norm1.gamma[768]ernie.encoder.layers.0.norm1.beta[768]ernie.encoder.layers.0.norm2.gamma[768]ernie.encoder.layers.0.norm2.beta[768]...ernie.pooler.dense.weight[768, 768]ernie.pooler.dense.bias[768]linear_start.weight[1, 768]linear_start.bias[1]linear_end.weight[1, 768]linear_end.bias[1] 为了方便分析，...省略了11层ernie.encoder.layers（总共12层）。下面表格列出两个框架之间的参数区别（不同之处已加粗）： paddle mindspore word_embeddings.weight[40000, 768] word_embeddings.embedding_table[40000, 768] position_embeddings.weigh[2048, 768] word_embeddings.embedding_table[2048, 768] token_type_embeddings.weight[4, 768] token_type_embeddings.embedding_table[4, 768] layer_norm.weight[768] layer_norm.gamma[768] layer_norm.bias[768] layer_norm.beta[768] layers.0.self_attn.q_proj.weight[768, 768]layers.0.self_attn.q_proj.bias[768]layers.0.self_attn.k_proj.weight[768, 768]layers.0.self_attn.k_proj.bias[768]layers.0.self_attn.v_proj.weight[768, 768]layers.0.self_attn.v_proj.bias[768] layers.0.self_attn.in_proj_weight[2304, 768]layers.0.self_attn.in_proj_bias[2304] layers.0.linear1.weight[768, 3072] layers.0.linear1.weight[3072, 768] layers.0.linear2.weight[3072, 768] layers.0.linear2.weight[768, 3072] layers.0.norm1.weight[768] layers.0.norm1.gamma[768] layers.0.norm1.bias[768] layers.0.norm1.beta[768] layers.0.norm2.weight[768] layers.0.norm2.gamma[768] layers.0.norm2.bias[768] layers.0.norm2.beta[768] linear_start.weight[768, 1] linear_start.weight[1, 768] linear_end.weight[768, 1] linear_end.weight[1, 768] 可以看到，对于embeddings和layer_norm/norm区别在于参数名而维度形状相同；对于全连接层liner区别在于维度形状交换而参数名相同；再看表格的第6行，前面源代码已经分析过了，paddle使用了全连接层并且没有将qkv的参数融合在一起，所以它的qkv的权重矩阵刚好是mindspore中权重矩阵的拆分（这里需要注意拼接weight的时候先沿axis=1拼接成[760,2304]，然后再转置/交换维度成[2304,768]，如果沿axis=0直接拼接，qkv所对应的权重矩阵就乱了）。 好到这里就分析完了？未列入上表的其他参数说明一模一样，即参数名相同维度也没反？ 注意：大坑来了！！！ paddle mindspore layers.0.self_attn.q_proj.weight[768, 768] layers.0.self_attn.out_proj.weight[768, 768] 特意把这self_attn.q_proj.weight单独提出来，这个参数乍一看在两个框架中完全一样！无论是参数名称还是其维度！但是，实际上是不同的！这两个矩阵虽然在维度大小上完全一致，但是是一个转置关系！也就说这个参数矩阵也需要交换一下维度！ 经过上面分析，接下来要做的就是：1. 将参数名进行转换 2. 将维度进行转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import loggingimport reimport numpy as npimport paddlefrom mindspore import Tensorfrom mindspore.train.serialization import save_checkpointdef paddle_to_mindspore(pth_file, size:str=None): size = &quot;mindspore&quot; if not size else size # rename ckpt logging.info('Starting checkpoint conversion.') ms_ckpt = [] state_dict = paddle.load(&quot;model_state.pdparams&quot;) cnt1 = 0 in_p_w = np.empty((768,0),dtype=np.float32) # 创建一个维度与embedding相同的空矩阵以便拼接 cnt2 = 0 in_p_b = np.empty(0,dtype=np.float32) for k, v in state_dict.items(): if 'embeddings.weight' in k: k = k.replace('embeddings.weight', 'embeddings.embedding_table') ms_ckpt.append({'name': k, 'data': Tensor(v.numpy())}) continue pattern = r&quot;norm.*?\\.weight&quot; if re.search(pattern, k): k = re.sub(&quot;weight&quot;, &quot;gamma&quot;, k) ms_ckpt.append({'name': k, 'data': Tensor(v.numpy())}) continue pattern = r&quot;norm.*?\\.bias&quot; if re.search(pattern, k): k = re.sub(&quot;bias&quot;, &quot;beta&quot;, k) ms_ckpt.append({'name': k, 'data': Tensor(v.numpy())}) continue pattern = r&quot;linear.*\\.weight&quot; if re.search(pattern, k): ms_ckpt.append({'name': k, 'data': Tensor(np.transpose(v.numpy()))}) continue pattern = r&quot;self_attn\\.._proj.weight&quot; if re.search(pattern, k): k = re.sub(r&quot;self_attn\\.._proj.weight&quot;, &quot;self_attn.in_proj_weight&quot;, k) if cnt1 % 3 != 0 or cnt1 == 0: in_p_w = np.concatenate((in_p_w, v.numpy()), axis=1) if (cnt1+1) % 3 == 0: ms_ckpt.append({'name': k, 'data': Tensor(in_p_w).swapaxes(0,1)}) else: # 每三个拼接一次（qkv）对齐 mindspore 的 in_proj_weight in_p_w = v.numpy() cnt1 += 1 continue pattern = r&quot;self_attn\\.._proj.bias&quot; if re.search(pattern, k): k = re.sub(r&quot;self_attn\\.._proj.bias&quot;, &quot;self_attn.in_proj_bias&quot;, k) if cnt2 % 3 != 0 or cnt2 == 0: in_p_b = np.append(in_p_b, v.numpy()) if (cnt2+1) % 3 == 0: ms_ckpt.append({'name': k, 'data': Tensor(in_p_b)}) else: in_p_b = v.numpy() cnt2 += 1 continue # 很关键，padlle权重维度与mindspore的权重维度很多都是反的，特别注意多个维度相等的时候也要转换！ pattern = r&quot;self_attn\\.out_proj.weight&quot; if re.search(pattern, k): ms_ckpt.append({'name': k, 'data': Tensor(np.transpose(v.numpy()))}) continue ms_ckpt.append({'name': k, 'data': Tensor(v.numpy())}) ms_ckpt_path = pth_file.replace('.pdparams','.ckpt') try: save_checkpoint(ms_ckpt, ms_ckpt_path) except: raise RuntimeError(f'Save checkpoint to {ms_ckpt_path} failed, please checkout the path.') return ms_ckpt_path","link":"/2023/04/05/UIE%E8%BF%81%E7%A7%BB/"},{"title":"LeetCode刷题笔记","text":"最近在学习JavaScript，刷题也用顺便巩固，两全其美。 简单题罗马数字转整数 思路 通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。 若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。 123456789101112131415161718192021222324252627282930/** * @param {string} s * @return {number} */var romanToInt = function(s) { // 声明对象，存储罗马数字对应的整数值 let romanOBJ={ 'M' : 1000, 'D' : 500, 'C' : 100, 'L' : 50, 'X' : 10, 'V' : 5, 'I' : 1, }; let result = 0; // 遍历源字符串 for (let i = 0; i &lt; s.length; ++i) { const value = romanOBJ[s[i]]; // 值小的罗马数字在前则减，否则加 if (i &lt; s.length-1 &amp;&amp; value &lt; romanOBJ[s[i + 1]]) { result -= value; } else { result += value; } } return result;}; 最长公共前缀 描述 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串&quot;&quot;。 思路 纵向扫描 123456789101112131415161718192021222324252627282930/** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function (strs) { let i = 0, j = 0; // 需要一个标指记录内层循环是正常结束还是不匹配后的break出来的 let flag = false; // 找出最短的字符串长度 以此为行最大扫描长度 let n = strs.reduce((max, current) =&gt; max &lt; current.length ? current.length : max, 0); if (n === 0) { return &quot;&quot;; } for (j = 0; j &lt; n; j++) { for (i = 0; i &lt; strs.length - 1; i++) { if (strs[i][j] === strs[i + 1][j]) { // 匹配成功继续下一轮循环 continue; } else { // 匹配失败结束循环（此时j的值是最近一次成功的下标） flag = true; break; } } if (flag) { // flag === true说明匹配结束，否则进行下一个字符的匹配 return strs[0].slice(0, j); } } // 这里的返回表示全部匹配成功（几个字符串完全一样） return strs[0].slice(0, n + 1);}; 改进版本 1234567891011121314151617181920var longestCommonPrefix = function(strs) { if (strs.length == 0) return &quot;&quot;; // 行列下标范围 const rows = strs.length; const cols = strs[0].length; for (let i = 0; i &lt; cols; i++) { const firstChar = strs[0][i]; // 首行 i 列字符（以首行字符串为基准比较） for (let j = 1; j &lt; rows; j++) { // 如果第 j 行字符串的长度 === i（此时j行的字符串最短，即最长公共前缀） // 或 字符不匹配（说明最长前缀已经找到） // 此时 i 即最长前缀下标结束位置 if (strs[j].length == i || strs[j][i] != firstChar) { return strs[0].substr(0, i); } } } // 若前面循环没有 return 说明第一行字符串肯定是最长公共前缀 return strs[0];}; 有效的括号 描述 给定一个只包括'('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 思路 栈 遍历字符串，遇左括号入栈，遇右括号进行匹配校验，匹配成功出栈，失败返回false。 遍历完毕，栈为空（说明全部匹配）则返回true，栈不空（说明有括号”落单“）返回false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param {string} s * @return {boolean} */var isValid = function (s) { let stack = []; let i = 0; while (i &lt; s.length) { if (s[i] === '(' || s[i] === '[' || s[i] === '{') { stack.push(s[i]); i++; } else { if (s[i] === ')') { // 注意这里当栈中无元素时，前面表达式值为undefined也不与 '(' 相等 // 正好考虑到了这种情况（其他语言可能出现语法错误 最好加上一个stack不为空的判断条件） // 即 stack.length!==0 &amp;&amp; stack[stk.length-1]==='(' if (stack.slice(-1)[0] === '(') { // 也可以用stack[stack.length - 1] stack.pop(); i++; } else { return false; } } else if (s[i] === ']') { if (stack.slice(-1)[0] === '[') { stack.pop(); i++; } else { return false; } } else if (s[i] === '}') { if (stack.slice(-1)[0] === '{') { stack.pop(); i++; } else { return false; } } } } if (stack.length === 0) { return true; } else { return false; }}; 改进（哈希） 12345678910111213141516171819202122var isValid = function(s) { let m =s.length if(m%2!==0) return false // 奇数个括号肯定不匹配 let map =new Map([ ['{','}'], ['(',')'], ['[',']'] ]) let stk=[] for(ch of s){ if(map.has(ch)){ // 左括号进栈 stk.push(ch) }else{ // 右括号进行匹配校验 // stk.length === 0 说明栈中无左括号，也是不匹配的一种情况 //（其实可以不写，因为stk为空的话那么前面的表达式值为 undefined） if(map.get(stk[stk.length-1])!==ch || stk.length===0) return false else stk.pop() } } if(stk.length==0) return true else return false}; 移除元素 描述 给你一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用O(1)额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 思路 遍历 + splice()，此法有点流氓，我猜不是题目考察本意。 123456789101112131415161718/** * @param {number[]} nums * @param {number} val * @return {number} */var removeElement = function(nums, val) { let i = 0; // 必须用 nums.length而不能提前赋值个变量 // 因为删除过程中长度是变化的 while(i &lt; nums.length){ if(val === nums[i]){ nums.splice(i,1); i--; // 删除之后指针回溯一位 } i++; } return nums.length;}; 官方解法 思路（双指针） 右指针right指向当前将要处理的元素，左指针left指向下一个将要赋值的位置。 如果右指针指向的元素不等于val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移； 如果右指针指向的元素等于val，它不能在输出数组里，此时左指针不动，右指针右移一位。 最后返回left即是数组应当输出得到长度。 1234567891011121314var removeElement = function(nums, val) { let left = 0; let right = 0; while(right &lt; nums.length){ if(nums[right] === val){ right++; }else{ nums[left] = nums[right]; left++; right++; } } return left;}; 搜索插入位置 描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为$O(log_n)$的算法。 思路 有序且要求时间复杂度 -&gt; 二分查找。 需要注意的是，查找失败时应该返回的下标是right + 1 或 left（循环结束条件为left &lt;= right时）。 12345678910111213141516171819202122232425/** * @param {number[]} nums * @param {number} target * @return {number} */var searchInsert = function(nums, target) { let left = 0; let right = nums.length - 1; while(left &lt;= right){ let mid = Math.floor((left+right)/2); if(nums[mid] === target){ return mid; }else if(nums[mid] &lt; target){ left = mid + 1; }else{ right = mid -1; } } return right + 1; /* 根据if的判断条件，left左边的值一直保持小于target，right右边的值一直保持大于等于target，而且left最终一定等于right+1; 这么一来，循环结束后，在left和right之间画一条竖线，恰好可以把数组分为两部分： left左边的部分和right右边的部分，而且left左边的部分全部小于target，并以right结尾； right右边的部分全部大于等于target，并以left为首。所以最终答案一定在left的位置。 */}; 最大子数组和 描述 给你一个整数数组nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 思路（贪心） 从左向右迭代，一个个数字加过去如果tempSum &lt; 0, 那说明加上它只会变得越来越小, 所以我们将tempSum置零后重新开始找子序串。 在迭代的过程中要注意，我们需要用maxSum来不断维持当前的最大子序和, 因为maxSum的值是在不断更新的, 所以我们要及时记录下它的最大值。 有一个注意点是: 当数组全是负数的时候其实是没有问题的。因为在tempSum不断遍历的过程中, 早已将最大值不断传给maxSum，即使tempSum一直是负数被不断置零也不用担心，maxSum还是会记录下最大的那个负数。 12345678910111213141516/** * @param {number[]} nums * @return {number} */var maxSubArray = function(nums) { let maxSum = -Infinity; let tempSum = 0; for(let i = 0; i &lt; nums.length; i++){ tempSum += nums[i]; maxSum = Math.max(tempSum, maxSum); if(tempSum &lt; 0){ tempSum = 0; } } return maxSum;}; 思路（动态规划） 略 最后一个单词的长度 描述 给你一个字符串s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。 单词是指仅由字母组成、不包含任何空格字符的最大子字符串。 思路 反向遍历，忽略尾部的空格，找到最后一个单词。 1234567891011121314151617181920/** * @param {string} s * @return {number} */var lengthOfLastWord = function(s) { let n = s.length; let lastWLen = 0; let flag = false; // 记录是否遍历到非“空格“的标识 for(let i = n-1; i &gt;= 0; i--){ if(s[i] === ' ' &amp;&amp; !flag){ // 此处匹配的是末尾的“空格”字符 continue; }else if(s[i] === ' ' &amp;&amp; flag){ // 此处匹配的是末尾单词前一个空格 return lastWLen; }else{ // 此处匹配的是单词字符 lastWLen++; flag = true; } } return lastWLen; // 注意：若末尾没有空格应当在此处返回，否则函数将无返回值}; 简化（实际上lastWLen本身就可以作为flag） 1234567891011var lengthOfLastWord = function(s) { let lastWLen = 0; for(let i = s.length - 1;i &gt;= 0; i--) { if(s.charAt(i) === ' ' &amp;&amp; lastWLen) { // lastWLen !== 0 表示已经遍历到末尾单词前一个空格 break; } else if(s.charAt(i) !== ' ') { lastWLen++; } } return lastWLen;}; 思路（内置方法） 12345678var lengthOfLastWord = function(s) { return s.trim().split(' ').reverse()[0].length;};var lengthOfLastWord = function(s) { let arr = s.trim().split(' '); return arr[arr.length-1].length;}; 二进制求和 描述 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为非空字符串且只包含数字1和0。 思路（模拟） 长度不同则补零 12345678910111213141516171819202122232425262728/** * @param {string} a * @param {string} b * @return {string} */var addBinary = function(num1, num2) { let res = ''; let i1 = num1.length - 1; let i2 = num2.length - 1; let carry = 0; while (i1 &gt;= 0 || i2 &gt;= 0) { // 补零操作 const x = i1 &gt;= 0 ? num1[i1] - '0' : 0; const y = i2 &gt;= 0 ? num2[i2] - '0' : 0; const sum = x + y + carry; res += (sum % 2); carry = Math.floor(sum / 2); i1--; i2--; } if (carry) res += carry; // res = res + ... 需要反转 // 可以改成 res = ... + res return res.split(&quot;&quot;).reverse().join(&quot;&quot;);};}; x 的平方根 描述 给你一个非负整数x，计算并返回x的 算术平方根 。 由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去。 思路 找出刚好小于或等于x的i*i。 穷举 二分查找 查找范围为[0,x]的一个单调递增数组，找出第一个小于等于x的值。 123456789101112131415161718192021222324/** * @param {number} x * @return {number} */var mySqrt = function(x) { for(let i =0; i &lt;= x; i++){ let leftNum = i*i; let rightNum = (i+1)*(i+1); if(leftNum === x){ return i; }else if( leftNum &lt; x &amp;&amp; rightNum &gt; x){ return i; } }};var mySqrt = function(x) { for(let i =0; i &lt;= x; i++){ if(i*i &gt; x){ return i-1; } } return x; // x === 0 的情况}; 123456789101112131415161718192021var mySqrt = function(x) { let left = 0; let right = x; while(left &lt;= right){ // const mid = Math.floor((left + right)/2); const mid = (left + right) &gt;&gt; 1; // 移位运算相当于除以 2 取整 if(mid * mid === x){ return mid; }else if(mid * mid &lt; x){ left = mid + 1; }else{ right = mid -1; } } // 退出循环后，left 在 right的右边（紧邻） // left 指向比目标数大的最小值 // 而 right 指向比目标值小的最大值 // 即 left 及 left 之右都是比目标值大的 // right 及 right 之左都是比目标值小的 return right;}; 爬楼梯 描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 思路 一般递归（超时） 带记录的递归（保存已计算过的阶） 动态规划 12345678910111213/** * @param {number} n * @return {number} */var climbStairs = function(n) { if(n===2){ return 2; } if(n===1){ return 1; } return climbStairs(n-1) + climbStairs(n-2);}; 1234567891011121314151617181920// 带记录的递归var climbStairs = function (n) { let map = new Map(); // 创建 map 记录递归树结点 return climbStairsMemo(n, map);};let climbStairsMemo = (n, map) =&gt; { if (map.has(n)) { // 如果已经计算过到该阶的方法数量，直接返回即可 return map.get(n); } if (n === 2) { // 到 2 阶有两种方法 map.set(n, 2); } else if (n === 1) { // 到 1阶有一种方法 map.set(n, 1); } else { // 递归调用，并记录到第 n 阶的方法种数 Fn = Fn-1 + Fn-2 map.set(n, climbStairsMemo(n - 1, map) + climbStairsMemo(n - 2, map)); } return map.get(n);}; 1234567891011121314151617181920212223242526272829303132333435363738394041// 动态规划var climbStairs = function (n) { let dp = [0,1,2]; if(n &lt; 3){ return dp[n]; } for(let i = 3; i &lt;= n; i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n];};var climbStairs = function (n) { let s1 = 1; let s2 = 2; if(n &lt; 3){ return n; } for(let i = 3; i &lt;= n; i++){ // let sum = s1 + s2; // s1 = s2; // s2 = sum; s2 = s1 + s2; s1 = s2 - s1; } return s2;};// 打表var climbStairs = function (n) { let dp = [0,1,2]; climbStairsDp(dp,n); return dp[n];};let climbStairsDp = (dp,n) =&gt;{ for(let i = 3; i &lt;= n; i++){ dp[i] = dp[i-1] + dp[i-2]; }}; 删除排序链表中的重复元素 描述 给定一个已排序的链表的头head， 删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。 思路 双指针（其实可以只用一个指针） 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var deleteDuplicates = function(head) { let p = head; let q = head?.next; // 注意 head可能为空需要 ?.否则执行出错 while(q){ if(p.val === q.val){ p.next = q.next; q = q.next; }else{ p = p.next; q = q.next; } } return head;};var deleteDuplicates = function(head) { let p = head; while(p?.next){ // 若p为空等价于 提前判断 if(!head) return head; if(p.val === p.next.val){ p.next = p.next.next; }else{ p = p.next; } } return head;}; 合并两个有序数组 描述 给你两个按 非递减顺序 排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。 请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后n个元素为0，应忽略。nums2的长度为n。 思路 双指针 + 辅助数组 先合并再排序 逆向双指针 12345678910111213141516171819202122232425262728/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) { let tempArr = []; let p = 0; let q = 0; while(p &lt; m &amp;&amp; q &lt; n ){ if(nums1[p] &lt;= nums2[q]){ tempArr.push(nums1[p]); p++; }else{ tempArr.push(nums2[q]); q++; } } if(p === m ){ tempArr.push(...nums2.slice(q)); }else{ tempArr.push(...nums1.slice(p,m)); } nums1.length = 0; // 清空nums1 nums1.push(...tempArr);}; 1234var merge = function(nums1, m, nums2, n) { nums1.splice(m, nums1.length - m, ...nums2); nums1.sort((a, b) =&gt; a - b); // 注意sort()用法}; 12345678910111213141516171819202122232425262728293031323334353637var merge = function(nums1, m, nums2, n) { let p = m - 1; let q = n - 1; let r = m + n - 1; while(p &gt;= 0 &amp;&amp; q &gt;= 0){ if(nums1[p] &gt; nums2[q]){ nums1[r--] = nums1[p--]; }else{ nums1[r--] = nums2[q--]; } } // 若nums1先遍历完，即p &lt; 0，说明nums2还有未遍历完，将nums2剩余数复制至nums1 // 若nums2先遍历完，虽然nums1未遍历完但已经有序且在结果数组（nums1）中，不用调整 if(p &lt; 0){ while(r &gt;= 0){ nums1[r--] = nums2[q--]; } }};var merge = function(nums1, m, nums2, n) { let p1 = m - 1, p2 = n - 1; let tail = m + n - 1; var cur; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 === -1) { cur = nums2[p2--]; } else if (p2 === -1) { cur = nums1[p1--]; } else if (nums1[p1] &gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; }}; 二叉树的中序遍历 描述 给定一个二叉树的根节点root，返回它的中序遍历。 思路（递归） 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number[]} */var inorderTraversal = function(root) { let arr = []; inorderTraversalCall(root, arr); return arr;};let inorderTraversalCall = (root, arr) =&gt; { if(!root){ return ; } inorderTraversalCall(root.left,arr); arr.push(root.val); inorderTraversalCall(root.right,arr);} 相同的树 描述 给你两棵二叉树的根节点p和q，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 思路 DFS BFS 骚操作 12345678910111213141516171819202122232425// DFS/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function(p, q) { if (!p &amp;&amp; !q) { return true } else if (!p || !q) { return false } else if (p.val !== q.val) { return false } else { return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right) }}; 1234// 骚操作 判断两个 js 对象是否相等var isSameTree = function(p, q) { return JSON.stringify(p) === JSON.stringify(q)}; 中等题无重复字符的最长子串 描述 给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。 思路（双指针 + Set） 一个指针遍历，另一个指针记录回溯位置。 12345678910111213141516171819202122232425/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) { let p = 0; let q = p + 1 ; let maxCount = 0; let set = new Set(); while(p &lt; s.length){ if(set.has(s[p])){ maxCount = Math.max(maxCount, set.size); set.clear(); p = q; q++; }else{ set.add(s[p]); p++; } } // 这一步不能少，因为存在 1.整个字符串无重复 2.最尾端的无重复子串最长 的情况 // 以上两种情况 set.has(s[p])为 false 因此不会进入 if 因此不会被记录需要在此进行记录 maxCount = Math.max(maxCount, set.size); // 当然也可将其放入循环尾部，并删除上面的赋值操作 return maxCount;}; 思路（滑动窗口） 123456789101112131415161718192021222324var lengthOfLongestSubstring = function (s) { let len = s.length; let result = 0; let set = new Set(); // 左指针用来收缩窗口 let left = 0; // 右指针用来扩张窗口 let right = 0; while (left &lt; len) { // 如果不重复，就不断扩张窗口，元素添加到set中 while (right &lt; len &amp;&amp; !set.has(s[right])) { set.add(s[right]); right++; } // 到这里说明有元素重复了，先记录子串长度，然后收缩窗口 result = Math.max(result, right - left); // 收缩窗口 set.delete(s[left]); left++; } return result;}; 最长回文子串 描述 给你一个字符串s，找到s中最长的回文子串。] 思路 首先，找到源串中的所有回文串，然后，截取最长的即可。 如何找： 找到源串中头尾相同的子串。 用判断回文串的方法（双指针）判断该子串和是否为回文串。 若是，则与之前找到的回文串比较长度，更长则更新maxStr和maxLen。 否则，换下一子串继续第二步。 12345678910111213141516171819202122232425262728293031323334/** * @param {string} s * @return {string} */var longestPalindrome = function (s) { // 设置两指针用来分别指向相同的两元素 let p; let q; let maxStr = s[0]; // 记录最长回文串 let maxLen = 1; // 记录最长回文串长度 // 遍历寻找两个相同元素 for (let i = 0; i &lt; s.length; i++) { for (let j = i + 1; j &lt; s.length; j++) { if (s[i] === s[j]) { // recp、recq 记录两个相同元素下标方便以后截取 let recp = p = i; let recq = q = j; let tempLen = q - p + 1; // 暂时记录 p、q之间的串长度（可能不是回文串） while (p &lt; q) { // 判断是否为回文串 if (s[++p] === s[--q]) { continue; } else { tempLen = 0; // 不是回文串则将长度置 0（maxLen一定 &gt; 0，因此此串（非回文串）不会被记录） break; } } if (maxLen &lt; tempLen) { // maxLen &lt; tempLen 说明上一次while处理结果一定是回文串，且是比之前长的回文串 maxStr = s.slice(recp, recq + 1); maxLen = tempLen; } } } } return maxStr; Z 字形变换 描述 将一个给定字符串s根据给定的行数numRows，以从上往下、从左到右进行Z字形排列。 思路 模拟 数学规律 123456789101112131415161718192021222324252627282930/** * @param {string} s * @param {number} numRows * @return {string} */var convert = function (s, numRows) { if (numRows == 1) return s; // 注意一行时有点特殊（没有拐角） let resStr = ''; let flag = 1; // 1表示向下，-1表示向上 let arr = Array.from(new Array(numRows), () =&gt; new Array()); let curRow = 0; for (let i = 0; i &lt; s.length; i++) { if (curRow &gt; numRows - 1) { flag = -1; curRow -= 2; } else if (curRow &lt; 0) { flag = 1; curRow += 2; } if (curRow &lt;= numRows - 1 &amp;&amp; flag === 1) { arr[curRow++].push(s[i]); } else if (curRow &gt;= 0 &amp;&amp; flag === -1) { arr[curRow--].push(s[i]); } } for (let item of arr) { resStr += item.join(''); } return resStr;}; 改进（模拟） 妙用flag 123456789101112131415161718var convert = function (s, numRows) { // flag作为每一次扫描到顶（底）的标指（-1为顶 1为底） // 同时作为下标递增（减）的计算参数 let flag = -1; let i = 0; let resStrArr = new Array(numRows).fill(''); if (numRows === 1) { return s; } for (let c of s) { resStrArr[i] += c; if (i === 0 || i === numRows - 1) { flag = -flag; } i += flag; } return resStrArr.join('');}; 盛最多水的容器 描述 给定一个长度为n的整数数组height。有n条垂线，第i条线的两个端点是(i, 0)和(i, height[i])。 找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。 思路 暴力搜索（超时） 双指针 每次移动指向高度较小的指针，面积才有可能大于之前的。 1234567891011121314151617/** * @param {number[]} height * @return {number} */var maxArea = function(height) { let maxArea = 0; for(let i = 0; i &lt; height.length - 1; i++){ for(let j = i +1; j &lt; height.length; j++){ if(height[i] &gt; height[j]){ maxArea = Math.max(height[j]*(j-i), maxArea); }else{ maxArea = Math.max(height[i]*(j-i), maxArea); } } } return maxArea;}; 12345678910111213141516171819/** * @param {number[]} height * @return {number} */var maxArea = function(height) { let maxArea = 0; let left = 0; let right = height.length - 1; while(left &lt; right){ if(height[left] &lt; height[right]){ maxArea = Math.max(maxArea, height[left]*(right-left)); left++; }else{ maxArea = Math.max(maxArea, height[right]*(right-left)); right--; } } return maxArea;}; 整数转罗马数字 描述 给你一个整数，将其转为罗马数字。 思路 模拟（模拟） 根据罗马数字的唯一表示法，为了表示一个给定的整数num，我们寻找不超过num的最大符号值，将num减去该符号值，然后继续寻找不超过num的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至num为0。最后得到的字符串即为num的罗马数字表示。 123456789101112131415161718192021/** * @param {number} num * @return {string} */var intToRoman = function(num) { // let romanOBJ = // {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', // 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5:'V', 4:'IV', 1:'I'}; // js中一般对象属性（键）在不同环境下顺序不同，不一定是按照定义顺序输出（一般升序） // 且属性会自动转化为字符串，因此使用数组 let romanArr = [[1000, &quot;M&quot;], [900, &quot;CM&quot;], [500, &quot;D&quot;], [400, &quot;CD&quot;], [100, &quot;C&quot;], [90, &quot;XC&quot;], [50, &quot;L&quot;], [40, &quot;XL&quot;], [10, &quot;X&quot;], [9, &quot;IX&quot;], [5, &quot;V&quot;], [4, &quot;IV&quot;], [1, &quot;I&quot;]]; let resStr = ''; for(let [val,roman] of romanArr){ while(num &gt;= val){ resStr += roman; num -= val; } } return resStr;}; 三数之和 描述 给你一个包含n个整数的数组nums，判断nums中是否存在三个元素a，b，c ，使得a + b + c = 0 ？请你找出所有和为0且不重复的三元组。 思路 暴力搜索 略 排序 + 双指针 将排好序的数组，依次以某一元素为基准（并去除重复），剩下的元素进行two sum操作（也要去重）。 有序的tow sum：相加之和小于目标值，左指针left++，相加之和大于于目标值右指针right--。 其实相当于三指针，只是指针i是依次从左向右移动而已。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param {number[]} nums * @return {number[][]} */var threeSum = function(nums) { if (nums.length &lt; 3) { return []; } nums.sort((a,b) =&gt; a-b); // 最小值大于 0 或者 最大值小于 0，说明没有无效答案 if (nums[0] &gt; 0 || nums[nums.length - 1] &lt; 0) { return []; } const n = nums.length; const res = []; for (let i = 0; i &lt; n; i++) { // 如果当前值大于 0，和右侧的值再怎么加也不会等于 0，所以直接退出 if (nums[i] &gt; 0) { return res; } // 当前循环的值和上次循环的一样，就跳过，避免重复值 if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) { continue; } // 双指针(two sum) let l = i + 1; let r = n - 1; while(l &lt; r) { const temp = nums[i] + nums[l] + nums[r]; if (temp &gt; 0) { r--; } if (temp &lt; 0) { l++; } if (temp === 0) { res.push([nums[i], nums[l], nums[r]]); // 跳过重复值 while(l &lt; r &amp;&amp; nums[l] === nums[l + 1]) { l++; } // 同上 while(l &lt; r &amp;&amp; nums[r] === nums[r - 1]) { r--; } l++; r--; } } } return res;}; 最接近的三数之和 描述 给你一个长度为n的整数数组nums和一个目标值target。请你从nums中选出三个整数，使它们的和与target最接近。 返回这三个数的和。 思路 排序 + 双指针 三之和稍微变化 1234567891011121314151617181920212223242526272829/** * @param {number[]} nums * @param {number} target * @return {number} */var threeSumClosest = function(nums, target) { nums.sort((a,b) =&gt; a-b); let res = Infinity; // 结果，且过程中保存上一次的最接近值 for(let i = 0; i &lt; nums.length; i++){ let left = i+1; let right = nums.length - 1; while(left &lt; right){ let sum = nums[i] + nums[left] + nums[right]; // 当前sum if(sum &lt; target){ left++; }else if(sum &gt; target){ right--; }else{ // 有a+b+c=0则直接返回target return target; } // 如果上一次的最接近值与目标值之差的绝对值 ＞ 当前值与目标值之差的绝对值 // 则更新最接近值 if(Math.abs(res - target) &gt; Math.abs(sum - target)){ res = sum; } } } return res;}; 电话号码的字母组合 描述 给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。 给出数字到字母的映射如下（与电话按键相同）。 注意1不对应任何字母。 思路 递推组合（广度优先-非标准） 例如：输入&quot;23456&quot;，可先将2和3进行组合，然后保存这个中间结果res。 然后，再将res与4进行组合，再保存至res… 直到把最后一个6组合完毕，则res即最终结果。 递归回溯（深度优先） 123456789101112131415161718192021222324252627282930313233343536var letterCombinations = function (digits) { // 为空特殊处理 if (digits.length === 0) return []; let numMap = new Map([ ['0', ''], ['1', ''], ['2', 'abc'], ['3', 'def'], ['4', 'ghi'], ['5', 'jkl'], ['6', 'mno'], ['7', 'pqrs'], ['8', 'tuv'], ['9', 'wxyz'] ]) let res = []; dfs(&quot;&quot;, digits); return res; function dfs(str, digit) { // 如果字符串为空了，将拼接好的字符加入数组 if (digit.length === 0) res.push(str); else { // 拿到字符串第一个字符，拿到其对应的数字 let numstr = numMap.get(digit[0]); // 对可能性进行组合 for (let i = 0; i &lt; numstr.length; i++) { str += numstr[i]; // 递归组好的 str和下一段字符串 dfs(str, digit.slice(1)) // 回溯 str = str.slice(0, -1); } } }}; 12345678910111213141516171819202122232425262728/** * @param {string} digits * @return {string[]} */var letterCombinations = function(digits) { if(digits === &quot;&quot;){ // 注意考虑为空情况 ***** return []; } let arr = [['a','b','c'],['d','e','f'],['g','h','i'],['j','k','l'], ['m','n','o'],['p','q','r','s'],['t','u','v'],['w','x','y','z']]; // 存储两组字符组第 n 次组合后的结果（初始值为第一个要参与组合的字符组-可看作第 0 次组合结果） // 此数组会递推参与组合，每一次保存当前一次组合产生的结果。 let res = [...arr[+digits[0] - 2]]; // 第 0 个数字对应的符号组（可看作第 0 次组合结果） let i = 1; // 数字下标 while(i &lt; digits.length){ // 当数字遍历完后退出循环 let row = +digits[i] - 2; // arr 中行号从0开始，而数字从2开始才有效，因此取出数字后 -2确定行号 let n = res.length; // 组合前 res 的长度（进入循环长度会随着 push 而增加） for(let j = 0; j &lt; n; j++){ // 上一次组合结果构成的数组与新字符组进行组合 for(let k = 0; k &lt; arr[row].length; k++){ let combination = res[j] + arr[row][k]; res.push(combination); } } res.splice(0,n); // 删除上一次组合的结果，留下最新组合结果 i++; } return res;}; 四数之和 描述 给你一个由n个整数组成的数组nums，和一个目标值target。请你找出并返回满足下述全部条件且不重复的四元组[nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复） 思路（降维） 将四数之和降为两数之和，套两层循环即可（三数之和套一层） 注意： 判断重复 target !== 0时，不能使用 nums[0](nums[n-1]) &lt;(&gt;) target直接返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param {number[]} nums * @param {number} target * @return {number[][]} */var fourSum = function (nums, target) { let n = nums.length; if (n &lt; 4) { return []; } nums.sort((a, b) =&gt; a - b); let res = []; for (let i = 0; i &lt; n - 3; i++) { // i 后至少要有 3 位 while (i - 1 !== -1 &amp;&amp; nums[i] === nums[i - 1]) { i++; } for (let j = i + 1; j &lt; n - 2; j++) { // j 后至少要有 2 位 while (j - 1 !== i &amp;&amp; nums[j] === nums[j - 1]) { j++; } let l = j + 1; let r = n - 1; while (l &lt; r) { let temp = nums[i] + nums[j] + nums[l] + nums[r]; if (temp &lt; target) { l++; } else if (temp &gt; target) { r--; } else if (temp === target) { res.push([nums[i], nums[j], nums[l], nums[r]]); l++; r--; } while (l - 1 !== j &amp;&amp; nums[l] === nums[l - 1]) { l++; } while (r + 1 !== n &amp;&amp; nums[r] === nums[r + 1]) { r--; } } } } return res;}; 优化 1234567891011121314151617181920212223242526272829303132333435363738394041var fourSum = function (nums, target) { let n = nums.length; if (n &lt; 4) { return []; } nums.sort((a, b) =&gt; a - b); let res = []; for (let i = 0; i &lt; n - 3; i++) { while (i - 1 !== -1 &amp;&amp; nums[i] === nums[i - 1]) { i++; } for (let j = i + 1; j &lt; n -2; j++) { while (j - 1 !== i &amp;&amp; nums[j] === nums[j - 1]) { j++; } let l = j + 1; let r = n - 1; while (l &lt; r) { let temp = nums[i] + nums[j] + nums[l] + nums[r]; if (temp &lt; target) { l++; continue; // (*) } else if (temp &gt; target) { r--; continue; // (*) } else if (temp === target) { res.push([nums[i], nums[j], nums[l], nums[r]]); l++; r--; } while (l &lt; r &amp;&amp; nums[l] === nums[l - 1]) { // (*) l++; } while (l &lt; r &amp;&amp; nums[r] === nums[r + 1]) { // (*) r--; } } } } return res;}; 代码随想录 123456789101112131415161718192021222324var fourSum = function(nums, target) { const len = nums.length; if(len &lt; 4) return []; nums.sort((a, b) =&gt; a - b); const res = []; for(let i = 0; i &lt; len - 3; i++) { // 去重i if(i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue; for(let j = i + 1; j &lt; len - 2; j++) { // 去重j if(j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) continue; let l = j + 1, r = len - 1; while(l &lt; r) { const sum = nums[i] + nums[j] + nums[l] + nums[r]; if(sum &lt; target) { l++; continue} if(sum &gt; target) { r--; continue} res.push([nums[i], nums[j], nums[l], nums[r]]); while(l &lt; r &amp;&amp; nums[l] === nums[++l]); while(l &lt; r &amp;&amp; nums[r] === nums[--r]); } } } return res;}; 括号生成 描述 数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。 思路 首先，可以知道的是，在“拼凑”每一组有效括号的过程中，一定满足： 左括号数小于等于括号的对数（(左括号 + 右括号)/2） 右括号小于等于左括号数（当然也小于等于括号对数） 题目要求生成n对的合法括号序列组合，因此可以考虑使用深度优先搜索，将搜索顺序定义为枚举序列的每一位填什么，那么最终的答案一定是由n个左括号和n个右括号组成。 123456789101112131415161718192021var generateParenthesis = function (n) { let l = 0; // 左括号已使用数 let r = 0; // 右括号已使用数 let str = ''; // 每一次成功匹配的括号组（遍历到叶子结点） let res = []; // 结果字符串数组 dfs(n, l, r, str, res); return res;};let dfs = (n, l, r, str, res) =&gt; { if (l == n &amp;&amp; r == n) { // 递归出口 // 可以返回空，重点是将当前成功匹配的括号组字符串加入结果数组 return res.push(str); } if (l &lt; n) { // 剪枝 已加入的左括号数小于括号总数的一半 dfs(n, l + 1, r, str + '(', res); } if (r &lt; l) { // 剪枝 已加入的右括号数小于左括号数（比左括号限制条件强） dfs(n, l, r + 1, str + ')', res); }}; 两两交换链表中的节点 描述 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题。 思路 迭代 递归 迭代 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var swapPairs = function(head) { if(!head || !head.next){ return head; } let prehead = new ListNode(); prehead.next = head; let t = prehead; let p = head; let q = head.next; while(q){ t.next = q; p.next = q.next; q.next = p; t = p; p = p.next; q = p?.next; } return prehead.next;};var swapPairs = function(head) { let prehead = new ListNode(); prehead.next = head; let t = prehead; while(t.next!==null &amp;&amp; t.next.next !==null){ const p = t.next; const q = t.next.next; t.next = q; p.next = q.next; q.next = p; t = p; } return prehead.next;}; 递归 12345678910111213141516171819202122232425```## 初级算法### [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)* 描述 * 给你一个有序数组`nums`，请你**原地**删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新**长度**。 * 不要使用额外的数组空间，你必须在**原地**修改输入数组并在使用`O(1)`额外空间的条件下完成。* 思路 * 遍历有序数组，相等删除```js/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { nums.forEach((value, index, list) =&gt; { for(let i = index+1; value === list[i]; ){ // 注意此处 i 无需自增，因为删除数组元素后，i 已指向“下一个元素” nums.splice(i,1); // 从 i 开始删除 1 个元素（不能用 delete list[i]，会保留位置） } }) return nums.length;}; 官方解法 思路 由于给定的数组nums是有序的,因此对于任意$i&lt;j$，如果$nums[i]=nums[j]$,则对任意$i≤k≤j$必有$nums[i]=nums[k]=nums[j]$，即相等的元素在数组中的下标一定是连续的。利用数组有序的点,可以通过双指针的方法刪除重复元素。 1234567891011121314151617181920var removeDuplicates = function(nums) { const n = nums.length; if (n === 0) { return 0; } // 快慢指针 （ slow 指向预备改变的位置） let fast = 1, slow = 1; while (fast &lt; n) { // 如果 nums[fast] !== nums[fast - 1] // 说明 nums[fast] 和之前的元素都不同 if (nums[fast] !== nums[fast - 1]) { nums[slow] = nums[fast]; ++slow; } // nums[slow]改变后 或 遇到相同元素后 fast 都得加 1 ++fast; } // 遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素。 return slow;}; 买卖股票的最佳时机 II 思路（贪心） 股票买卖策略 单独交易日：设今天价格$p_1$、明天价格$p_2$，则今天买入、明天卖出可赚取金额$p_2-p_1$(负值代表亏损）。 连续上涨交易日： 设此上张交易日股票价格分別为$p_1,p_2,…,p_n$，则第一天买最后一天卖收益最大，即$p_n-p_1$。 等价于每天都买卖。 连续下降交易日：则不买卖收益最大,即不会亏钱。 故只需将相邻两天价格差为正的差价加起来，即为最大收益。 12345678910111213141516/** * @param {number[]} prices * @return {number} */var maxProfit = function(prices) { let n = prices.length; let i = 0, max = 0; while(i&lt;n-1){ if(prices[i]&lt;prices[i+1]){ max += prices[i+1]-prices[i]; } i++; } return max;}; 轮转数组 描述 给你一个数组，将数组中的元素向右轮转k个位置，其中k是非负数。 思路 切片连接 12345678910111213/** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) { // 注意此处 的 -k%nums.length // 当 k &gt; nums.length 时，需要取模 let arr = nums.splice(-k%nums.length, nums.length+1); for(let i = arr.length-1; i &gt;= 0;i--){ nums.unshift(arr[i]); }}; 改进版本 123456var rotate = function (nums, k) { k = k % nums.length; // arr.splice()返回被删除的数组 let temp = nums.splice(-k); nums.splice(0, 0, ...temp) // ...ES6扩展运算符}; 存在重复元素 描述 给你一个整数数组nums。如果任一值在数组中出现至少两次，返回true；如果数组中每个元素互不相同，返回false。 思路（超时） 遍历数组后删除对应元素 使用includes()判断是否任然存在该元素 123456789101112131415161718/** * @param {number[]} nums * @return {boolean} */var containsDuplicate = function (nums) { let flag = false; nums.forEach((item, index, array) =&gt; { let temp = item; // array.splice(index, 1); // 不能使用splice删除，因为不会保留位置 // 而index是根据原数组得来的，会导致删除的元素不对 delete array[index]; if (array.includes(temp)) { flag = true; } }) return flag;}; 思路（排序） 在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。 12345678910var containsDuplicate = function(nums) { nums.sort((a, b) =&gt; a - b); const n = nums.length; for (let i = 0; i &lt; n - 1; i++) { if (nums[i] === nums[i + 1]) { return true; } } return false;}; 思路（哈希表） 对于数组中每个元素，将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。 12345678910var containsDuplicate = function(nums) { const set = new Set(); for (const x of nums) { if (set.has(x)) { return true; } set.add(x); } return false;}; 只出现一次的数字 描述 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 思路（空间复杂度：$O(n)$） 使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。 使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。 使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。 思路（位运算） 任何数和$0$做异或运算，结果仍然是原来的数，即$a⊕0=a$。 任何数和其自身做异或运算，结果是$0$，即$a⊕a=0$。 异或运算满足交换律和结合律 $a⊕b⊕a=b⊕(a⊕a)$ $b⊕(a⊕a)=b⊕0=b$ 数组中的全部元素的异或运算结果即为数组中只出现一次的数字。 12345678/** * @param {number[]} nums * @return {number} */ // 位运算var singleNumber = function(nums) { return nums.reduce((prev, curr) =&gt; prev ^ curr);}; 12345678910111213// 哈希var singleNumber = function(nums) { const map = {} nums.forEach(val =&gt; { // 存在则 +1 不存在则 1 map[val] = map[val] + 1 || 1; }) for(let key in map) { if(map[key] === 1) { return key; } }}; 两个数组的交集 II 描述 给你两个整数数组nums1和nums2，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 思路 分别以两个数组对的数组元素为键，出现次数为值，创建哈希表。然后遍历两个哈希表找出共同元素，插入n次入数组（n为较小值）。 12345678910111213141516171819202122232425262728293031323334353637/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ // value：数组元素（作为键）；count：出现次数（作为值）；var intersect = function(nums1, nums2) { let map1 = new Map(); let map2 = new Map(); let arr = []; nums1.forEach(value =&gt; { // map1[value] = map1.get((value)) + 1 || 1; 建议使用 set map1.set(value,map1.get((value)) + 1 || 1); }) nums2.forEach(value =&gt; { map2.set(value,map2.get((value)) + 1 || 1); }) for(let key1 of map1.keys()){ for(let key2 of map2.keys()){ if(key1===key2){ let count1 = map1.get(key1); let count2 = map2.get(key2); if(count1 &gt;= count2){ for(let i = 1; i&lt;= count2; i++){ arr.push(key2); } }else{ for(let i = 1; i&lt;= count1; i++){ arr.push(key1); } } } } } return arr;}; 官方解法 思路（一个哈希表） 首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。 为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。 123456789101112131415161718192021222324252627282930var intersect = function(nums1, nums2) {// 长短交换判定 if (nums1.length &gt; nums2.length) { return intersect(nums2, nums1); } const hashmap = new Map()// 将较短的nums1中的元素与个数存入hashmap for (let num of nums1) { let count = hashmap.get(num) || 0; hashmap.set(num, count+1); } let res = [], index = 0;// 遍历nums2，遇到重复则count--并更新hashmap// 遇到重复说明两个数组都有该元素// cout==0说明先存进 hashmap 中的数组的对应某元素已经全部加入新数组中 for (let num of nums2) { let count = hashmap.get(num) || 0; if (count &gt; 0) { res[index++] = num; count--;// 更新 hashmap，以count状态作为判断条件 if (count &gt; 0) { hashmap.set(num, count); } else { hashmap.delete(num); } } } return res;}; 思路（排序+双指针） 首先对两个数组进行排序，然后使用两个指针遍历两个数组。 初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。 12345678910111213141516171819var intersect = function(nums1, nums2) {//将两个数组从小到大排序 nums1.sort((a,b) =&gt; a-b); nums2.sort((a,b) =&gt; a-b); let res = []; let key1 = 0, key2 = 0, index = 0;//在两个指针不达边界的前提下不断推进 while(key1 &lt; nums1.length &amp;&amp; key2 &lt; nums2.length){//判断nums1[key1]与nums2[key2]的大小，分出大于小于等于三种情况 if(nums1[key1] &lt; nums2[key2]) key1++; else if(nums1[key1] &gt; nums2[key2]) key2++; else{ res[index++] = nums1[key1]; key1++; key2++; } } return res;}; 加一 描述 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位，数组中每个元素只存储单个数字。 你可以假设除了整数0之外，这个整数不会以零开头。 思路（js方法） 数组 -&gt; 大整数 -&gt; +1 -&gt; 数组（-&gt;表示转换类型） 基于js是一门非常高级的语言，已经封装好了很多方法，直接调用方法完成，虽然方便但忽略了算法。 123456789101112/** * @param {number[]} digits * @return {number[]} */var plusOne = function(digits) { // 将数组转化成 字符串 =&gt; 大整数（否则可能会超出范围） let num = BigInt(digits.join('')); num++; // num = num.toString() // let arr = Array.from(num); return num.toString().split('');}; 官方解法 思路（找出最长的后缀9） 如果digits的末尾没有9，例如[1,2,3]，那么我们直接将末尾的数加一，得到[1,2,4]并返回； 如果digits的末尾有若干个9，例如[1,2,3,9,9]，那么我们只需要找出从末尾开始的第一个不为9的元素，即3，将该元素加一，得到[1,2,4,9,9]。随后将末尾的9全部置零，得到[1,2,4,0,0]并返回。 如果digits的所有元素都是9，例如[9,9,9,9,9]，那么答案为[1,0,0,0,0,0]。我们只需要构造一个长度比digits多1的新数组，将首元素置为1，其余元素置为0即可。 12345678910111213141516171819var plusOne = function(digits) { const n = digits.length; // 找出第一个不为 9 的元素，将其加 1 并将后续所有元素置零 // 包括了第一二种情况 for (let i = n - 1; i &gt;= 0; --i) { if (digits[i] !== 9) { ++digits[i]; for (let j = i + 1; j &lt; n; ++j) { digits[j] = 0; } return digits; } } // digits 中所有的元素均为 9（第三种情况） const ans = new Array(n + 1).fill(0); ans[0] = 1; return ans;}; 移动零 描述 给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 思路 考虑到js对数组封装的方法丰富，就不使用找零移动法了 将数组中为0的元素删除，并计数count，删除全部0后，在数组末尾插入count个0。 123456789101112131415161718192021222324252627282930/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) { let n = nums.length; let count = 0; for(let i = 0; i &lt; n; i++){ if(nums[i]===0){ nums.splice(i,1); count++; n--; // 删除元素后长度 n 应减 1 i--; // 删除元素后当前下标实际指向的是下一个元素应减 1 } } while(count){ nums.push(0); count--; }};// 错误代码 nums.forEach((value,index,arr) =&gt; { if(value === 0){ arr.splice(index,1); // forEach()中的 index 虽然在函数体中改变，但不会有效果 index--; count++; } }) 官方解法 思路（双指针 类似冒泡排序） 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。 123456789101112131415161718192021// 还是写复杂了呀var moveZeroes = function (nums) { let n = nums.length; for (let i = 0; i &lt; n; i++) { if (nums[i] === 0) { // 找到第一个为 0 的元素 let j = 0; // 写在 for循环外 因为for循环外 要用 for (j = i + 1; j &lt; n; j++) { if (nums[j] !== 0) { // 如果 j 指向非 0 则交换 nums[i] = nums[j]; nums[j] = 0; break; } } // 当 j 指向最后一个元素（此时数组已经任务） // 可以结束最外层循环 if (j &gt; n-1) break; } } }}; 123456789101112131415161718// 这个好点// 两个指针都从左侧出发，左指针遇 0 等待，与下一个非零数交换var moveZeroes = function(nums) { let n = nums.length; let left = 0, right = 0; for(let i = 0; i &lt; n; i++){ if(nums[i]!==0){ // 注意 这里必须使用 temp 变量而不能直接使用 0 赋值 // 原因是：开始时 l r 指向同一个元素且可能不为 0 // 注意与上面写的区别 let temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; } right++; }} 有效的数独 描述 请你判断一个9 x 9的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。 空白格用’.’表示。 思路（三次遍历） 利用哈希唯一性，按规则扫描表格内的数，插入哈希表，若已存则在返回false；若扫描完成未发现重复则返回true。 分别按行、列、3 × 3块扫描。 其中块扫描按块进行列扫面，即先扫描左边3 × 9组成的3个列块，然后向右依次扫描。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param {character[][]} board * @return {boolean} */var isValidSudoku = function (board) { let hash = new Map(); let len = 9; let llen = 3; // 每一个小块边长 3 // 判断行 for (let i = 0; i &lt; len; i++) { for (let j = 0; j &lt; len; j++) { // &quot;.&quot;代表空，不作为重复条件判定 if (hash.has(board[i][j]) &amp;&amp; board[i][j] !== '.') { return false; } else { hash.set(board[i][j], 0); // 这里的value 0 没啥用 } } hash.clear(); } // 判断列 for (let i = 0; i &lt; len; i++) { for (let j = 0; j &lt; len; j++) { if (hash.has(board[j][i]) &amp;&amp; board[j][i] !== '.') { return false; } else { hash.set(board[j][i], 0); } } hash.clear(); } // 判断3*3 // iStart、jStart分别代表行、列开始的下标 let iStart = 0, jStart = 0; // jStart &lt; 9 扫描结束（已经扫到最右下角的块） while (jStart &lt; 9) { // 扫描每一 3 × 3块 for (let i = iStart; i &lt; llen + iStart; i++) { for (let j = jStart; j &lt; llen + jStart; j++) { if (hash.has(board[i][j]) &amp;&amp; board[i][j] !== '.') { return false; } else { hash.set(board[i][j], 0); } } } hash.clear(); // 某一块扫描完成，清除哈希表 iStart += 3; // 修改iStart 至下一块 行开始位置 if (iStart &gt;= 9) { // iStart &gt;= 9 说明某一“块列”扫描完成 iStart = 0; // 重置 iStart 至下一列”块列“ 的行开始位置 jStart += 3; // 修改 jStart 至下一列“块列” 的列开始位置 } } return true;}; 官方解法 思路（一次遍历） 创建二维数组rows和columns分别记录数独的每一行和每一列中的每个数字的出现次数，创建三维数组 subbozes记录数独的每一个小九官格中的每个数字的出现次数。 其中$rows[i][index]、\\textit{columns}[j][\\textit{index}]$ $columns[j][index]$和$subboxes[⌊\\frac{i}{3}⌋][⌊\\frac{j}{3}⌋][index]$ 分别表示数独的第i行第j列的单元格所在的行、列和小九宫格中,数字index+1出现的次数,其中0≤index&lt;9,对应的数字index+1满足1≤inde+1≤9 12345678910111213141516171819202122var isValidSudoku = function(board) { // arr.map()：对数组的每个元素都调用函数，并返回结果数组 const rows = new Array(9).fill(0).map(() =&gt; new Array(9).fill(0)); const columns = new Array(9).fill(0).map(() =&gt; new Array(9).fill(0)); const subboxes = new Array(3).fill(0).map(() =&gt; new Array(3).fill(0).map(() =&gt; new Array(9).fill(0))); for (let i = 0; i &lt; 9; i++) { for (let j = 0; j &lt; 9; j++) { const c = board[i][j]; if (c !== '.') { const index = c.charCodeAt() - '0'.charCodeAt() - 1; rows[i][index]++; columns[j][index]++; // i：0-2；j：0-2代表一个 3×3 单元格 subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index]++; if (rows[i][index] &gt; 1 || columns[j][index] &gt; 1 || subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index] &gt; 1) { return false; } } } } return true;}; 旋转图像 描述 给定一个n×n的二维矩阵matrix表示一个图像。请你将图像顺时针旋转90度。 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 思路 找出旋转前后下标变化规律 关键等式： matrixNew[col][n−row−1]=matrix[row][col] 12345678910111213141516/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */var rotate = function(matrix) { let len = matrix.length; for(let i =0; i &lt; Math.floor(len/2); i++){ for(let j = 0; j &lt; Math.floor((len+1)/2); j++){ let temp = matrix[i][j]; matrix[i][j] = matrix[len-j-1][i]; matrix[len-j-1][i] = matrix[len-i-1][len-j-1]; matrix[len-i-1][len-j-1] = matrix[j][len-i-1]; matrix[j][len-i-1] = temp; } }}; 反转字符串 描述 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 思路 调用内建方法reverse() 双指针 解构语法 位运算 1234567891011/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead. */var reverseString = function(s) { let left = 0; let right = s.length - 1; while(left &lt; right){ [s[left++],s[right--]] = [s[right],s[left]]; }}; 整数反转 描述 你一个32位的有符号整数x，返回将x中的数字部分反转后的结果。 如果反转后整数超过32位的有符号整数的范围[−2^31, 2^31 − 1] ，就返回0。 假设环境不允许存储64位整数（有符号或无符号）。 思路 先将输入整数的位数计算出来，以便计算每一位应对应的权重（转化后在什么位上）。 通过整除、取余获取尾部数字，乘以转化后对应的位的权重，然后相加。 12345678910111213141516171819202122232425262728/** * @param {number} x * @return {number} */var reverse = function (x) { let flag = false; if (x &lt; 0) { flag = true; } let result = 0; // 这里将它转化成绝对值 // 因为 对于负数 floor()向下取整时：floor(-1.2) === 2 而非 1 let temp = x = Math.abs(x); let count = 0; while (temp) { temp = Math.floor(temp / 10); count++; } while (count) { result += x % 10 * 10 ** (count - 1); x = Math.floor(x / 10); count--; } if (result &lt; (-2) ** 31 || result &gt; 2 ** 31 - 1) { return 0; } return flag ? -result : result;}; 官方解法 12345678910111213var reverse = function(x) { let rev = 0; while (x !== 0) { const digit = x % 10; // 向 0 取整 x = ~~(x / 10); // ~~ 正数时是Math.floor()的替代品 rev = rev * 10 + digit; if (rev &lt; Math.pow(-2, 31) || rev &gt; Math.pow(2, 31) - 1) { return 0; } } return rev;}; 字符串中的第一个唯一字符 描述 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 思路 遍历字符串利用hashmap以字符为key、{index:null,count:null}为value，存储字符的下标index和出现次数count。 遍历哈希表找到第一个count === 1的映射，并返回其下标。 1234567891011121314151617181920212223242526272829/** * @param {string} s * @return {number} */var firstUniqChar = function (s) { let char = s.split(''); let map = new Map(); char.forEach((c, index) =&gt; { if (map.has(c)) { map.get(c).count++; } else { map.set(c, { index: index, count: 1 }); } }) for (let item of map.values()) { if (item.count === 1) { return item.index; } } return -1; // 字符串没有不重复的 // 不能用 forEach()遍历，因为难以跳出整个循环 // map.forEach((obj) =&gt; { // if(obj.count === 1){ // result = obj.index; // return false; // 仅跳出本次循环 而非整个 forEach // } // })}; 官方解法 思路 我们可以对字符串进行两次遍历。 在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。 在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回-1。 12345678910var firstUniqChar = function(s) { //_.countBy方法创建一个由键组成的对象，这些键是通过运行iteratee的collection的每个元素的结果生成的。每个 key 的对应值是iteratee返回 key 的次数。 const frequency = _.countBy(s); for (const [i, ch] of Array.from(s).entries()) { // arr.entries()返回[key,value] if (frequency[ch] === 1) { return i; } } return -1;}; 有效的字母异位词 描述 给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。 注意：若s和t中每个字符出现的次数都相同，则称s和t互为字母异位词。 思路 首先判断字符串长度是否相等，不相等直接return false。 利用hashmap，扫描字符串字符存入map并记录出现次数。 扫描第二个字符串判断map中是否已经存在： 若存在则次数减1，若次数减至&lt; 0则return false； 若不存在return false（不存在说明第二个串用了第一个没有使用的字符） 。 1234567891011121314151617181920212223242526272829/** * @param {string} s * @param {string} t * @return {boolean} */var isAnagram = function(s, t) { let map = new Map(); if(s.length !== t.length){ return false; } for(let item of s){ if(map.has(item)){ map.set(item, map.get(item)+1); }else{ map.set(item,1); } } for(let item of t){ if(map.has(item)){ map.set(item, map.get(item)-1); if(map.get(item) &lt; 0){ return false; } }else{ return false; } } return true;}; 官方解法 思路 排序 判断字符串是否相等 123var isAnagram = function(s, t) { return s.length == t.length &amp;&amp; [...s].sort().join('') === [...t].sort().join('');}; 验证回文串 描述 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 思路 双指针 正则表达式（两年前学过忘记了，用得很笨拙） 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param {string} s * @return {boolean} */var isPalindrome = function (s) { // 为什么要转化成数组？ // 因为js中字符串不可更改 // 即 s[0]=s[0].toLowerCase()无效 let strArr = s.split(''); let l = 0; let r = strArr.length - 1; // 正则：数字和字母 let re = /[0-9A-Za-z]/g; // 等同于/\\w/g // 正则：大写字母 let reUp = /[A-Z]/g; while (l &lt; r) { // 如果不是数字或字母 指针移动 if (!strArr[l].match(re)) { l++; continue; // 指针移动后得先再判断 l &lt; r?和再次判断是否为数字或字母 } if (!strArr[r].match(re)) { r--; continue; } // 如果是大写字母 转换成小写 if (strArr[l].match(reUp)) { strArr[l] = strArr[l].toLowerCase(); } if (strArr[r].match(reUp)) { strArr[r] = strArr[r].toLowerCase(); } if (strArr[l] === strArr[r]) { l++; r--; } else { return false; } } return true;}; 其他解法 思路 和我一样，但是正则比我用的好 12345678910111213141516var isPalindrome = function(s) { // s = s.replace(/[^\\w]/g, '').toLowerCase() // 题目要求只考虑字母和数字字符，所以上面的写法也没啥问题 s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase() // 还没学js正则的api 上面我写的像坨xx let left = 0; let right = s.length - 1; while(left &lt; right) { if(s[left] != s[right]) { return false } left++ right-- } return true}; 实现 strStr() 描述 实现strStr()函数。 给你两个字符串haystack和needle，请你在haystack字符串中找出needle字符串出现的第一个位置（下标从0开始）。如果不存在，则返回-1 。 说明： 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当needle是空字符串时我们应当返回0。这与C语言的strstr()以及Java的indexOf()定义相符。 思路（暴力搜索） 双指针 分别指向源串和子串，比较、回溯（源串回溯至第一个匹配位置的下一位，模式串回溯至0） 模式串指针指向最后一位字符的下一位，则代表匹配成功。 源串指针指向最后一位字符的下一位，且此时模式串没有指向最后一位字符的下一位则匹配失败。 1234567891011121314151617181920212223242526272829/** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function (haystack, needle) { let hLen = haystack.length; let nLen = needle.length; if (nLen &gt; hLen) { // 模式串长度大于源串必定找不到 return -1; } if (needle === &quot;&quot;) { // 别忘记这个特殊模式串 return 0; } let p = 0, q = 0; while (p &lt; hLen) { if (haystack[p] === needle[q]) { // 字符匹配指针移动 p++; q++; if (q &gt; nLen - 1) { // 模式串指针已经移动到“溢出”字符串？ return p - nLen; // 代表匹配成功，返回源串下标（注意下标的计算） } } else { // 否则回溯 p = p - q + 1; // p指针回溯（注意计算） q = 0; // q指针回溯 } } return -1;}; 其他思路 KMP（略） 滑动窗口（略） 删除链表中的节点 描述 请编写一个函数，用于删除单链表中某个特定节点。在设计函数时需要注意，你无法访问链表的头节点head，只能直接访问要被删除的节点 。 题目数据保证需要删除的节点不是末尾节点。 思路 复制下一个结点的值 -&gt; 删除下一个节点。 (我觉得我又行了!） 123456789101112131415/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead. */var deleteNode = function(node) { node.val = node.next.val; node.next = node.next.next;}; 反转链表 描述 给你单链表的头节点head，请你反转链表，并返回反转后的链表。 思路 略 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function(head) { let p = null; let q = head; let r = head?.next; // head可能为空 while(q){ q.next = p; p = q; q = r; r = r?.next; // 遍历到最后时，尾部节点 r 可能为空 } return p;};// 这种解法排除了可能为空而无法调用.next而报错的情况// var reverseList = function(head) {// let prev = null;// let curr = head;// while (curr) {// const next = curr.next;// curr.next = prev;// prev = curr;// curr = next;// }// return prev;// }; 删除链表的倒数第 N 个结点 描述 给你一个链表，删除链表的倒数第n个结点，并且返回链表的头结点。 思路 计算链表长度 首先从头节点开始对链表进行一次遍历，得到链表的长度L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第L-n+1个节点时，它就是我们需要删除的节点。 注意 没有头结点的链表注意表头元素的删除方法需要单独编写 若使用复制删除法，则尾部结点的删除方法也需要单独编写 其他 双指针 由于我们需要找到倒数第n个节点，因此我们可以使用两个指针first和second同时对链表进行遍历，并且first比second超前n个节点。当first遍历到链表的末尾时，second就恰好处于倒数第n个节点。 栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @param {number} n * @return {ListNode} */var removeNthFromEnd = function (head, n) { let sumCount = 0; // 总结点数 链表长度 let p = head; while (p) { sumCount++; p = p.next; } let index = sumCount - n + 1; // 删除第index个结点（从1开始） let count = 1; // 当前遍历到第 count 个结点 p = head; if (index === 1) { // 由于没有头结点，删除首节点时需要单独操作 // 直接让head指向下一个结点 head = p.next; } else if (index === sumCount) { // 删除尾结点需要单独操作 // 当count===index 使 p 指向index -1，被删除的结点前一个元素 while (count &lt; index - 1) { p = p.next; count++; } p.next = null; } else { // 当count===index 使 p 指向index，即，将被删除的结点 while (count &lt; index) { // 除以上情况外，进行常规删除操作 p = p.next; count++; } // 删除操作（赋值替换） p.val = p.next.val; p.next = p.next.next; } return head;}; 合并两个有序链表 描述 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 思路 迭代 递归 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} list1 * @param {ListNode} list2 * @return {ListNode} */var mergeTwoLists = function(list1, list2) { let p = list1; let q = list2; let r = head = new ListNode(undefined,undefined); while(p &amp;&amp; q){ // 如果任意链表遍历至完成（指向null）跳出循环 if(p.val &lt; q.val){ let temp = new ListNode(p.val,null); r.next = temp; r = r.next; p = p.next; }else{ let temp = new ListNode(q.val,null); r.next = temp; r = r.next; q = q.next; } } // 若p(q)空，则将q(p)直接接入新链表即可 if(!p){ r.next = q; }else if(!q){ r.next = p; } return head.next;}; 12345678910111213var mergeTwoLists = function(l1, l2) { if (l1 === null) { return l2; } else if (l2 === null) { return l1; } else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; }}; 回文链表 描述 给你一个单链表的头节点head，请你判断该链表是否为回文链表。如果是，返回true；否则，返回false。 思路 将值复制到数组中后用双指针法 递归 快慢指针 123456789101112131415161718192021222324/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {boolean} */var isPalindrome = function(head) { const vals = []; while (head !== null) { vals.push(head.val); head = head.next; } for (let i = 0, j = vals.length - 1; i &lt; j; ++i, --j) { if (vals[i] !== vals[j]) { return false; } } return true;}; 环形链表 描述 给你一个链表的头节点head，判断链表中是否有环。 思路 利用数据结构集合（或哈希表）的唯一性，也可以用数组的includes()方法 遍历链表加入集合，重复则true，反之true。 快慢指针 定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置head，而快指针在位置head.next。 这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */var hasCycle = function(head) { let p = head; let set = new Set(); while(p){ if(set.has(p)){ return true; }else{ set.add(p); } p = p.next; } return false;}; 123456789101112131415const hasCycle = function(head) { if(head === null || head.next === null) { return false; } let slow = head; let fast = head.next; while (slow) { if(slow === fast) { return true } slow = slow?.next || null; fast = fast?.next?.next || null; } return false;};","link":"/2022/01/24/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"title":"VS Code小坑（HTML代码提示“修复”）","text":"踩坑描述 之前写HTML是在IDEA环境写的，虽然貌似比VS Code方便，但是每次启动都要花一些时间，而且进程过于占内存，所以打算配置VS Code的环境写HTML文档。 由于之前VS Code我主要用来写Python代码，并且安装了Django框架（“罪魁祸首”），神奇的事情发生了。我发现我的HTML文档居然没有代码提示？ 出现原因 前面已经说了Django是罪魁祸首，原因就是Django框架偷偷地改了我的HTML语言模式。 第三排Django HTML语言，我惊了。 解决方法既然问题原因已经找到解决起来接很简单了。 Ctrl+Shift+P调出VS Code命令窗口，选择更改语言模式。 选择HTML语言模式。 HTML文档代码提示恢复正常。 总结VS Code真香","link":"/2020/03/13/VS_Code%E5%B0%8F%E5%9D%91/"},{"title":"python","text":"Python简介 Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。 Python是一种解释型脚本语言，可以应用于以下领域：Web 和 Internet开发、科学计算和统计、人工智能、教育、桌面界面开发、软件开发、后端开发、网络爬虫等。 与C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构。 感受Python的简约-九九乘法表 1234for i in range(1,10): for j in range(1,i+1): print('%d*%d=%d' % (i,j,i*j), end='\\t') print() 输出结果 1234567891*1=12*1=2 2*2=43*1=3 3*2=6 3*3=94*1=4 4*2=8 4*3=12 4*4=165*1=5 5*2=10 5*3=15 5*4=20 5*5=256*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=367*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=498*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=649*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 Python中的注释符号 单行注释 - 以#和空格开头的部分 1# print(&quot;你好,世界！&quot;) 多行注释 - 三个引号开头，三个引号结尾 123456&quot;&quot;&quot;第一个Python程序 - hello, world!Version: 1.0Author: ZTY&quot;&quot;&quot; Python中对变量类型进行转换 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 Python中的运算符（部分） 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 注意 取模运算（“Module Operation”）和取余运算（“Complementation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。 对于整型数a，b来说，取模运算或者求余运算的方法都是: 1.求整数商: c = a/b 2.计算模或者余数: r = a - c*b 求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数);而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。 例如计算:-7 Mod 4 那么:a = -7;b = 4 第一步:求整数商c，如进行求模运算c = -2(向负无穷方向舍入)，求余c = -1(向0方向舍入) 第二步:计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3 练习1 输入半径计算圆的周长和面积 1234567import mathr = float(input('请输入圆的半径：'))p = 2*math.pi*ra = math.pi*r*rprint('周长：%.2f' % p)print('面积：%.2f' % a) 输入年份判断是不是闰年 12345year = int(input('请输入年份: '))# 如果代码太长写成一行不便于阅读 可以使用\\对代码进行折行is_leap = (year % 4 == 0 and year % 100 != 0) or \\ year % 400 == 0print(is_leap) Python中的分支结构 在Python中，要构造分支结构可以使用if、elif和else关键字。相当于C/C++中的if、else if、else关键字。 C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 练习2 百分制成绩转换为等级制成绩 123456789101112score = float(input('请输入成绩: '))if score &gt;= 90: grade = 'A'elif score &gt;= 80: grade = 'B'elif score &gt;= 70: grade = 'C'elif score &gt;= 60: grade = 'D'else: grade = 'E'print('对应的等级是:', grade) Python中的循环结构 python range() 函数可创建一个整数列表，一般用在 for 循环中。 函数语法： 1range(start, stop[, step]) 参数说明： start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）; stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5 step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) for-in循环 如果明确的知道循环执行的次数或者要对一个容器进行迭代，那么我们推荐使用for-in循环 1~100之间的偶数求和 1234sum = 0for x in range(2, 101, 2): sum += xprint(sum) while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。 0~100随机数猜数游戏 1234567891011121314151617import randomanswer = random.randint(1,100)cnt=0while True: cnt +=1 guess = input('请输入你猜的数字') g = int(guess) if g&gt;answer: print('你猜大了') elif g&lt;answer: print('你猜小了') else: print('恭喜你猜对了') breakif cnt&gt;=5:print('你猜了%d次才猜对，太笨了！' %cnt) 和C语言一样，上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 拓展练习 生成斐波那契数列的前20个数 斐波那契数列（Fibonacci sequence），又称黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中提出一个在理想假设条件下兔子成长率的问题而引入的数列，所以这个数列也被戏称为”兔子数列”。斐波那契数列的特点是数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和，形如：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …。 12345a = 0b = 1for _ in range(20): a, b = b, a + b print(a, end=' ') 值得注意的是a, b = b, a + b是并列赋值语句，它与下列语句处理的结果是不同的！前者a和b同时被赋值，后者a先于b被赋值。 12a = bb = a + b Python中的函数与模块 通过例子，研究函数如何定义函数及其特点 12345678from random import randint #引入随机数函数def roll_dice(n=2): &quot;&quot;&quot;摇色子&quot;&quot;&quot; total = 0 for _ in range(n): total += randint(1, 6) return total 123456# 在参数名前面的*表示args是一个可变参数def add(*args): total = 0 for val in args: total += val return total 上述示例说明(定义方法)： 在Python中可以使用def关键字来定义函数。 函数执行完成后我们可以通过return关键字来返回一个值。 特点： 在Python中，函数的参数可以有默认值，也支持使用可变参数。 Python中每个文件就代表了一个模块（module）,使用以下语句from module import function就可以导入在该模块中的函数。 若导入的多个模块中包含同名函数，可通过以下方式区分要使用的函数。 12345import module1 as m1import module2 as m2m1.function()m2.function() 注意：如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，如果你不希望执行这些代码，则需要在这些代码前进行如下操作： 123if __name__ == '__main__': #这里是可执行的代码 原因：__name__是Python中一个隐含的变量它代表了模块的名字，只有被Python解释器直接执行的模块的名字才是__main__。 字符串和常用数据结构字符串的使用 在Python中，字符用单引号或者双引号包围起来，表示一个字符串。 以三个双引号或单引号开头的字符串可以折行。 12345678s1 = '我是字符串！'s2 = &quot;我是字符串！&quot;s3 = &quot;&quot;&quot;我是\\字符串！&quot;&quot;&quot;s4 = '''我是\\字符串！'''print(s1, s2, s3, s4 , end='')#输出结果：我是字符串！ 我是字符串！ 我是字符串！ 我是字符串！ 说明：可以在字符串中使用\\（反斜杠）来表示转义，也就是说\\后面的字符不再是它原来的意义，例如：\\n不是代表反斜杠和字符n，而是表示换行；而\\t也不是代表反斜杠和字符t，而是表示制表符。 如果不希望字符串中的\\表示转义，我们可以通过在字符串的最前面加上字母r来加以说明。 12345678s1 = r'\\'你好世界！\\''s2 = r'\\n\\\\你好世界！\\\\\\n'print(s1)print(s2)'''输出结果：\\'你好世界！\\'\\n\\\\你好世界！\\\\\\n''' Python为字符串类型提供了非常丰富的运算符，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符（切片运算）。 1234567891011121314151617s1 = 'hello ' * 3print(s1) # hello hello hellos2 = 'world's1 += s2print(s1) # hello hello hello worldprint('ll' in s1) # Trueprint('good' in s1) # Falsestr2 = 'abc123456'# 从字符串中取出指定位置的字符(下标运算)print(str2[2]) # c# 字符串切片(从指定的开始索引到指定的结束索引)print(str2[2:5]) # c12print(str2[2:]) # c123456print(str2[2::2]) # c246print(str2[::2]) # ac246print(str2[::-1]) # 654321cbaprint(str2[-3:-1]) # 45 注意： 没有步长的切片：我们用的语法是 s[start:stop] 有步长的切片：我们用的语法是 s[start:stop:stride] 格式化输出字符串的三种方法，例：a * b = 50 常规 12a, b = 5, 10print('%d * %d = %d' % (a, b, a * b)) 字符串方式 12a, b = 5, 10print('{0} * {1} = {2}'.format(a, b, a * b)) 简化 12a, b = 5, 10print(f'{a} * {b} = {a * b}') 其他对字符串的操作 1234567891011121314151617181920212223242526272829303132333435str1 = 'hello, world!'# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find('or')) # 8print(str1.find('shit')) # -1# 与find类似但找不到子串时会引发异常# print(str1.index('or'))# print(str1.index('shit'))# 检查字符串是否以指定的字符串开头print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith('!')) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, '*'))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, ' '))str2 = 'abc123456'# 检查字符串是否由数字构成print(str2.isdigit()) # False# 检查字符串是否以字母构成print(str2.isalpha()) # False# 检查字符串是否以数字和字母构成print(str2.isalnum()) # Truestr3 = ' jackfrued@126.com 'print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip()) 列表 与字符串类似，列表也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在[]中，多个元素用,进行分隔，可以使用for循环对列表元素进行遍历，也可以使用[]或[:]运算符取出列表中的一个或多个元素。 基本操作 123456789101112131415161718192021222324252627 list1 = [1, 3, 5, 7, 100] print(list1) # [1, 3, 5, 7, 100] # 乘号表示列表元素的重复 list2 = ['hello'] * 3 print(list2) # ['hello', 'hello', 'hello'] # 计算列表长度(元素个数) print(len(list1)) # 5 # 下标(索引)运算 print(list1[0]) # 1 print(list1[-1]) # 100 #修改列表元素 list1[2] = 300 print(list1) # [1, 3, 300, 7, 100] ````* 遍历操作 ```python # 通过循环用下标遍历列表元素 for index in range(len(list1)): print(list1[index]) # 通过for循环遍历列表元素 for elem in list1: print(elem) # 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值 for index, elem in enumerate(list1): print(index, elem) 添加或移除元素 添加元素 123456789list1 = [1, 3, 5, 7, 100]# 在最后延长list1.append(200)# 在下表1位置插入list1.insert(1, 400)# 合并两个列表list1.extend([1000, 2000])# list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000] 移除元素 12345678910# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1: list1.remove(3)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0) # 删除下标为0的元素list1.pop(len(list1) - 1) # 删除表末元素（根据下标）print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear() 和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表。操作方法类似，就不例举了。 排序操作 123456789list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']# sorted函数返回列表排序后的拷贝不会修改传入的列表list2 = sorted(list1)# 倒序排序list3 = sorted(list1, reverse=True)# 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序list4 = sorted(list1, key=len)# 给列表对象发出排序消息直接在列表对象上进行排序（直接改变list1）list1.sort(reverse=True) 生成式和生成器 用列表的生成表达式语法创建列表容器-生成式 12345f = [x for x in range(1, 10)]print(f) # [1, 2, 3, 4, 5, 6, 7, 8, 9]f = [x + y for x in 'AB' for y in '123']print(f) # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3'] 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间。 通过生成器获取到数据-生成器 1234567import sysf = (x ** 2 for x in range(1, 10))print(sys.getsizeof(f)) # 120print(f) # &lt;generator object &lt;genexpr&gt; at 0x000001FE58DBA4F8&gt;for val in f: print(val, end=' ') # 1 4 9 16 25 36 49 64 81 生成器可以获取到数据但它不占用额外的空间存储数据,每次需要数据的时候就通过内部的运算得到数据需要花费额外的时间。 生成器定义的其他方式-通过yield关键字将一个普通函数改造成生成器函数。 123456789101112131415# 斐波拉切数列def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield adef main(): for val in fib(20): print(val)if __name__ == '__main__': main() 简单理解：yield就是return返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后(下一行)开始。 元组 元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，与列表的区别是元组的元素不能修改。 12345678910111213141516# 定义元组t = ('周天宇', '男', 20, '四川成都')print(t) # ('周天宇', 男, 20, '四川成都')# 获取元组中的元素print(t[0]) # 周天宇# 遍历元组中的值for member in t: print(member, end=' ') # 周天宇 男 20 四川成都# 将元组转换成列表person = list(t)print(person) # ['周天宇', '男', 20, '四川成都']# 列表是可以修改它的元素的person[0] = '周杰伦'print(person) # ['周杰伦', '男', 20, '四川成都']# 将列表转换成元组t2 = tuple(person) 如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组。 如果一个函数要返回多个值，可以使用元组。 集合 Python中的集合跟数学上的集合是一致的，不允许有重复元素（自动删除），而且可以进行交集、并集、差集等运算。 123456789# 创建集合的字面量语法set1 = {1, 2, 3, 3, 3, 2}print(set1) # {1, 2, 3,}print('Length =', len(set1))# 创建集合的构造器语法set2 = set(range(1, 10))set3 = set((1, 2, 3, 3, 2, 1))# 创建集合的推导式语法(推导式也可以用于推导集合)set4 = {num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0} 添加和删除元素 123456set1.add(4)set2.update([11, 12])set2.discard(5) # 去除5if 4 in set2: set2.remove(4)print(set3.pop()) # pop()删除并返回值 discard()和remove()的区别是remove的元素在set当中没有的话会报错，而discard不会。 交集、并集、差集等运算 1234567891011121314151617181920212223# 交集print(set1 &amp; set2)# print(set1.intersection(set2))# 并集print(set1 | set2)# print(set1.union(set2))# 差集print(set1 - set2)# print(set1.difference(set2))# 对称差print(set1 ^ set2)# print(set1.symmetric_difference(set2))# 判断子集print(set2 &lt;= set1)# print(set2.issubset(set1))# 判断超集print(set1 &gt;= set2)# print(set1.issuperset(set2)) 字典 它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。 创建字典 12345678910111213# 创建字典的字面量语法scores = {'周天宇': 95, '胡歌': 78, '周杰伦': 82}print(scores) # {'周天宇': 95, '胡歌': 78, '周杰伦': 82}# 创建字典的构造器语法items1 = dict(one=1, two=2, three=3, four=4)# 通过zip函数将两个序列压成字典items2 = dict(zip(['a', 'b', 'c'], '123'))# 创建字典的推导式语法items3 = {num: num ** 2 for num in range(1, 10)}print(items1, items2, items3)# {'one': 1, 'two': 2, 'three': 3, 'four': 4}# {'a': '1', 'b': '2', 'c': '3'}# {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} 其他操作 1234567891011121314151617# 通过键可以获取字典中对应的值print(scores['周天宇']) # 95# 对字典中所有键值对进行遍历for key in scores: # key只被“返回键”。 print(f'{key}: {scores[key]}')# 更新字典中的元素scores['周天宇'] = 85 # 修改scores['林俊杰'] = 71 # 增添scores.update(王力宏=77, 陶喆=87) # 增添print(scores.get('蔡依林'))# get方法也是通过键获取对应的值但是可以设置默认值print(scores.get('蔡依林', 60))# 删除字典中的元素print(scores.popitem())print(scores.pop('周天宇', 85))# 清空字典scores.clear() 练习3 跑马灯文字 12345678910111213import osimport timedef main(): text = '蝉鸣的夏季，我想遇见你......' while True: os.system('cls') print(text) time.sleep(0.2) text = text[1:] + text[0]if __name__ == &quot;__main__&quot;: main() os.system('cls')清除屏幕显示内容。 time.sleep(0.2)休眠0.2秒。 返回文件后缀 123456789101112def get_(fname,has_dot = False): pos = fname.rfind('.') if 0 &lt; pos &lt; len(fname) - 1: index = pos if has_dot else pos +1 return fname[index:] else: return ''if __name__ == &quot;__main__&quot;: fname = input('文件名') has_dot = True print(get_(fname,has_dot)) Pythonrfind()返回字符串最后一次出现的位置，如果没有匹配项则返回-1。 语法str.rfind(str, beg=0 end=len(string)) str — 查找的字符串。 beg — 开始查找的位置，默认为0。 end — 结束查找位置，默认为字符串的长度。 返回最大值和第二大值 1234567891011121314def max2(x): m1, m2 = (x[0], x[1]) if x[0] &gt; x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] &gt; m1: m2 = m1 m1 = x[index] elif x[index] &gt; m2: m2 = x[index] return m1, m2if __name__ == &quot;__main__&quot;: x = [5,9,12,8,36,4] a, b = max2(x) print(a, b) Python中返回多个值的实质是返回一个tuple类型（元组）。 return (a, b)也可以写作 return a, b。 (c, d) = function(x)也可以写作c, d = function(9, 4)。 面向对象编程基础 面向对象有三大支柱：封装、继承和多态。 封装：我自己对封装的理解是”隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口。 类和对象 类是对象的蓝图和模板，对象是类的实例。 定义类：Python中可以使用class关键字定义类。 123456789101112131415161718class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》。' % self.name) else: print('%s正在观看《不能说的秘密》。' % self.name) 创建和使用对象 12345678910111213def main(): # 创建学生对象并指定姓名和年龄 stu1 = Student('周天宇', 20) # 给对象发study消息 stu1.study('Python程序设计') # 给对象发watch_movie消息 stu1.watch_movie() stu2 = Student('小屁孩', 12) stu2.study('思想品德') stu2.watch_movie()if __name__ == '__main__': main() 访问可见性问题 在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头。 1234567891011121314151617181920class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo)if __name__ == &quot;__main__&quot;: main() 事实上，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问。如果你知道更换名字的规则仍然可以访问到它们。 12test._Test__bar()print(test._Test__foo) 在实际开发中，并不建议将属性设置为私有的，因为这会导致子类无法访问。所以大多数Python程序员会遵循一种命名惯例，就是让属性名以单下划线开头来表示属性是受保护的。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻。 123456def __init__(self, foo): self._foo = foo # 此处改为单下划线def _bar(self): # 此处改为单下划线 print(self._foo) print('_bar') Python类中的那些魔法方法，如__str__、__repr__等，这些方法并不是私有成员，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名。 面向对象进阶@property装饰器 我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。 1234567891011121314151617181920212223242526272829303132333435363738class Person(object): def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('周天宇', 16) person.play() person.age = 20 person.play() # person.name = '白元芳' # AttributeError: can't set attribute（name属性未添加修改器所以不可通过这种方式修改）if __name__ == '__main__': main() slots魔法：限制动态添加变量 Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。 但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 12345678910111213141516171819202122232425262728293031323334class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('周天宇', 20) person.play() person._gender = '男' # person._is_handsome = True # AttributeError: 'Person' object has no attribute '_is_handsome'(类开头的__slots__限定了不能添加新的属性。) 合理使用 __slots__ 属性可以节省一个对象所消耗的空间。一个普通对象使用一个dict来保存它自己的属性，你可以动态地向其中添加或删除属性，但是如果使用 __slots__属性，那么该对象用来保存其自身属性的结构一旦创建则不能再进行任何修改。因此使用slot结构的对象节省了一部分开销。 Python 实例方法、类方法和静态方法实例方法，类方法与静态方法的区别 用代码说明实例方法，类方法，静态方法的区别。注意下述代码中方法foo，class_foo，static_foo的定义以及使用。 123456789101112131415161718192021222324252627282930class Kls(object): def foo(self, x): print('executing foo(%s,%s)' % (self, x)) @classmethod def class_foo(cls,x): print('executing class_foo(%s,%s)' % (cls,x)) @staticmethod def static_foo(x): print('executing static_foo(%s)' % x)ik = Kls()# 实例方法ik.foo(1)print(ik.foo)print('==========================================')# 类方法ik.class_foo(1)Kls.class_foo(1)print(ik.class_foo)print('==========================================')# 静态方法ik.static_foo(1)Kls.static_foo('hi')print(ik.static_foo) 输出结果 12345678910executing foo(&lt;__main__.Kls object at 0x0551E190&gt;,1)&lt;bound method Kls.foo of &lt;__main__.Kls object at 0x0551E190&gt;&gt;==========================================executing class_foo(&lt;class '__main__.Kls'&gt;,1)executing class_foo(&lt;class '__main__.Kls'&gt;,1)&lt;bound method type.class_foo of &lt;class '__main__.Kls'&gt;&gt;==========================================executing static_foo(1)executing static_foo(hi)&lt;function static_foo at 0x055238B0&gt; 实例方法：调用时会把实例ik作为第一个参数传递给self参数。因此，调用ik.foo(1)时输出了实例ik的地址。 类方法：调用时会把类Kls作为第一个参数传递给cls参数。因此，调用ik.class_foo(1)时输出了Kls类型信息。前面提到，可以通过类也可以通过实例来调用类方法，在上述代码中，我们再一次进行了验证。 静态方法：调用时并不需要传递类或者实例。其实，静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。 感谢CSDN博主haozlee原文链接。 类之间的关系类和类之间的关系有三种：is-a、has-a和use-a关系 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 继承和多态 继承：提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。 子类继承父类提供的属性和方法。 子类可以定义自己特有的属性和方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person(object): &quot;&quot;&quot;人&quot;&quot;&quot; def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_video(self): if self._age &gt;= 18: print('%s正在观看《不能说的秘密》.' % self._name) else: print('%s只能观看《熊出没》.' % self._name)class Student(Person): &quot;&quot;&quot;学生&quot;&quot;&quot; def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person): &quot;&quot;&quot;老师&quot;&quot;&quot; def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course))def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_video() t = Teacher('周天宇', 20, '大二') t.teach('Python程序设计') t.watch_video()if __name__ == '__main__': main() 多态：通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为。 12345678910111213141516171819202122232425262728293031323334353637from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): &quot;&quot;&quot;宠物&quot;&quot;&quot; def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): &quot;&quot;&quot;发出声音&quot;&quot;&quot; passclass Dog(Pet): &quot;&quot;&quot;狗&quot;&quot;&quot; def make_voice(self): print('%s: 汪汪汪...' % self._nickname)class Cat(Pet): &quot;&quot;&quot;猫&quot;&quot;&quot; def make_voice(self): print('%s: 喵...喵...' % self._nickname)def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice()if __name__ == '__main__': main() abc.ABCMeta：简单的说ABCMeta就是让你的类变成一个纯虚类，子类必须实现某个方法，这个方法在父类中用@abc.abstractmethod修饰。 你可以在父类中实现这两个虚方法，也可以不实现。但在子类中就必须实现被“虚化”的函数，否则会报错。例如上述的make_voice()就在子类（Dog、Cat）中被实现了两种版本，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 综合案例 工资结算系统 某公司有三种类型的员工分别是部门经理、程序员和销售员需要设计一个工资结算系统根据提供的员工信息来计算月薪： 部门经理的月薪是每月固定15000元。 程序员的月薪按本月工作时间计算 每小时150元。 销售员的月薪是1200元的底薪加上销售额5%的提成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from abc import ABCMeta, abstractmethodclass Employee(object, metaclass=ABCMeta): &quot;&quot;&quot;员工&quot;&quot;&quot; def __init__(self, name): &quot;&quot;&quot; 初始化方法 :param name: 姓名 &quot;&quot;&quot; self._name = name @property def name(self): return self._name @abstractmethod def get_salary(self): &quot;&quot;&quot; 获得月薪 :return: 月薪 &quot;&quot;&quot; passclass Manager(Employee): &quot;&quot;&quot;部门经理&quot;&quot;&quot; def get_salary(self): return 15000.0class Programmer(Employee): &quot;&quot;&quot;程序员&quot;&quot;&quot; def __init__(self, name, working_hour=0): super().__init__(name) self._working_hour = working_hour @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour &gt; 0 else 0 def get_salary(self): return 150.0 * self._working_hourclass Salesman(Employee): &quot;&quot;&quot;销售员&quot;&quot;&quot; def __init__(self, name, sales=0): super().__init__(name) self._sales = sales @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales if sales &gt; 0 else 0 def get_salary(self): return 1200.0 + self._sales * 0.05def main(): emps = [ Manager('刘备'), Programmer('诸葛亮'), Manager('曹操'), Salesman('荀彧'), Salesman('吕布'), Programmer('张辽'), Programmer('赵云') ] for emp in emps: if isinstance(emp, Programmer): emp.working_hour = int(input('请输入%s本月工作时间: ' % emp.name)) elif isinstance(emp, Salesman): emp.sales = float(input('请输入%s本月销售额: ' % emp.name)) # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态) print('%s本月工资为: ￥%s元' % (emp.name, emp.get_salary()))if __name__ == '__main__': main() super()函数 super()函数是用于调用父类(超类)的一个方法。 super是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。 Python3.x 和 Python2.x 的一个区别是：Python3.x可以使用直接使用super().xxx代替super(Class, self).xxx: 123456789class A: def add(self, x): y = x+1 print(y)class B(A): def add(self, x): super().add(x)b = B()b.add(2) # 3 super().__init__() 作用：执行父类的构造函数，使得我们能够调用父类的属性。 对继承自父类的属性进行初始化。而且是用父类的初始化方法来初始化继承的属性。也就是说，子类继承了父类的所有属性和方法，父类属性自然会用父类方法来进行初始化。 当然，如果初始化的逻辑与父类的不同，不使用父类的方法，自己重新初始化也是可以的。 isinstance() 函数 isinstance()函数来判断一个对象是否是一个已知的类型，类似type()。 isinstance()与type()区别： type()不会认为子类是一种父类类型，不考虑继承关系。 isinstance()会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用isinstance()。 语法：isinstance(object, classinfo) 参数： object — 实例对象。 classinfo — 可以是直接或间接类名、基本类型或者由它们组成的元组。 如果对象的类型与参数二的类型（classinfo）相同则返回True，否则返回False。 文件和异常读写文本文件读文本文件 Pythonopen()方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数。 12345678def main(): f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) f.close()if __name__ == '__main__': main( 一般在读取文本文件时，需要在使用open()函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为'r'（如果不指定，默认值也是'r'），然后通过encoding参数指定编码。 使用open()方法一定要保证关闭文件对象，即调用close()方法。 open()函数常用形式是接收两个参数：文件名(file)和模式(mode)。 1open(file, mode='r') 更多open()参数和方法链接：菜鸟教程 如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理。 12345678910111213141516171819def main(): f = None try: f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') # finally块的代码不论程序正常还是异常都会执行到 finally: if f: f.close()if __name__ == '__main__': main() 更简洁的写法with关键字。 12with open('file_name','r') as f: r=f.read() 当with里面的语句产生异常的话，也会正常关闭文件。 如果要让代码有更好的健壮性和容错性，这样写即可。 1234567891011121314def main(): try: with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!')if __name__ == '__main__': main() 更多try/except语句和异常处理详解：菜鸟教程 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中。 1234567891011121314151617181920212223import timedef main(): # 一次性读取整个文件内容 with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) # 通过for-in循环逐行读取 with open('致橡树.txt', 'r', encoding='utf-8') as f: for line in f: print(line, end='') time.sleep(0.5) print() # 读取文件按行读取到列表中 with open('致橡树.txt', 'r', encoding='utf-8') as f: lines = f.readlines() print(lines)if __name__ == '__main__': main() 注意：使用readline()直接读取文件会读出换行符\\n，如果想要和上面的for-in循环效果一样，可这样写： 123456789101112import timedef main(): with open('逍遥游.txt', 'r', encoding='utf-8') as f: for line in f.readlines(): line=line.strip('\\n') print(line) time.sleep(0.5)if __name__ == '__main__': main() 写入文本文件 将1-9999之间的素数分别写入三个文件中。 12345678910111213141516171819202122232425262728293031323334353637from math import sqrt # 求平方根def is_prime(n): &quot;&quot;&quot;判断素数的函数&quot;&quot;&quot; assert n &gt; 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else Falsedef main(): filenames = ('a.txt', 'b.txt', 'c.txt') # 元组的元素是不可变更的。 fs_list = [] try: for filename in filenames: fs_list.append(open(filename, 'w', encoding='utf-8')) for number in range(1, 10000): if is_prime(number): if number &lt; 100: fs_list[0].write(str(number) + '\\n') elif number &lt; 1000: fs_list[1].write(str(number) + '\\n') else: fs_list[2].write(str(number) + '\\n') except IOError as ex: print(ex) print('写文件时发生错误!') finally: for fs in fs_list: fs.close() print('操作完成!')if __name__ == '__main__': main() 需要注意的是元组中的元素为不可变更的对象，所以这里的三个txt文件用的是列表来操作。 append()函数，用于在列表末尾添加新的对象。 语法： 1list.append(obj) 读写二进制文件 复制图片文件 12345678910111213141516def main(): try: with open('guido.jpg', 'rb') as fs1: data = fs1.read() print(type(data)) # &lt;class 'bytes'&gt; with open('吉多.jpg', 'wb') as fs2: fs2.write(data) except FileNotFoundError as e: # e用于创建自定义异常类的实例 print('指定的文件无法打开.') except IOError as e: print('读写文件时出现错误.') print('程序执行结束.')if __name__ == '__main__': main() type()函数，只有第一个参数则返回对象的类型，三个参数返回新的类型对象。 语法： 12345678type(object)type(name, bases, dict)'''name -- 类的名称。bases -- 基类的元组。dict -- 字典，类内定义的命名空间变量。''' 读写JSON文件 JSON与Python数据类型对应关系： JSON Python dict object list, tuple array str string int, float, int- &amp; float-derived Enums number True / False true / false None null Python与JSONn数据类型对应关系: JSON Python object dict array list string str number (int / real) int / float true / false True / False null None 使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中。 12345678910111213141516171819import jsondef main(): mydict = { 'name': '周天宇', 'age': 20, 'friends': ['周杰伦', '林俊杰'], } try: with open('data.json', 'w', encoding='utf-8') as fs: json.dump(mydict, fs) except IOError as e: print(e) print('保存数据完成!')if __name__ == '__main__': main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中。 dumps - 将Python对象处理成JSON格式的字符串。 load - 将文件中的JSON数据反序列化成对象。 loads - 将字符串的内容反序列化成Python对象。 Python对正则表达式的支持 正则表达式基础符号表。 Python提供的re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 实际开发中可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，先通过compile()函数编译正则表达式并创建出正则表达式对象更好。 例子：验证输入用户名和QQ号是否有效并给出对应的提示信息。 12345678910111213141516171819202122232425&quot;&quot;&quot;验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0&quot;&quot;&quot;import redef main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) # r'原始字符串 if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!')if __name__ == '__main__': main() 更多例子 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），“原始字符串”就是字符串中的每个字符都是它原始的意义（声明字符串中没有转义字符）。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d。","link":"/2020/02/04/python/"},{"title":"XPath语法的使用","text":"XPath简介 XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。 XPath 含有超过 100 个内建的函数。这些函数用于字符串值、数值、日期和时间比较、节点和 QName 处理、序列处理、逻辑值等等。 XPath术语 在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。 XPath语法选取节点 XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。 下面列出了最有用的路径表达式： 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 选取未知节点 XPath 通配符可用来选取未知的 XML 元素（节点）: 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 我的实例 空气质量排名爬虫 123456789101112131415161718192021222324252627import reimport requestsfrom lxml import etreedef show(): print('全国空气状况排名表(污染)'+'\\n统计时间：'+time) print() for num in range(len(rank)): print('第'+rank[num]+'名 '+provinces[num]+'———'+citys[num]+' 空气质量：'+qualitys[num]+' AQI：'+AQI[num]+' PM2.5：'+PM2_5[num]+'μg/m³') print('\\n全国空气状况排名表(污染)'+'\\n统计时间：'+time)headers = {&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&quot;,}url = 'http://www.pm25.com/rank.html'response = requests.get(url, headers=headers)response.encoding = 'utf-8'html = response.content.decode('utf-8')root = etree.HTML(html)time = re.findall(r'&lt;span&gt;统计时间：(.*?)&lt;/span&gt;', html)[0]rank = root.xpath('//ul[@class=&quot;pj_area_data_details rrank_box&quot;]//span[@class=&quot;pjadt_ranknum&quot;]/text()')provinces = root.xpath('//ul[@class=&quot;pj_area_data_details rrank_box&quot;]//span[@class=&quot;pjadt_sheng&quot;]/text()')citys = root.xpath('//ul[@class=&quot;pj_area_data_details rrank_box&quot;]//a/text()')qualitys = root.xpath('//ul[@class=&quot;pj_area_data_details rrank_box&quot;]//span[@class=&quot;pjadt_quality&quot;]//em/text()')AQI = root.xpath('//ul[@class=&quot;pj_area_data_details rrank_box&quot;]//span[@class=&quot;pjadt_aqi&quot;]/text()')PM2_5 = root.xpath('//ul[@class=&quot;pj_area_data_details rrank_box&quot;]//span[@class=&quot;pjadt_pm25&quot;]/text()')if __name__ == &quot;__main__&quot;: show() 更多详细XPath的使用可以参考XPath教程。","link":"/2020/03/15/Xpath/"},{"title":"云南风景","text":"写在前面2020年1月21日从成都出发前往云南，原计划准备去大理游玩，由于新型冠状病毒的持续蔓延，景区取消接待，只得安分地在昆明周边走走。 滇池风光（拍摄于1月22日） 汽车行驶在平坦的路上，轻轻地按下车窗 风有一点凉，阳光却很暖。 沿着小路驶去，没有去海埂公园 这里是离滇池最近的地方。 波光粼粼 阳光下的海鸥，活泼却温柔。","link":"/2020/01/25/%E4%BA%91%E5%8D%97%E9%A3%8E%E6%99%AF/"},{"title":"内存管理","text":"分区、分段、段页式 操作系进行内存管理的原因 划分内存而满足多道程序的需求。 内存需要被高效地分配而能够装入尽可能多的进程。 分类 连续：分区 离散：分段、分页 固定分区 系统初始启动时将内存划分为数目固定、尺寸固定的多个分区。 这些分区的尺寸可以相等也可以不等。 特点 如果一个程序太大而不能进入分区需要程序员使用覆盖技术（早期计算机系统）设计程序。 内存使用不够高效。无论程序多小必须占据整个分区，这被称为内零头（内部碎片）。 以上问题虽然可以通过大小不相等的分区设计加上算法减小影响，但是不能根治问题。 优点 实现简单。 系统开销小。 缺点 存在内零头，存储利用率不高。 分区尺寸固定，系统无法运行大程序。 分区数目固定，活动的进程数目受限。 动态分区 分区的大小和数量多样。 进程可以分配到精确的所需的内存大小。 会在内存中产生很多“小空隙”，称为外零头。 必须使用紧凑技术，调整进程使它们相邻，从而拼接所有较小的空闲内存形成一块较大的。 动态分区消除了内零头，却产生了外零头。 简单分页 内存被分为大小相等的块，每一个进程被分成和内存块相等大小的块。 这些进程的块，被称为页而内存的块被称为页帧（页框）。 没有外零头，仅有很少的内零头出现在进程的最后一页。 分页系统地址转换 根据逻辑地址及页大小求出页号和页内偏移量。 用页号检索页表，查找页对应的页框号。 根据页框号、页内偏移以及页框尺寸求出物理地址。 简单分段 基于模块化设计时，程序员根据需要将进程分割成许多大小不一的段，系统则将物理内存动太划分成许多尺寸不一定相等的部分。 当一个进程装入物理内存时，系统将该进程的每个段独立分配一个分区；同一进程的多个段不必存放在连续的多个分区中。 没有内部碎片，比较与动态分区，内存利用率更高，开销小。 段页式区别和对比 页面是信息的物理单位；在特定的系统中，其大小是固定不变的，不随进程的不同而不同。 段是信息的逻辑单位，其长度不定；即使是属于同一进程的两个段长度也可能不等。 分页活动源于系统管理物理内存的需要，在系统内部进行，由系统实施，用户看不见。 分段活动源于用户进行模块化程序设计的需要，在系统外部进行，由用户实施，用户是知道的。 在分页系统中，逻辑地址是一维的。 在分段系统中，逻辑地址是二维或多维的。 怎样理解这里的一维和二维? 段页式为什么存在 分页系统中，内零头得到了有效的抑制，外零头则被完全消除；因此使用分页技术可以提高物理内存的利用率。 分段系统中，动态数据结构、程序和数据共享、程序和数据保护等问题得到了妥善的解决；因此，分段技术有利于模块化程序设计。 段页技术汲取了分页技术和分段技术的上述优点。 如何划分 在段页存储管理系统当中，每个进程均被编程人员分割成多个段，每个段又被系统分割成多个页。 相应的，物理内存被系统划分成多个页框（页帧）。 当一个进程装入物理内存时，系统为该进程的每个段的各页面独立地分配一个页框；一个进程的同一段的多个页面不必存放在连续的多个页框中。 虚拟内存分页 与简单分页相比，不需要将进程所有的页装入主存。 优点 没有外部碎片。 巨大的虚拟内存空间。 更高程度的多道程序设计。 缺点 复杂的内存管理开销。 虚拟内存分段 与简单分段相比，不需要进程所有的段都装入主存。 优点 具有虚拟内存分段的三个优点，并支持保护和共享。 缺点 复杂的内存管理开销。","link":"/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"第一天","text":"第一章——前言 作为一个爱好摄影的程序员，第一次搭建博客，先放几张图 经过格式工厂的转码，把图片压缩到1M以内，希望加载可以稍微快点 时间久远图片没有按照顺序放 有新作品会陆续更新 第二章——图片在这里 2018年拍摄·夏天 2018年拍摄·夏天 2018年拍摄·夏天 2019年拍摄·春天 2019年拍摄·春天 2019年拍摄·春天","link":"/2020/01/17/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"title":"应用层","text":"应用层协议的特点 每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。 应用层的许多协议都是基于客户服务器方式。 域名系统 DNS 域名系统概述 许多应用层软件经常直接使用域名系统 DNS** (Domain Name System)，但计算机的用户只是间接而不是直接使用域名系统。 互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。 名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。 互联网的域名结构 互联网采用了层次树状结构的命名方法。 任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。 域名的结构由标号序列组成，各标号之间用点隔开：… . 三级域名 . 二级域名 . 顶级域名 各标号分别代表不同级别的域名。 顶级域名 TLD(Top Level Domain) 国家顶级域名 nTLD .cn 表示中国， .us 表示美国， .uk 表示英国，等等。 通用顶级域名 gTLD 最早的顶级域名是： .com（公司和企业） .net（网络服务机构） .org（非赢利性组织） .edu（美国专用的教育机构） .gov（美国专用的政府部门） .mil（美国专用的军事部门） .int（国际组织） 基础结构域名 (infrastructure domain) 这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名。 域名服务器 一个服务器所负责管辖的（或有权限的）范围叫做区 (zone)。 各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。 每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。 DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。 域名服务器有以下四种类型 根域名服务器 根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。 不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。 在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a 一直到 m（前 13 个字母）。(a.rootservers.net，b.rootservers.net ……) 根域名服务器共有 13 套装置，不是 13 个机器。 顶级域名服务器 顶级域名服务器（即 TLD 服务器,Top Level Domain）负责管理在该顶级域名服务器注册的所有二级域名。 当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 权限域名服务器 责一个区的域名服务器。 当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器 本地域名服务器 本地域名服务器对域名系统非常重要。 当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。 每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器， 这种域名服务器有时也称为默认域名服务器。 域名的解析过程 主机向本地域名服务器的查询一般都是采用递归查询。 本地域名服务器向根域名服务器的查询通常是采用迭代查询。 文件传输协议 FTP概述 文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。 FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。 FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。 FTP 的基本工作原理 FTP 特点 文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。 FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。 FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。 主进程的工作步骤 打开熟知端口（端口号为 21），使客户进程能够连接上。 等待客户进程发出连接请求。 启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。 回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。 两个连接 控制连接(21)在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。 实际用于传输文件的是“数据连接(20)”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。 数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。 两个不同的端口号 客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。 接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。 由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。 好处： 使协议更加简单和更容易实现。 在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。 简单文件传送协议 TFTP TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。 TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。 TFTP 只支持文件传输而不支持交互。 TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 远程终端协议 TELNET TELNET 是一个简单的远程终端协议，也是互联网的正式标准。 用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。 TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 万维网 万维网概述 万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。 万维网是一个大规模的、联机式的信息储藏所。 万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。 这种访问方式称为“链接”。 超媒体与超文本 万维网是分布式超媒体 (hypermedia) 系统，它是超文本 (hypertext) 系统的扩充。 一个超文本由多个信息源链接成。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。 超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。 万维网的工作方式 万维网以客户-服务器方式工作。 浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。 客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。 万维网必须解决的问题 怎样标志分布在整个互联网上的万维网文档？ 使用统一资源定位符 URL (Uniform Resource Locator) 来标志万维网上的各种文档。 使每一个文档在整个互联网的范围内具有唯一的标识符 URL。 用何协议实现万维网上各种超链的链接？ 在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。 HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ 超文本标记语言 HTML (HyperText Markup Language) 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 怎样使用户能够很方便地找到所需的信息？ 为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）。 统一资源定位符 URL URL的格式 由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。 URL 的一般形式是： 超文本传送协议 HTTP HTTP 的操作过程 为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。 从层次的角度看，HTTP 是面向事务的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。 用户点击 URL http://www.tsinghua.edu.cn/chn/yxsz/index.htm 后所发生的事件 (1) 浏览器分析超链指向页面的 URL。 (2) 浏览器向 DNS 请求解析 www.tsinghua.edu.cn 的 IP 地址。 (3) 域名系统 DNS 解析出清华大学服务器的 IP 地址。 (4) 浏览器与服务器建立 TCP 连接。 (5) 浏览器发出取文件命令：GET /chn/yxsz/index.htm。 (6) 服务器给出响应，把文件 index.htm 发给浏览器。 (7) TCP 连接释放。 (8) 浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。 HTTP 的主要特点 HTTP 是面向事务的客户服务器协议。 HTTP 1.0 协议是无状态的 (stateless)。 HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。 持续连接 HTTP/1.1 协议使用持续连接 (persistent connection)。 万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。 这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。 目前一些流行的浏览器（例如，IE 6.0）的默认设置就是使用 HTTP/1.1。 持续连接的两种工作方式 非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。 流水线方式：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT 时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。 代理服务器 代理服务器 (proxy server) 又称为万维网高速缓存 (Web cache)，它代表浏览器发出 HTTP 请求。 万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。 当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。 HTTP 的报文结构 HTTP 有两类报文： 请求报文——从客户向服务器发送请求报文。 响应报文——从服务器到客户的回答。 由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。 在服务器上存放用户的信息 万维网站点使用 Cookie 来跟踪用户。 Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。 使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。 万维网的文档 超文本标记语言 HTML XML XML (Extensible Markup Language)是可扩展标记语言，它和HTML很相似。 但XML的设计宗旨是传输数据，而不是显示数据（HTML是为了在浏览器上显示数据）。 XHTML XHTML (Extensible HTML) 是可扩展超文本标记语言，它与 HTML 4.01 几乎是相同的。 CSS CSS (Cascading Style Sheets) 是层叠样式表，它是一种样式表语言，用于为 HTML 文档定义布局。 动态万维网文档 静态文档是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。 动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。 万维网的信息检索系统 全文检索搜索和分类目录搜索 在万维网中用来进行搜索的程序叫做搜索引擎。 全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件到互联网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。 用户在查询时只要输入关键词，就从已经建立的索引数据库上进行查询（并不是实时地在互联网上检索到的信息）。 分类目录搜索 分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。 分类目录搜索也叫做分类网站搜索。 最著名的全文检索搜索引擎： Google（谷歌）(www.google.com) 百度 (www.baidu.com) 最著名的分类目录搜索引擎： 雅虎 (www.yahoo.com) 雅虎中国 (cn.yahoo.com) 新浪 (www.sina.com) 搜狐 (www.sohu.com) 网易 (www.163.com) 电子邮件 电子邮件概述 电子邮件的一些标准 发送邮件的协议：SMTP 读取邮件的协议：POP3 和 IMAP MIME 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。 电子邮件的最主要的组成构件 简单邮件传送协议 SMTP SMTP 所规定的就是在两个相互通信的 SMTP 进程之间应如何交换信息。 由于 SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。 SMTP 规定了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上（也可不附上）很简单的文字说明。 SMTP 通信的三个阶段 连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。 邮件传送 连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。 动态主机配置协议 DHCP 互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。 这种机制允许一台计算机加入新的网络和获取IP 地址而不用手工参与。 DHCP 使用客户-服务器方式 需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送*发现报文*（DHCPDISCOVER），这时该主机就成为 DHCP 客户。 本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。 DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文（DHCPOFFER）。 DHCP 中继代理(relay agent) 并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。 当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。","link":"/2020/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"title":"操作系统的基本概念","text":"操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合 OS的功能性需求 计算机用户需要的用户命令 由OS实现的所有用户命令所构成的集合常被人们称为OS的Interface（用户接口），有时也称为命令接口。 应用软件需要的System Call（系统调用） 由OS实现的所有系统调用所构成的集合常被人们称为程序接口或应用编程接口（API）。 体现的作用： OS作为用户与计算机系统之间的接口。 OS作为计算机系统资源的管理者。 OS实现对计算机资源的抽象。 OS的非功能性需求 性能、安全、可靠性、可扩展性、可移植性… 基本概念作业和作业步 Job（作业）：计算机用户在一次上机过程中要求计算机系统为其所作工作的集合。 作业步：作业中每项相对独立的工作。 作业的基本类型： Off-line Job（脱机作业）：计算机用户不能在此类作业被计算机系统处理时改变已定义好的作业步。 On-line Job（联机作业）：计算机用户可以在此类作业被计算机系统处理时随时改变其作业步。 进程和线程 Thread（线程）：程序的一次相对独立的运行过程。在现代OS中，线程是系统调度的最小单位。 Process（进程）：系统分配资源的基本对象。在现代OS中，进程仅仅是系统中拥有资源的最小实体。不过，在传统OS中，进程同时也是系统调度的最小单位。 虚拟存储和文件 Virtual Memory（虚拟存储）：进程的逻辑地址空间。它是现代OS对计算机系统中多级物理存储体系进行高度抽象的结果。 File（文件）：命名了的字节流。它是线代OS对计算机系统中种类繁多的外部设备进行高度抽象的结果。","link":"/2020/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"数据库语句","text":"SQL 命令复习数据表创建1234567create table 通讯录( 姓名 varchar(8), 性别 char(2), 年龄 int, 电话 char(20), 地址 char(20)); 视图创建1234567891011121314create view cs_info_viewasselect * from student where 系别='计算机';create view s_info_view(学号,姓名,性别,系别)asselect sno,sn,sex,dep from student;create view s_info_viewasselect sno as 学号,sn as 姓名,sex as 性别,dep as 系别 from student; 索引创建12345678910111213141516171819202122232425262728293031323334# 创建表时创建索引# 创建 S 表并以 sname 字段建立普通索引 create table S( sno char(10), sname varchar(20), age int, sex char(2), dept varchar(20), index (sname));# 创建 SC 表，并以 sno 和 cno 两字段组合建立名为 uk_sno_cno 多列唯一索引create table SC( sno char(10), cno char(15), score decimal(4,1), unique index uk_sno_cno(sno,cno));# 在已存在的表上创建索引# 降序普通索引create index idx_sno on SC(sno desc);alter table SC add index idx_sno (sno desc);# 唯一索引create unique index uk_sno on S(sno);alter table S add unique index idx_sno (sno); 授权/回收权限命令123456789101112# 把创建表权限授权给用户 user1/回收grant create table to user1;revoke create table from user1;# 把查询 order 表的权限授权给用户 user1/回收 grant select on order to user1 [with grant option];revoke select on order from user1;# with grant option 表示允许被授权用户将制定的系统权限再授予其他用户 基本的查询命令1234select * from course;select sno,sname,sage from student;select cno as 课程名 from course;select sname as 姓名,2020-sage as 出生年份 from student; 条件查询123456789101112131415161718192021222324252627282930313233# 精确匹配select * from sc where grade &gt; 85;# 多重条件select * from scwhere (cno = 'kc001' or cno ='kc002') and grade &gt; = 85;# 确定范围select * from teacherwhere sal between 1000 and 1500;# (等价于 sal&gt; =1000 and sal &lt; =1500&gt;);# 确定集合select * from scwhere cno in ('c1','c2'); # (等价于 cno='c1' or cno='c2')select * from scwhere cno not in ('c1','c2'); # (等价于 cno! ='c1' and cno! ='c2')# 部分匹配查询（模糊查询）select * from coursewhere cname [not] like '%数%';# “%” 匹配零个及多个任意字符；“_” 匹配一个任意字符# 空值查询select * from coursewhere cpno is null;# 统计查询# count() 按列计算个数# sum()、avg()、max()、min()# count(*) 用来统计元组个数，不消除重复行，不允许使用 distinct 关键字select count(*) from studentwhere dept = '计算机'; 连接查询12345678910111213141516171819202122232425262728# 一般连接select teacher.tno,tn,cnofrom teacher,tcwhere (teacher.tno=tc.tno) and (tn='刘伟');# 自身连接select cx.cno [as] 课程号,cy.cname [as] 课程名, cx.cno [as] 先选课程号,cy.cname [as] 先选课程名from course [as] cx, course [as] cywhere cx.cpno = cy.cno;# JOIN连接# 交叉连接 （笛卡尔积）select * from student cross join course;# 内连接select * from student [inner] join sc on student.sno = sc.snowhere sage &gt; 20 and sex = '男';# 外连接# left (right、full) [outer] join 结果包含第一（二）个表中所有行select *from student left [outer] join scon student.sno = sc.sno; 嵌套查询1234567891011121314151617181920212223242526272829303132333435363738# 普通子查询# 先执行子查询 返回单一值select * from teacherwhere prof = (select prof from teacher where tn='刘伟')；# 先执行子查询 返回一组值# 使用 anyselect * from teacherwhere tno = any (select tno from tc where cno='c5');# 使用 in 代替 =any select * from teacherwhere tno in (select tno from tc where cno='c5');# 使用 allselect * from teacherwhere sal &gt; all (select sal from teacher where dept='计算机') and dept ! = '计算机';# 使用 exists# 属于相关子查询select * from teacherwhere [not] exists (select * from tc where tno = teacher.tno and cnon = 'c5'); 相关子查询123456789# 先执行外部查询# 执行次数由父查询表的行数决定select distinct tnfrom teacherwhere 'c5'! = all (select cno from tc where tno=teacher.tno); 派生子查询12345678# 嵌入到 from 子句中# 子查询为父查询提供派生表（临时表）select *from student,(select avg(sage) as 信息系平均年龄 from student where sdept='信息') as infowhere sage &gt; info.信息系平均年龄; 分组查询123456789101112# 按系别分组select sdept as 系名, count(*) as 人数from studentgroup by sdept;# 学了四门以上课程的学号和课程数select sno as 学号, count(*) as 课程数from scgroup by snohaving count(*) &gt; =4; 排序123456# 排序 (order by)# desc 降序；asc 升序select * from studentwhere sdept='计算机'order by sage desc； 限量查询123456select * from studentorder by score desclimit 5;# limit n 等价于 limit 0,n# limit 5,10 从标号为 5 的行开始，取 10 行， 6 - 15 行 增、删、改12345678910111213141516171819202122# 增# 每列都要插入，且顺序一致insert into studentvalues ('S7','周杰伦','男',21,'古典音乐');# 其他列有默认值的填默认值，否则 NULL，若有非空值限制则报错insert into sc(sno,cno)values ('S7','c1');# 改update teacher set dept ='信息'where tno = '刘伟';update student set age = age + 1;# 删delete from teacher where tn = '刘伟';delete from teacher;","link":"/2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/"},{"title":"操作系统课后习题","text":"西安电子科技大学出版社出版的计算机操作系统（第四版）课后习题整理 作者：汤小丹 梁红兵 哲凤屏 汤子瀛 第一章 操作系统引论 设计现代OS的主要目标是什么？ 有效性 方便性 可扩充性 开放性 OS的作用可表现在哪几个方面？ OS作为用户与计算机硬件系统之间的接口 OS作为计算机系统资源的管理者 OS实现了对计算机资源的抽象 为什么没说OS实现了对计算机资源的抽象？ OS首先在裸机上覆盖一层I/O设备管理软件，实现了对计算机硬件操作的第一层抽象 在第一层软件上再覆盖文件管理软件，实现了对硬件资源操作的第二层抽象 OS通过在计算机硬件上安装多层系统软件，增强了系统功能，隐藏了对硬件操作的细节，由它们共同实现了对计算机资源的抽象 试说明推动多道批处理系统形成和发展的主要动力是什么？ 主要动力来源于四个方面的社会需求与技术发展 不断提高计算机资源的利用率 方便用户 器件的不断更新换代 计算机体系结构的不断发展 不断提出新的应用需求 何谓脱机I/O和联机I/O？ 脱机I/O是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在外围机的控制下，把纸带或卡片上的数据或程序输入到磁带上。该方式下的输入和输出由外围机控制完成，是在脱离主机的情况下进行的 联机I/O方式是指程序和数据的输入输出都是直接在主机的直接控制下进行的 外围机（外围设备）？ 试说明推动分时系统形成和发展的主要动力是什么？ 主要动力是：更好地满足用户的需要 主要表现在： CPU的分时使用缩短了作业的平均周转时间 人机交互能力使用户能直接控制自己的作业 主机的共享使多用户能同时使用同一台计算机，独立地处理自己的作业 实现分时系统地关键问题是什么？应如何解决？ 关键问题：当用户在自己的终端上键入自己的命令时，系统应能及时接收并及时处理该命令，在用户能接受的时延内将结果返回给用户 解决办法： 针对及时接收问题，可以在系统中设置多路卡，使主机能够同时接收用户从各个终端上输入的数据；为每个终端配置缓冲区，暂存用户键入的命令或数据 针对及时处理问题，应使所有用户的作业都直接进入内存，并且为每个作业分配一个时间片，允许作业只在自己的时间片内运行，这样在不长的时间内，能使每个作业都运行一次 为什么要引入实时OS？ 实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。 引入实时OS是为了满足应用的需求，更好地满足实时控制领域和实时信息处理领域的需要。 什么是硬实时任务和软实时任务？试举例说明。 硬实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。 例如：运载火箭的控制等 软实时任务是指它的截止时间并不严格，偶尔错过任务截止时间，对系统产生的影响不大。 例如：网页内容更新，火车售票系统。 试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。 及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微秒。 交互性：实时信息处理系统具有交互性，但人与系统的交互仅限于访问系统中某些特定的专用服务程序。不像分时系统那样能向终端用户提供数据和资源共享等服务 可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性 OS有哪几大特征？其最基本的特征是什么？ 特征：并发性、共享性、虚拟性、异步性四个基本特征 最基本特征：共享和并发是操作系统的两个最基本的特征，虚拟以并发和共享为前提，异步是并发和共享的必然结果。 在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对于独占资源应采取何种共享方式？ 一般情况下：只能说明资源能被大家使用，如图书馆中的图书能提供给大家借阅，但并未限定借阅者必须在同一时间（间隔）和同一地点阅读。这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理比较简单。 OS环境下：资源共享或称为资源复用是指系统中的资源可供内存中多个并发执行的进程共同使用。宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。由于系统资源远少于多道程序需求的总合，会形成对共享资源的争夺，资源管理复杂得多。 独占资源：在一段时间内，只允许一个进程访问该资源。应采用互斥共享方式。 其他资源：允许在一段时间内由多个进程“同时”（微观上交替进行）访问。可采用同时访问方式。例如：磁盘设备等。 什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。 时分复用技术：利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使得设备得到最充分的利用（也是提高资源利用率的根本原因）。 举例： 虚拟处理机技术：利用多道程序设计技术，为每道程序建立至少一个进程，然多道程序并发执行。实现为多个用户服务，将一台物理处理机逻辑上分为多台处理机。 虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，供多个用户“同时”使用。 是什么原因使操作系统具有异步性特征？ 由于资源等因素的限制，使进程通常都不可能“一气呵成”，而是以“停停走走”的方式运行，即异步方式运行。 处理机管理有哪些主要功能？它们的主要任务是什么？ 进程控制（管理）： 为作业创建进程，撤销已结束进程控制进程在运行过程中的状态转换 进程同步： 为多个进程（含线程）的运行进行协调 进程通信： 用来实现在相互合作的进程之间的信息交换 （处理机）调度： 作业调度：从后备队列按照一定算法，选出若干个作业，为它们分配所需的资源（首先是分配内存）。 进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。 内存管理有哪些主要功能？它们的主要任务是什么？ 内存分配： 为每道程序分配内存 内存保护： 确保每道用户程序都只在自己的内存空间运行，彼此互不干扰 地址映射： 将地址空间的逻辑地址转换为内存空间与对应的物理地址 内存扩充： 用于实现请求调用功能，置换功能等 设备管理有哪些主要功能？其主要任务是什么？ 主要功能:缓冲管理、设备分配和设备处理以及虚拟设备等。 主要任务:完成用户提出的I/O请求，为用户分配I/O设备；提高CPU和I/O设 备的利用率；提高I/O速度；以及方便用户使用I/O设备。 文件管理有哪些主要功能？其主要任务是什么？ 主要功能：文件存储空间的管理、目录管理、文件的读/写管理和保护。 主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。 试说明推动传统OS演变为现代OS的主要因素是什么？ 用户对OS的系统安全、网络功能和服务、多媒体功能的需求增加。 计算机技术的不断发展。 什么是微内核OS？ 足够小的内核 基于客户/服务器模式 应用机制与策略分离原理 采用面向对象技术 微内核操作系统具有哪些优点？它为何能有这些优点？ 提高了系统的可扩展性 增强了系统的可靠性 可移植性 提供了对分布式系统的支持 融入了面向对象技术 现代操作系统较之传统操作系统又增加了哪些功能和特征？ 面向安全、面向网络、面向多媒体 在微内核OS中，为什么要采用客户/服务器模式？ C/S模式具有独特的优点： 数据的分布处理和存储 便于集中管理 灵活性和可扩充性 易于改编应用软件 在基于微内核结构的OS中，应用了哪些新技术？ 采用面向对象的程序设计技术 何谓微内核技术？在微内核中通常提供了哪些功能？ 把操作系统中更多的成分和功能放到更高的层次（即用户模式）中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。 在微内核中通常提供了进程（线程）管理、低级存储器管理、中断和陷入处理等功能。 第二章 进程的描述与控制 什么是前趋图？为什么要引入前趋图？ 前趋图(Precedence Graph)是一个有向无循环图，记为DAG(Directed AcyclicGraph)，用于描述进程之间执行的前后关系。 画出下列四条语句的前趋图 略 为什么程序并发执行会产生间断性特征？ 程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务需要相互合作，致使这些并发进程之间形成了互相制约的关系，从而使得进程在执行期间出现间断性。 程序并发执行时为什么会失去封闭性和可再现性？ 程序并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态由多个程序改变，致使程序运行失去了封闭性，也会导致其失去可再现性。 在操作系统中为什么要引入进程概念？它会产生什么样的影响? 为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操 作系统中引入了进程概念。 影响：使程序的并发执行得以实行。 试从动态性，并发性和独立性上比较进程和程序? 动态性是进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。 并发性是进程的重要特征，同时也是OS的重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。 独立性是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。 试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？ 作为独立运行基本单位的标志 PCB的建立表示程序成为一个能在多道程序环境下独立运行、合法的基本单位，也就获得了OS服务的权力。 能实现间断运行方式 PCB在进程阻塞时保存和恢复CPU现场信息 提供进程管理所需要的信息 PCB记录程序和数据在内存或外存中的始址指针，找到相应的程序和数据 访问系统中的文件或I/O需要借助PCB的信息 通过PCB的资源清单可了解到该进程所需的全部资源 提供进程调度所需要的信息 PCB存储了进程状态信息（就绪与否） 优先级、等待时间、已执行时间、事件（阻塞原因） 实现与其它进程的同步和通信 PCB中有用于实现进程通信的区域或通信队列指针等 综上：PCB是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。OS通过PCB感知进程的存在，根据PCB对并发执行的进程进行控制和管理。 PCB提供了进程管理和进程调度的哪些信息？ 提供进程管理所需要的信息 PCB记录程序和数据在内存或外存中的始址指针，找到相应的程序和数据 访问系统中的文件或I/O需要借助PCB的信息 通过PCB的资源清单可了解到该进程所需的全部资源 提供进程调度所需要的信息 PCB存储了进程状态信息（就绪与否） 优先级、等待时间、已执行时间、事件（阻塞原因） 进程控制块的组织方式有哪几种？ 线性方式 将系统中所有PCB组织在一张线性表中。 实现简单，开销小，但每次查找需要扫描整张表，适合进程数目不多的系统。 链接方式 把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。这样就可以形成就绪队列、若干阻塞队列、空闲队列等。 索引方式 系统根据所有进程的状态不同，建立几张索引表。例如，就绪索引表、阻塞索引表等。 何谓操作系统内核？内核的主要功能是什么？ 操作系统内核：被安排在紧靠硬件的软件层次中，将它们常驻内存的与硬件紧密相关的模块。 支撑功能： 中断处理（OS最基本的功能）、时钟管理、原语操作 资源管理功能 进程管理、存储器管理、设备管理 试说明进程在三个基本状态之间转换的典型原因。 就绪状态→执行状态：进程分配到CPU资源 执行状态→就绪状态：时间片用完 执行状态→阻塞状态：I/O请求 阻塞状态→就绪状态：I/O完成 为什么要引入挂起状态？该状态有哪些性质？ 引入挂起状态处于五种不同的需要:终端用户需要，父进程需要，操作系统需要，对换需要和负荷调节需要。 处于挂起状态的进程不能接收处理机调度。 在进行进程切换时，所要保存的处理机状态信息有哪些？ 通用寄存器，进程当前暂存信息 指令计数器，下一指令地址信息 程序状态字PSW，进程状态信息 用户指针栈，过程和系统调用参数及调用地址信息 试说明引起进程创建的主要事件。 用户登录、作业调度、提供服务、应用请求（前三者由系统内核创建，最后一个为用户进程自己创建） 试说明引起进程被撤销的主要事件。 正常结束、异常结束（越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障）、外界干预（操作员或操作系统干预、父进程请求、父进程终止）。 在创建一个进程时所要完成的主要工作是什么？ OS发现请求创建新进程事件后，调用进程创建原语Creat() 申请空白PCB，为新进程申请获得唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB。 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。 初始化进程控制块(PCB)，包括：初始化标识信息、初始化处理机状态信息、初始化处理机控制信息。 将新进程插入就绪队列，如果进程就绪队列能够接纳新进程。 在撤销一个进程时所要完成的主要工作是什么？ 根据被终止进程标识符，从PCB集中检索出进程PCB，读出该进程状态。 若被终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。 若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。 将被终止进程拥有的全部资源，归还给父进程，或归还给系统。 将被终止进程PCB从所在队列或列表中移出，等待其它程序搜集信息。 试说明引起进程阻塞或被唤醒的主要事件是什么？ 向系统请求共享资源失败-阻塞，其他进程始放该资源-唤醒。 等待某操作（事件）完成-阻塞，操作（事件）完成-唤醒。 新数据尚未到达-阻塞，数据到达-唤醒。 等待新任务-阻塞，新任务到达-唤醒。 为什么要在OS中引入线程？ 在操作系统中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性，提高CPU的利用率。 进程是分配资源的基本单位，而线程则是系统调度的基本单位。 试说明线程具有哪些属性？ 轻型实体、独立调度和分派的基本单位、可并发执行、共享进程资源。 试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。 调度性：线程在OS中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。 并发性：进程可以并发执行，一个进程的多个线程也可并发执行。 拥有资源：进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源（TCB），本身基本不拥有系统资源，但可以访问隶属进程的资源。 系统开销：操作系统在创建、撤消和切换进程时付出的开销显著大于线程。 线程控制块TCB中包含了哪些内容？ 线程标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号屏蔽 堆栈指针 何谓用户级线程和内核支持线程？ 用户级线程：仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、 线程间的同步与通信等功能，都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。 内核支持线程：在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、撤销和切换等都是依靠内核，在内核空间中实现的。在内核空间里还为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。 试说明用户级线程的实现方法。 用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中 间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。 试说明内核支持线程的实现方法。 系统在创建新进程时，分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。创建一个线程分配一个TCB，有关信息写入TCB，为之分配必要的资源。当PTDA中的TCB用完，而进程又有新线程时，只要所创建的线程数目未超过系统允许值，系统可 在为之分配新的TCB；在撤销一个线程时，也应回收线程的所有资源和TCB。 多线程模型有哪几种类型？多对一模型有何优缺点？ 多对一模型 优点：线程管理开销小，效率高 缺点：一个线程访问内核时发生阻塞，整个进程都会被阻塞；在任意时刻只有一个线程能访问内核，多个线程不能同时在多个处理机上运行。 一对一模型 优点：一个线程阻塞时，允许调度另一个线程运行（更好的并发功能） 缺点：每创建一个用户线程，相应的需要创建一个内核线程，开销较大。 多对多模型 优点：结合上述两模型优点 第三章 处理机调度与死锁 高级调度与低级调度的主要任务是什么？为什么要引入中级调度？ 高级调度的主要任务是根据某种算法，把外存上处于后备队列中的那些作业调入内存。 低级调度是保存处理机的现场信息，按某种算法先取进程，再把处理器分配给进程。 引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。配合对换技术，调度换出到磁盘的进程进入内存，准备执行。（挂起状态-&gt;就绪状态） 处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？ 处理机调度算法的目标： 资源利用率：使系统中的处理机和其他所有资源都尽可能地保持忙碌状态。 公平性：使每个进程都获得合理的CPU时间，不会发生进程饥饿现象。 平衡性：进程的类型分计算型和I/O型，为使系统中的CPU和外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。 策略强制执行：对所制定的的策略其中包括安全策略，只要需要，就必须以准确地执行，即使会造成某些工作地延迟也要执行。 批处理系统的目标： 平均周转时间短：从作业提交给系统开始，到作业完成为止地这段时间间隔短/作业数。 作业在外存后备队列等待调度的时间、进程在就绪队列等待调度的时间、进程在CPU执行的时间、进程等待I/O地时间，即周转时间。 系统吞吐量高：单位时间内系统所完成的作业数多。 处理机利用率高：CPU的利用尽量不空闲。（单纯提高利用率应该选择计算量大的作业运行，由上述可看出这些要求存在一些矛盾。） 何谓作业、作业步和作业流？ 作业包含通常的程序和数据，还配有作业说明书。系统根据该说明书和JCB的内容对程序的运行进行控制。批处理系统中是以作业为基本单位从外存调入内存。 作业步是指每个作业运行期间都必须经过若干个相对独立相互关联的顺序加工的步骤。 作业流是指若干个作业进入系统后依次存放在外存上形成的输入作业流；在操作系统的控制下，逐个作业进行处理，于是形成了处理作业流。 在什么情况下需要使用作业控制块JCB？其中包含了哪些内容？ 每当作业进入系统时，系统便为每个作业建立一个作业控制块JCB，根据作业类型将它插入到相应的后备队列中。 JCB包含的内容通常有：(1)作业标识 (2)用户名称 (3)用户账户 (4)作业类型（CPU繁忙型、I/O芳名型、批量型、终端型）(5)作业状态 (6)调度信息（优先级、作业已运行）(7)资源要求 (8)进入系统时间 (9)开始处理时间 (10)作业完成时间 (11)作业退出时间 (12)资源使用情况等 在作业调度中应如何确定接纳多少个作业和接纳哪些作业？ 作业调度每次接纳进入内存的作业数，取决于多道程序度。应将哪些作业从外存调入内存，取决于采用的调度算法。最简单的是先来服务调度算法，较常用的是短作业优先调度算法和基于作业优先级的调度算法。 为什么要引入高响应比优先调度算法？它有何优点？ 在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽略了作业的运行时间，而SJF算法正好与之相反。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的算法。 优点：因此既照顾了短作业，又不致使长作业等待时间过长，从而改善了处理机调度的性能。 $优先权=\\frac{等待时间+要求服务时间}{要求服务时间}=\\frac{响应时间}{要求服务时间}$ 试说明低级调度的主要功能。 保存处理机的现场信息 按某种算法选取进程 把处理机分配给进程 在抢占调度方式中，抢占的原则是什么？ 抢占的原则有：时间片原则、优先权原则、短作业优先权原则等。 在选择调度方式和调度算法时，应遵循的准则是什么？ 面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。 面向系统的准则：系统吞吐量高、处理机利用率高、各类资源的平衡利用。 在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？ 批处理系统的调度算法：先来先服务(FCFS)、短作业优先(SJF)、优先级、高响应比优先(HRRN)、多级反馈队列调度(MFQ)算法。 分时系统的调度算法：时间片轮转法（轮转调度算法 RR）。 实时系统的调度算法：最早截止时间优先(EDF)、最低松弛度优先(LLF)算法。 何谓静态和动态优先级？确定静态优先级的依据是什么？ 静态优先级是指：在创建进程时确定且在进程的整个运行期间保持不变的优先级。 动态优先级是指：在创建进程时赋予的优先权，可以随进程推进或随其等待时间增加而改变的优先级，可以获得更好的调度性能。 确定进程优先级的依据：进程类型、进程对资源的需求和用户要求 试比较FCFS和SJF两种进程调度算法。 相同点：两种调度算法都可以用于作业调度和进程调度。 不同点：FCFS调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业，将它们调入内存、分配资源、创建进程、插入到就绪队列。该算法有利于长作业/进程，不利于短作业/进程。 SJF算法每次调度都从后备队列中选择一个或若干个估计运行时间最短的作业，调入内存中运行。该算法有利于短作业/进程，不利于长作业/进程。 在时间片轮转法中，应如何确定时间片的大小？ 时间片应略大于一次典型的交互需要的时间。 一般应考虑三个因素：系统对响应时间的要求、就绪队列中进程的数目和系统的处理能力。 时间片太小，会频繁执行进程调度和进程上下文切换，增加系统开销；太长，RR算法退化为FCFS算法。 通过一个例子来说明通常的优先级调度算法不能适用于实时系统？ 实时系统的调度算法很多，主要是基于任务的开始截止时间和任务紧急/松弛程度的任务优先级调度算法，通常的优先级调度算法(需要使用抢占式优先级调度算法)不能满足实时系统的调度实时性要求而不适用。例如：火箭发射系统，紧急停止发射。 为什么说多级反馈队列调度算法能较好地满足各方面用户的需求？ 终端型作业用户提交的作业大多属于较小的交互型作业，系统只要使这些作业在第一队列规定的时间片内完成，终端作业用户就会感到满足。 短批处理作业用户，开始时像终端型作业一样，如果在第一队列中执行一个时间片段即可完成，便可获得与终端作业一样的响应时间。对于稍长作业，通常只需在第二和第三队列各执行一时间片即可完成，其周转时间仍然较短。 长批处理作业，它将依次在第1，2，…，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。 所以，多级反馈队列调度算法能满足多用户需求。 为什么说传统的几种调度算法都不能算是公平调度算法？ 传统的调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作用业占用了多少处理机时间。 另外也为考虑到调度的公平性。 保证调度算法是如何做到调度的公平性的？ 保证每个相同类型的进程获得相同的处理机时间。 记录每个进程自创建以来已执行的处理时间。 计算每个进程应获得的时间，自创建以来已执行的处理时间/n（n为同时运行的同类型进程数）。 计算进程获得处理机的比率，进程实际执行的处理时间和应获得的时间之比。 比较进程获得处理机的比率，选择比率最小的进程分配处理机，直到它的比率不是最小为止。 公平分享调度算法又是如何做到调度的公平性的？ 该算法调度的公平性主要是针对用户而言，使用户获得相同的处理机时间，或所要求的时间比例。即需考虑每一个用户所拥有的进程数目。 为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？ 实时系统中通常有着多个实时任务。若处理机的处理能力不够强，有可能因为处理机忙不过来而使某些实时任务得不到及时处理，导致发生难以预料的后果。 按照调度方式可将实时调度算法分为哪几种？ 可分为非抢占式和抢占式两种算法。而非抢占式算法又分为非抢占式轮转和优先调度算法；抢占式调度算法又分为基于时钟中断的抢占式优先权和立即抢占式优先权调度算法。 什么是最早截止时间优先调度算法？举例说明。 根据任务的开始截止时间确定的任务优先级调度算法。截止时间越早则优先级越高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。 举例：非抢占式调度方式用于非周期实时任务。举例：P108 什么是最低松弛度优先调度算法？举例说明之。 该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高， 为该任务所赋予的优先级就愈高，以使之优先执行。举例：P109 何谓“优先级倒置”现象，可以采取什么方法来解决？ 在OS中存在着影响进程运行的资源而产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。（低优先级进程或线程占用了某些临界资源） 解决方法： （1）当低优先级进程进入临界区后不允许其处理机被抢占，让其执行完自己退出临界区。但可能使高优先级进程等待时间较长。 （2）低优先级进程进入临界区后，继承将要执行的高优先级进程的优先级，防止优先级在这两个进程之间的进程插队。 试分别说明可重用资源和可消耗资源的性质。 可重用性资源是一种可供用户重复使用多次的资源。 性质： 每一个可重用资源中的单元只能分配给一个进程使用，不允许多进程共享。 进程在使用可重用资源时，必须按照这样的顺序： 请求资源，失败则阻塞或循环等待。 使用资源，对资源进程操作。 释放资源，使用完成释放资源。 可消耗性资源又称为临时资源，它是在进程运行期间，由进程动态地创建和消耗。 性质： 每一类可消耗性资源地单元数目在进程运行期间是可以不断变化的。 进程在运行过程中，可以不断地创造可消耗性资源地单元，将它们放入缓冲区，以增加该资源类的单元数目。 进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给资源类中。 试举例说明竞争不可抢占资源引起的死锁。 一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。 两个进程P1、P2准备写两个文件F1、F2；P1先打开F1，P2“同时”打开“F2；P1试图打开F2，P2试图打开F1，各自阻塞无限等待。 为了破环“请求和保持”条件而提出了两种协议，试比较两种协议。 第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。 优点：简单、易行且安全。 缺点：资源被严重浪费、使进程经常会发生饥饿现象. 第二种协议：对第一种协议的改进，允许一个进程只获得运行初期所需地资源后，便开始运行。进程在运行过程中再逐步释放已分配给自己、且已用毕地全部资源，然后在请求新的资源。 优点：使进程更快地完成任务，提高设备利用率、减少进程发生饥饿地机率。 何谓死锁？产生死锁的原因和必要条件是什么？ 如果一组进程中的每一个进程都在等待仅由该进程组中的其它进程才能引发的事件，那么该组进程就是死锁。 产生死锁的原因为竞争资源（不可抢占资源、可消耗资源）和进程间推进顺序非法。其必要条件是：互斥条件、请求和保持条件、不可抢占条件、循环等待条件。 解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？ 决死锁的四种方法即预防、避免、检测和解除死锁中，预防死锁最容易实现；（检测）解除死锁使资源的利用率最高，并发程度提高（对应防范程度逐渐减弱）。 请详细说明可通过哪些途径预防死锁。 破坏“请求和保持”条件，就是如果系统有足够资源，便一次性把进程需要的所有资源分配给它； 破坏“不可抢占”条件，就是已经拥有资源的进程，当它提出新资源请求而不能立即满足时，必须释放它已保持的所有资源，待以后需要时再重新申请； 破坏“循环等待”条件，就是将所有资源按类型排序标号，所有进程对资源的请求 必须严格按序号递增的次序提出。 第四章 存储器管理 为什么要配置层次式存储器？ 无法同时满足对存储器速度快、容量大、价格低的要求。 设置多个存储器可以使存储器两端的硬件能并行工作； 采用多级存储系统，特别是 Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案； 在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力。增加CPU中寄存器数量大大缓解对存储器压力。 可采用哪几种方式将程序装入内存？它们分别适用于何种场合？ 绝对装入方式，只适用于单道程序环境。 程序中的相对地址（逻辑地址）与实际内存地址完全相同。 可（静态）重定位装入方式，适用于多道程序环境。 不允许程序运行时在内存中移位置。（运行前可移动，但必须修改程序和数据的绝对地址。） 逻辑地址与实际装入内存后的物理地址不同。 动态运行时装入方式，用于多道程序环境。 实际情况是程序在运行时在内存中的位置可能经常需要改变（换入换出） 装入内存的地址仍然都是逻辑地址，在真正执行时进行地址转换（需要重定位寄存器的支持）。 何谓静态链接？静态链接时需要解决两个什么问题？ 静态链接是指在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式。 需要解决的问题： 对相对地址进行修改。 各模块内部的相对地址加上对应的偏移量 变换外部调用符号。 各模块间的外部调用符号也变换为相对地址 何谓装入时动态链接？装入时动态链接方式有何优点？ 装入时动态链接是指将用户源程序编译后得到的一组目标模块（分开存放），在装入内存时采用边装入边链接的链接方式。 优点： 便于修改和更新。 不需要重新打开装入模块。 便于实现对目标模块的共享。 对比静态链接（不能实现共享），不需要每个应用都含有其目标模块的拷贝，可以将一个模块链接到多个应用上。 运行时的动态链接？运行时动态链接方式有何优点？ 运行时动态链接是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。 优点： 加快程序装入过程、节省大量的内存空间。 不需要将所有可能运行的模块全部装入内存，因为有些模块根本不会运行。 例如：错误处理的目标模块，若整个运行过程都不出现错误，这个模块就不会被使用。 在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？ 在每个分区的起始部分，设置一些控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部设置一个后向指针，通过前后向链接指针，将所有空闲分区链成一个双向链。当分区分配出去后，把状态位由“0”改为“1”。 为什么要引入动态重定位？如何实现？ 动态可重定位分区分配（动态分区分配的改进），使用了紧凑技术，程序或数据的地址发生变化，每次紧凑都要修改地址，很麻烦且大大影响系统效率。 在程序执行过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，即引入了动态重定位； 具体实现方法是在系统中增加一个重定位寄存器，用来装入程序在内存中的起始地址， 程序执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加之和，从而实现动态重定位。 什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？ 指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。 可分为：首次适应算法（First Fit，FF）、循环首次适应算法（Next Fit，NF）、最佳适应算法（Best Fit，BT）、最坏适应算法（Worst Fit，WF） 在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？ 在采用首次适应算法回收内存时可能出现4种情况： 回收区前邻空闲区。将回收区与前邻空闲区合并，将前邻空闲区大小修改为两者之和。 回收区后邻空闲区。将两区合并，改后邻空闲区始址为回收区始址，大小为两者之和。 回收区前后均邻空闲区。将三个分区合并，修改前邻空闲区大小为三者之和。 回收区前后均不邻空闲区。为回收区设置空闲区表项，填入回收区始址和大小并插入空闲区队列。 什么是基于索引搜索的动态分区分配算法？它可分为哪几种？ 基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，分区很多，采用顺序搜索分区方法可能会很慢，这时会采用基于索引的分配算法。 常用的有：快速适应算法（Quick Fit）、伙伴系统（Buddy System）、哈希算法。 伙伴系统表达式计算 略（P141） 分区存储管理中常用那些分配策略？比较它们的优缺点。 分区存储管理中的常用分配策略：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。 首次适应算法优缺点： 保留了高址部分的大空闲区，有利于后来的大型作业分配。 低址部分不断被划分，留下许多难以利用的小空闲区，每次查找都从低址开始增加了系统开销。 循环首次适应算法优缺点： 内存空闲分区分布均匀，减少了查找系统开销。 缺乏大空闲分区，导致不能装入大型作业。 最佳适应算法优缺点： 每次分配给文件的都是最适合该文件大小的分区。 内存中留下许多难以利用的小空闲区。 最坏适应算法优缺点： 剩下空闲区不太小，产生碎片几率小，对中小型作业分配分区操作有利。 存储器中缺乏大空闲区，对大型作业分区分配不利。 为什么要引入对换？对换可分为哪几种类型？ 最早用于用于麻省理工单用户分时系统CTSS，由于当时计算机内存非常小，为了使该系统能分时运行多个用户程序而引入。 两方面原因： 一方面，多道程序环境下，内存中存在某些进程由于某事件未发生而被阻塞运行，占用了大量内存空间。 另一方面，外存中又有许多作业，因内存空间不足而不能进入内存运行。 这是对系统资源的严重浪费，且使系统吞吐量下降。 对换类型： 整体对换：以整个进程为单位的对换，又称“进程对换”。 页面(分段)对换：以进程的一个页面或分段为单位的对换，又称“部分对换”。 对文件区管理的目标和对对换空间管理的目标有何不同？ 在具有对换功能的OS中，通常把磁盘空间分为文件区和对换区两部分。 对文件区管理的主要目标：提高文件的空间利用率，然后才是提高对文件的访问速度。因此，采取离散分配的方式。 对对换空间管理的主要目标：提高进程换入换出的速度，然后才是提高文件存储空间的利用率。为此，采取连续分配方式，较少考虑外存中的碎片问题。 为实现对换，系统应具备哪几方面的功能？ 系统应具备三方面功能：对换空间管理、进程换出、进程换入。 在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？ 并非每次将整个进程换出 原因： 从结构上讲，进程是由程序段、数据段和进程控制块PCB组成的，其中进程控制块总有部分或全部常驻内存，不被换出。 程序段和数据段可能正被若干进程共享，此时它们也不能被换出。 基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？ 分页存储管理方式、分段存储管理方式、段页式存储管理方式。 .什么是页面?什么是物理块?页面的大小应如何确定？ 页面：分页存储管理将进程的逻辑地址空间分成若干个页，并为各页加以编号。 物理块：把内存的物理地址空间分成若干个块，并为各块加以编号。 页面大小应选择适中，且页面大小应该是2的幂，通常为1KB~8KB。 什么是页表？页表的作用是什么？ 页表是分页式存储管理使用的数据结构。一个进程分为多少页，它的页表就有多少行。每一行记录进程的一页页号和它存放的物理块的块号对应关系。 作用：页表用于进行地址变换，即实现页号到物理块号的地址映射。 为实现分页存储管理，需要哪些硬件的支持？ 页表寄存器PTR 地址变换机构 基本的地址变换机构 具有快表（高速缓冲寄存器或称联想寄存器）的地址变换机构 在分页系统中是如何实现地址变换的？ 利用地址变换机构实现从逻辑地址到物理地址的转变换，通过页表来实现从页号到物理块号的变换，将逻辑地址中的页号转换为内存中的物理块号。 具有快表时是如何实现地址变换的？ 在CPU给出有效地址后，由地址变换机构自动将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号比较。 若找到匹配页号，表示要访问的页表项在快表中。可直接从快表读出该页对应物理块号，送到物理地址寄存器中。 如快表中没有对应页表项，则再访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页表项存入快表。 较详细的说明引入分段存储管理方式是为了满足用户哪几个方面的需求。 方便编程。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定 信息共享。在实现对程序和数据的共享时，是以信息逻辑单位为基础。 分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适 信息保护。对信息的逻辑单位进行保护（标上标记即可），分段能更有效方便地实现信息保护功能。 动态增长。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题 动态链接。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。 在具有快表的段页式存储管理方式中，如何实现地址变换? 类似第22题 为什么说分段系统较之分页系统更易于实现信息共享和保护？ 对于分页系统，每个页面是分散存储的，为了实现信息共享和保护，则页面之间需要一一对应起来，为此需要建立大量的页表项； 而对于分段系统，每个段都从0开始编址，并采用一段连续的地址空间，这样在实现共享和保护时，只需为所要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应起来即可。 分页和分段有何区别? 分页和分段都采用离散分配的方式，且都要通过地址映射机构来实现地址变换，这是它们的共同点； 对于它们的不同点有三： 第一，从功能上看，页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率，即满足系统管理的需要，而不是用户的需要；而段是信息的逻辑单位，它含有一组其意义相对完整的信息，目的是为了能更好地满足用户的需要； 第二，页的大小固定且由系统确定，而段的长度却不固定，决定于用户所编写的程序； 第三分页的作业地址空间是一维的，而分段的作业地址空间是二维的。 试全面比较连续分配和离散分配方式 连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单，只用于单用户单任务操作系统；分区方式分固定和动态分区。 离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段式存储管理旨在满足用户(程序员)的需要，段页式存储管理则将两者结合起来，具有分段系统便于实现、可共享、易于保护和动态链接等优点，又能像分页系统很好解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式； 第五章 虚拟存储器 常规存储器管理方式具有哪两大特征？它对系统性能有何影响？ 一次性：进程（作业）必须一次性地全部装入内存，对空间浪费非常大； 驻留性：在程序运行过程中，进程（作业）全部驻留在内存，暂时不用的数据无法释放，占用内存资源。 什么是程序运行时的时间局限性和空间局限性？ 时间局限性： 如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久的将来该存储单元可能再次被访问。 产生时间局限性的典型原因是在程序中存在着大量的循环操作。 空间局限性： 一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围内。 产生空间局限性的典型原因是程序是顺序执行的。 虚拟存储器有哪些特征？其中最本质的特征是什么？ 虚拟存储器有多次性、对换性、虚拟性三大特征。 多次性：多次性是相对于传统存储器管理方式而言地，是指一个作业中地程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行，即只需将当前要运行地那部分程序和数据装入内存即可开始运行。 对换性：对换性是相对于传统存储器管理方式的常驻性而言，是指一个作业中的程序和数据，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出。 虚拟性：虚拟性是指能够从逻辑上扩充内存容量，使用户看到的内存内容远大于实际内存容量。 最本质的特征是虚拟性。 实现虚拟存储器需要哪些硬件支持? 请求分页（段）的页（段）表机制。 缺页（段）中断机构。 地址变换机构。 实现虚拟存储器需要哪几个关键技术? 在分页请求系统中是在分页的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。允许只装入少数页面的程序（及数据），即可启动运行。 在请求分段系统中是在分段系统的基础上，增加了请求调段及分段置换功能后形成的段式虚拟存储系统。允许只装入少数段（而非所有段）的用户程序和数据，即可启动运行。 在请求分页系统中，页表应包括哪些数据项？每项的作用是什么? 页表应包括：页号、物理块号、状态位P、访问字段A、修改位M和外存地址。 其中状态位P指示该页是否调入内存，供程序访问时参考； 访问字段A用于记录本页在一段时间内被访问的次数，或最近己有多长时间未被访问，提供给置换算法选择换出页面时参考； 修改位M表示该页在调入内存后是否被修改过； 外存地址用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。 试比较缺页中断机构与一般的中断，它们之间有何明显的区别？ 一般中断只需要保护现场然后就直接跳到需及时处理的地方。 缺页中断除了保护现场之外，还要判断内存中是否有足够的空间存储所需的页或段，然后再把所需页调进来再使用。 试说明请求分页系统中的地址变换过程。 取逻辑地址分解为页号P和页内偏移w； 根据页号查找页表，获得该页的描述信息； 若该页中断位为1，产生缺页中断； 更新该页的描述信息； 根据页块号和页内偏移w，计算物理地址。 P170 何谓固定分配局部置换和可变分配全局置换的内存分配策略? 固定分配局部置换： 固定分配是指，为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。 局部置换是指，如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中，选出一页换出，然后再调入一页。 可变分配全局置换： 可变分配是指，先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地改变。 全局置换是指，如果进程在运行中发现缺页，则将OS所保留的空闲物理块或者以所有进程的全部物理块为标的，选择一块换出，然后将所缺之页调入。 在请求分页系统中，应从何处将所需页面调入内存？ 请求分页系统中的缺页从何处调入内存分三种情况： 系统拥有足够对换区空间时，可以全部从对换区调入所需页面，提高调页速度。在进程运行前将与该进程有关的文件从文件区拷贝到对换区。 系统缺少足够对换区空间时，不被修改的文件直接从文件区调入，当换出这些页面时，未被修改的不必换出，再调入时，仍从文件区直接调入。对于可能修改的，在换出时便调到对换区，以后需要时再从对换区调入。 UNIX方式。未运行页面从文件区调入。曾经运行过但被换出页面，下次从对换区调入。UNIX系统允许页面共享，某进程请求的页面有可能已调入内存，直接使用不再调入。 试说明在请求分页系统中页面的调入过程。 每当程序所要访问的页面未在内存时（存在位为“0”），便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。 该程序通过查找页表，得到该页在外存的物理块后： 如果此时内存能容纳新页，则启动磁盘I/O，将所缺之页调入内存，然后修改页表。 如果内存已满，则须先按照某种置换算法，从内存中选出一页准备换出； 如果该页未被修改过（修改位为“0”），可不必将该页写回磁盘； 但如果此页已被修改（修改位为“1”），则必须将它写回磁盘，然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中。 在缺页调入内存后，利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据。整个页面的调入过程对用户是透明的。 在请求分页系统中，常采用哪几种页面置换算法？ 采用的页面置换算法有： 最佳（Optimal）置换算法和先进先出（FIFO）置换算法，最近最久未使用（LRU）置换算法，最少使用（LFU）置换算法，Clock置换算法，页面缓冲算法（PBA）等。 在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。 M=3时，采用FIFO页面置换算法的缺页次数为9次，缺页率为75%； M=4时，采用FIFO页面置换算法的缺页次数为10次，缺页率为83%。 增加分配给作业的内存块数，反而增加了缺页次数，提高了缺页率，这种现象被称为是Belady现象。 实现LRU算法所需的硬件支持是什么？ 需要寄存器和栈两类硬件之一的支持。 寄存器： 给在内存中的每个页配置移位寄存器，当进程访问某物理块时，将相应寄存器的Rn-1位置1，此时，定时每隔一定时间将寄存器右移一位。最小数值对应的页面就是最近最久未使用的页面。 栈： 利用一个特殊栈保存当前使用的各页面的页面号，每当进程访问某页面时将该页面的页面号从栈中移出，将它压入栈顶。因此栈顶始终时最新被访问的页面的编号，栈底则是最近最久未使用的页面的页面号。 试说明改进型Clock置换算法的基本原理。 因为修改过的页面在换出时付出的开销比未被修改过的页面大，在改进型Clock算法中，既考虑页面的使用情况，还要增加置换代价的因素；在选择页面作为淘汰页面时，把同时满足未使用过和未被修改作为首选淘汰页面。 影响页面换进换出效率的若干因素是什么？ 页面置换算法：影响页面换进换出效率最重要的因素，直接影响进程在运行过程中的缺页率，影响页面换进换出的开销。 写回磁盘的频率：如果是采取每个页面换出时，就将它写回磁盘的策略，这意味着每换出一个页面，便需要启动一次磁盘。但如果在系统中建立了一个已修改换出页面链表，对每一个要被换出的页面（已修改），系统可暂不把它们写回磁盘，而是将它们挂在已修改换出页面链表上，仅当被换出页面数目达到一定值时，再将它们一起写回到磁盘上，这样就显著地减少了磁盘I/O的操作次数。或者说，减少已修改页面换出的开销。 读入内存的频率：在设置了已修改换出页面链表后，在该链表上就暂时有一批装有数据的页面，如果需要再次访问这些页面时，就不需从外存上调入，而直接从已修改换出页面链表中获取，这样也可以减少将页面从磁盘读入内存的频率，减少页面换进的开销。或者说，只需花费很小的开销，便可使这些页面，又回到该进程的驻留集中。 页面缓冲算法的主要特点是什么？它是如何降低页面换进换出的频率的？ 显著地降低了页面换进、换出的频率，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销； 由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如先进先出（FIFO）算法，它不需要特殊硬件的支持，实现起来非常简单。 在该系统中，内存分配策略上采用了可变分配和局部置换方式。 请求分页中的内存分配方式 为了能显著地降低了页面换进、换出的频率，在内存中设置了如下两个链表： 空闲页面链表：是一个空闲物理块链表，用于分配给频繁发生缺页的进程，以降低该进程的缺页率。当有一个未被修改的页要换出时，实际上并不将它换出到外存，而是把它们所在的物理块，挂在空闲链表的末尾。 修改页面链表：由已修改的页面所形成的链表。设置该链表的目的，是为了减少已修改页面换出的次数。降低将已修该页面写回磁盘的频率，以及降低将磁盘内容读入内存的频率。 在请求分页系统中产生抖动的原因是什么？ 抖动（Thrashing) ： 指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页程序或数据送磁盘的对换区中，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此频繁更换页面，使得系统把大部分时间用在了页面的调进换出上，而几乎不能完成任何有效的工作，我们称这种现象为”抖动”。 产生抖动的原因： CPU的利用率和多道程序度的对立统一矛盾关系，为了提高CPU利用率，可提高多道程序度，但单纯提高多道程序度又会造成缺页率的急剧上升，导致CPU的利用率下降，而系统的调度程序又会为了提高CPU利用率而继续提高多道程序度，形成恶性循环，我们称这时的进程是处于”抖动”状态。 何谓工作集？它是基于什么原理确定的？ 工作集: 某段时间间隔内，进程要访问的页面集合。 工作集可用于指导驻留集大小。 驻留集： 进程已装入内存的页面的集合，与系统采用的页面装入和页面置换算法有关。 经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。为了防止系统出现抖动现象，需要选择合适的驻留集体大小。 驻留集尺寸： 进程驻留在内存中的页面数量，与系统采用的页面分配策略有关。 工作集模型的原理： 让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。 如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。 不同提法： 工作集≠驻留集 工作集=驻留集 当前可以利用哪几种方法来防止“抖动”？ 采取局部置换策略 将”抖动”影响限制在较小范围内，但效果不太好，”抖动“发生后该进程会长期在磁盘I/O的等待队列中，还是会延长其它进程的缺页中断处理时间。 把工作集算法融入到处理机调度中 调入新作业前，必须检查每个进程在内存驻留的页面是否足够多。若是则可调入，若不是则应首先增加缺页率居高的作业的物理块。 利用“L=S”准则调节缺页率 L：缺页之间的平均时间，S：平均缺页服务时间（置换一个页面所需的时间）。 L远大于S：很少缺页，磁盘能力未得到充分利用；S大于L：频繁缺页，缺页速度超过磁盘处理能力；L=S：磁盘和处理机达到最大利用率。 选择暂停的进程 多道程序度偏高时，影响处理机利用率，为防止发生”抖动“，系统必须减少多道程序的数目。 试试说明如何利用“L=S”准则来调节缺页率，以避免“抖动”的发生? L：缺页之间的平均时间，S：平均缺页服务时间（置换一个页面所需的时间）。 L远大于S：很少缺页，磁盘能力未得到充分利用；S大于L：频繁缺页，缺页速度超过磁盘处理能力；L=S：磁盘和处理机达到最大利用率。 为了实现请求分段式存储管理，应在系统中增加配置哪些硬件结构？ 请求段表机制、缺段中断机制和地址变换机构。 在请求段表机制中，应设置哪些段表项？| 段名 | 段长 | 段基址 | 存取方式 | 访问字段A | 修改位M | 存在位P | 增补位 | 外存始址 || —— | —— | ——— | ———— | ————- | ———- | ———- | ——— | ———— | 说明请求分段系统中的缺页中断处理过程。 请对共享段表中的各项作简要说明。 共享进程计数器count： 记录有多少进程正在共享该分段，当某进程不再需要它时，检查是否为0，从而决定系统是否回收该段所占的内存区。 存取控制字段： 为不同进程赋予不同的存取权限（读写）。 段号： 对于一个共享段，在不同的进程中可以具有不同的段号，每个进程可用自己的段号去访问该共享段。 如何实现共享分段的分配和回收? 共享段的分配： 在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，当又有其它进程需要调用该共享段时，无须再为该段分配内存。 共享段的回收： 当共享此段的某进程不再需要该段时，若无其他进程使用该段，则由系统回收该共享段的物理内存，否则只是取消调用者进程在共享段表中的有关记录。 第六章 输入输出系统 试说明I/O系统的基本功能。 隐藏物理设备的细节 与设备的无关性 提高处理机和I/O设备的利用率 对I/O设备进行控制e.确保对设备的正确共享 错误处理 简要说明I/O软件的4个层次的基本功能。 中断处理程序： 用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后恢复现场，并返回到被中断的进程。 设备驱动程序： 与硬件直接有关，用来具体实现系统对设备发出的操作指令，驱动I/O设备工作。 设备独立性软件： 用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等。 用户层I/O软件： 用于实现用户与I/O设备交互。 I/O系统接口与软件/硬件（RW/HW）接口分别是什么接口? I/O系统接口： I/O系统接口是I/O系统与上层系统之间的接口，向上层提供对设备进行操作的抽象I/O命令，以方便高层对设备的使用。 软件/硬件（RW/HW）接口： 软件/硬件（RW/HW）接口的上面是中断处理程序和用于不同设备的设备驱动程序，它的下面是各种设备的控制器。 与设备无关性的基本含义是什么？为什么要设置该层？ 基本含义： 应用程序独立于具体使用的物理设备。 为了实现设备独立性而引入了逻辑设备和物理设备两概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，还必须使用物理设备名称。 设置原因： 为了提高0S的可适应性和可扩展性，在现代0S中都毫无例外地实现了设备独立性，也称设备无关性。 优点： 增加了设备分配时的灵活性。 易于实现I/O重定向（用于I/O操作的设备可以更换（即重定向），而不必改变应用程序。 试说明设备控制器的组成。 设备控制器与处理机的接口； 设备控制器与设备的接口； I/O逻辑。 为了实现CPU与设备控制器之间的通信，设备控制器应该具备哪些功能? 基本功能：接收和识别命令；数据交换；标识和报告设备的状态；地址识别；数据缓冲；差错控制。 什么是内存映像I/O？它是如何实现的？ 驱动程序将抽象I/O命令转换出的一系列具体的命令、参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的控制。这一工作可用两种方法来完成：利用特定的I/O指令、内存I/O映像。 内存映像I/O： 在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采用k。当k值处于0~n-1范围时，被认为是内存地址，若k≥n时，被认为是某个控制器的寄存器地址。 内存映像I/O方式统一了对内存和对控制器的访问方法，简化了I/O的编程。 为什么说中断是0S赖以生存的基础？ 中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，没有中断，就不可能实现多道程序，因为进程之间的切换是通过中断来完成的。 另一方面，中断也是设备管理的基础，为了提高处理机的利用率和实现CPU和I/O设备并执行，也必需有中断的支持。中断处理程序是I/O系统中最低的一层。 对中断源的两种处理方式分别用于那种场合？ 屏蔽（禁止)中断： 当处理机正在处理一个中断时，将屏蔽掉所有的中断，直到处理机已处理完本次中断，再去检查是否有中断产生。所有中断按顺序处理，优点是简单，但不能用于实时性要求较高的中断请求。 嵌套中断： 在设置了中断优先级的系统中，当同时有多个不同优先级的中断请求，CPU优先响应优先级最高的中断请求，高优先级的中断请求可以抢占正在运行的低优先级中断的处理机。 设备中断处理程序通常需完成哪些工作？ 唤醒被阻塞的驱动进程。 保护被中断进程的CPU环境。 转入相应的设备处理程序。 中断处理。 恢复被中断进程的现场。 简要说明中断处理程序对中断进行处理的几个步骤。 测定是否有未响应的中断信号 唤醒被阻塞的驱动进程。 保护被中断进程的CPU环境 转入相应的设备处理程序 中断处理 恢复CPU的现场并退出中断 试说明设备驱动程序具有哪些特点。 驱动程序是请求I/O进程（与设备无关的软件）与设备控制器间的一个通信和转换程序。 驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，不同类型的设备应配置不同的驱动程序。 驱动程序与I/O设备采用的控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。 由于驱动程序与硬件紧密相关，部分程序必须用汇编语言书写，很多驱动程序的基本部分往往固化在ROM中。 驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。 设备驱动程序通常需要完成哪些工作？ 接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。 检查用户I/O请求合法性，了解I/O设备状态，传递有关参数，设置设备工作方式。 发出I/O命令，如果设备空闲，便启动分配到的I/O设备，完成指定I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。 及时响应由控制器或通道发来的中断请求，根据中断类型调用相应中断处理程序处理。 对于有通道的计算机，驱动程序还应该根据用户I/O请求自动构成通道程序。 简要说明设备驱动程序的处理过程可分为哪几步。 将抽象要求转换为具体要求 对服务请求进行校验 检查设备的状态 传送必要的参数 启动I/O设备 试说明I/O控制发展的主要推动因素是什么？ 尽量减少CPU对I/O控制的干预，把CPU从繁杂的I/O控制中解脱出来，以便更多地去完成数据处理任务。 缓和CPU的高速性和设备的低速性之间速度不匹配的矛盾，以提高CPU的利用率和系统的吞吐量。 提高CPU和I/O设备操作的并行程度，使CPU和I/O设备都处于忙碌状态，从而提高整个系统的资源利用率和系统吞吐量。 有哪几种I/O控制方式？各适用于何种场合？ 程序 I/O 方式、中断驱动 I/O 控制方式、DMA I/O 控制方式、I/O 通道控制方式。 程序 I/O 方式（使用轮询的可编程 I/O 方式），以字（符）为单位进行I/O，适用于早期的计算机系统中，并且是无中断的计算机系统。 中断驱动 I/O 控制方式（使用中断的可编程 I/O 方式），以字（节）为单位进行I/O，是普遍用于现代的计算机系统中。 DMA I/O 控制方式（直接存储器访问方式），数据传输基本单位是数据块，适用于I/O设备为块设备时在和主机进行数据交换的一种I/O控制方式。 当I/O设备和主机进行数据交换是一组数据块时通常采用I/O通道控制方式（DMA方式的发展），但此时要求系统必须配置相应的通道及通道控制器。 试说明DMA的工作流程。 DMA是Direct Memory Access的缩写，意为存储器直接访问。可以不通过CPU而在DMA控制器的控制下，高速地与I/O设备和存储器之间交换数据。 CPU需要访问外存时便发送一条访问命令给DMA的命令寄存器CR、一个内存地址码给DMA的内存地址寄存器MAR、本次要传送的字（节）数给DMA的数据计数器DC、外存地址给DMA的I/O控制逻辑。 CPU启动DMA控制器后转向其他处理。 DMA控制器负责控制数据在内存与外设之间传送。每传送一个字（节）就需挪用一个存储器周期，按MAR从内存读出或写入内存一个字（节），修改MAR和计算器DC。 当DC修改为0时，表示传送结束，由DMA向CPU发出中断请求。 为什么要引入与设备的无关性?如何实现设备的独立性？ 设备无关性（独立性）的基本含义是应用程序独立于具体使用的物理设备，应用程序以逻辑设备名请求使用某类设备。 引入原因： 为了方便用户和提高OS的可适应性与可扩展性。 实现了设备独立性功能可带来两方面的好处： 设备分配时的灵活性。 易于实现I/O重定向。 如何实现： 为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中，使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件，必须在驱动程序之上设置一层设备独立性软件，执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。 与设备的无关的软件中，包括了哪些公有操作的软件? 设备驱动程序的统一接口 缓冲管理 差错控制 对独立设备的分配与回收 独立于设备的逻辑数据块 在考虑到设备的独立性时，应如何分配独占设备？ 进程以逻辑设备名提出I/O请求。 根据逻辑设备表获得I/O请求的逻辑设备对应物理设备在系统设备表中的指针。 检索系统设备表，找到属于请求类型、空闲可用且分配安全设备的设备控制表，将对应设备分配给请求进程。如果未找到安全可用的空闲设备，则把请求进程的进程控制块挂到相应类型设备的等待队列上等待唤醒和分配。 到设备控制表中找出与其相连接的控制器的控制器控制表，根据状态字段判断是否忙 碌，忙则等待；否则将该控制器分配给进程。 到该控制器的控制器控制表中找出与其相连接的通道的通道控制表，判断通道是否忙 碌，忙则等待；否则将该通道分配给进程。 只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功，然后便可启 动设备进行数据传送。 何谓设备虚拟？实现设备虚拟式所依赖的关键技术是什么？ 通过虚拟技术可将一台独占设备变换成若干台逻辑设备，供若干个用户（进程）同时使用，通常把这种经过虚拟技术处理后的设备称为虚拟设备。 其实现所依赖的关键技术是SPOOLING技术。 在实现后台打印时，SPOOLing 系统应为请求I/O的进程提供哪些服务？ 由输出进程在输出井中为之申请一空闲盘块区，并将要打印的数据送入其中； 输出进程再为用户进程申请一张空白的用户打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。 一旦打印机空闲，输出进程便从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据从输出井传送到内存缓冲区，再由打印机进行打印。 假脱机系统向用户提供共享打印机的基本思想是什么？ 对每个用户而言，系统并非及时执行其程序输出数据的真实打印操作，而只是即时将数据输出到缓冲区，这时的数据并未真正被打印，只是让用户感觉系统已为他打印； 真正的打印操作，是在打印机空闲且该打印任务在等待队列中已排到队首时进行的；以上过程是对用户屏蔽的，用户是不可见的。 引入缓冲的主要原因是什么？ 缓和CPU与I/O设备之间速度不匹配的矛盾； 减少对CPU的中断频率，放宽对中断响应时间的限制； 解决数据粒度（数据单元大小）不匹配的问题； 提高CPU和I/O设备之间的并行性。 在单缓冲情况下，为什么系统对一块数据的处理时间为$Max(C,T)+M$？ 在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T； 操作系统将缓冲区数据传送给用户区的时间为M； 而CPU对这一块数据进行计算得时间为C。 在单缓冲情况下，由于设备的输入操作和CPU的处理操作可以并行，所以系统对每一整块数据的处理时间为 $Max(C,T)+M$。 为什么在双缓冲情况下，系统对一块数据的处理时间为$Max(C,T)$？ 该方式又称缓冲对换方式，在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。 此时操作系统可以从第一缓冲区移出数据，并送入用户进程。 接着由CPU对数据进行计算。 在双缓冲区中，不仅设备的输入操作和CPU的处理操作可以并行，设备的输入操作和数据的传送操作也可以并行，因此耗时大约为$Max(C,T)$。考虑到M是内存中数据块的“搬家”耗时，非常短暂可以省略，因此近似地认为是：$Max(C,T)$。 试绘图说明把多缓冲用于输出时的情况。 试说明收容输入工作缓冲区和提取输出工作缓冲区的工作情况。 收容输入工作缓冲区的工作情况为： 在输入进程需要输入数据时，调用GetBuf（EmptyQueue)过程，从EmptyQueue队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区Hin。 然后把数据输入其中，装满后再调用PutBuf（InputQueue,Hin)过程，将该缓冲区挂在输入队列InputQueue的队尾。 提取输出工作缓冲区的工作情况为： 当要输出数据时，调用GetBuf（OutputQueue)过程，从输出队列的队首取得一装满输出数据的缓冲区作为提取输出工作缓冲区Sout。 在数据提取完后，再调用PutBuf(EmptyQueue,Sout)过程，将该缓冲区挂到空缓冲队列EmptyQueue的队尾。 何谓安全分配方式和不安全分配方式？ 安全分配方式是指每当进程发出I/0请求后，便进入阻塞状态，直到其I/0操作完成时才被唤醒。 在采用这种分配策略时，一旦进程已获得某种设备资源后便阻塞，使它不可能再请求任何资源，而在它运行时又不保持任何资源。这种分配方式已经摒弃了造成死锁的“请求和保持”条件，分配是安全的。缺点是进程进展缓慢，CPU与I/0设备串行工作。 不安全分配方式是指进程发出I/0请求后仍继续执行，需要时又可发出第二个I/0请求、第三个I/0请求。仅当进程请求的设备已被另一个进程占有时，进程才进入阻塞状态。 优点是一个进程可同时操作多个设备，进程推进迅速。缺点是分配不安全，可能具有“请求和保持”条件，可能造成死锁。因此，在设备分配程序中需增加一个功能，用于对本次的设备分配是否会发生死锁进行安全性计算，仅当计算结果表明分配安全的情况下才进行分配。 磁盘访问时间由哪几部分组成？每部分时间应如何计算？ 磁盘访问时间由寻道时间$T_s$、旋转延迟时间$T_\\tau$、传输时间$T_t$ 三部分组成。 $T_s$是启动磁臂时间 s 与磁头移动 n 条磁道的时间和，即$T_s=m×n+s$。 $T\\tau$是指定扇区移动到磁头下面所经历的时间，即$T\\tau=1/2r$。 硬盘$15000r/min$时，每转需时$4ms$$Tr$为$2ms$；软盘$300$或$600r/min$时$T\\tau$为$50$~$100ms$。 $T_t$是指数据从磁盘读出或向磁盘写入经历的时间，即$T_t=b/rN$。 $Tt$的大小与每次读/写的字节数 b 和旋转速度 r 有关，N 为一条磁道上的字节数，其中当一次读/写的字节数相当于半条磁道上的字节数时 $T\\tau=T_t$。 因此访问时间：$T_a=T_s+\\frac{1}{2r}+\\frac{b}{rN}$ 目前常用的磁盘调度算法有哪几种？每种算法优先考虑的问题是什么？ 目前常用的磁盘调度算法有先来先服务（FCFS）、最短寻道时间优先（SSTF）及扫描（SCAN）等算法。 先来先服务算法优先考虑进程请求访问磁盘的先后次序。 最短寻道时间优先（Shortest Seek Time First）算法优先考虑要求访问的磁道与当前磁头所在磁道距离是否最近。 扫描算法考虑欲访问的磁道与当前磁道间的距离，更优先考虑磁头当前的移动方向。","link":"/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"title":"数据挖掘习题","text":"填空题 数据仓库就是一个面向主题的、集成的、相对稳定的、反映历史变化的数据集合。 数据处理通常分成两大类：联机事务处理(OLTP)和联机分析处理(OLAP)。 调和数据是存储在企业级数据仓库(EDW)和操作型数据存储中的数据。 使用星型模式可以从一定程度上提高查询效率。因为星型模式中数据的组织已经经过预处理，主要数据都在庞大的事实表中。 数据仓库中存在不同综合级别的数据。一般把数据分成四个级别：早期细节级、当前细节级、轻度综合级和高度综合级。 关联规则的经典算法包括Apriori和FP-growth，其中FP-growth的效率更高。 分类的过程包含获取数据、预处理、分类器设计和分类决策。 分类器设计阶段包括三个过程：划分数据集、分类器构造和分类器测试。 分类问题中常用的评价准则有精确度、查全率和查准率、F-measure和几何均值。 支持向量机中常用的核函数有多项式核函数、径向核函数和S型核函数。 聚类分析包括连续型、二值离散型、多值离散型和混合类型四种类型描述属性的相似度计算方法。 连续型属性的数据样本之间的距离有欧氏距离、曼哈顿距离和明考斯基距离。 划分聚类方法对数据集进行聚类时包括三个要点：选定某种距离作为数据样本间的相似性度量、选择评价聚类性能的准则函数和选择某个初始类，之后用迭代的方法得到聚类结果，使得评价聚类的准则函数取得最优值。 层次聚类方法包括：凝聚型层次聚类和分解型层次聚类两种层次聚类方法。 简述题 请简述数据挖掘中关联规则Apriori算法的思想。 Apriori算法多次扫描交易记录集，目的是产生长度不同的频繁集。首先产生1-频繁集$L_1$，在此基础上经过连接、修剪产生2-频繁集$L_2$，直到无法产生新的频繁集则算法终止。 这里在第 k 次循环中，也就是产生k-频繁集$Lk$的过程中，首先产生k-候选频繁集的集合$C_k$，简称候选集。$C_k$中的每一项集是对两个只有一个项不同的属于$L{k-1}$的频繁集连接产生。$C_k$进行修剪，产生对应的$L_k$。 请比较PCA（主成分分析）和LDA（线性判别分析）的区别。 PCA为非监督降维，LDA为有监督降维 PCA希望投影后的数据方差尽可能的大（最大可分性），因为其假设方差越多，则所包含的信息越多；而LDA则希望投影后相同类别的组内方差小，而组间方差大。LDA能合理运用标签信息，使得投影后的维度具有判别性，不同类别的数据尽可能的分开。 // 请分析特征选择和特征提取有何区别？ 这两者达到的效果是一样的，就是试图去减少特征数据集中的属性(或者称为特征)的数目，但是两者所采用的方式方法却不同。 特征提取的方法主要是通过属性间的关系，如组合不同的属性得到新的属性，这样就改变了原来的特征空间。 特征选择的方法是从原始特征数据集中选择出子集，是一种包含的关系，没有更改原始的特征空间。 聚类和分类有什么区别和联系？ 区别 数据分类方法是在已知类标号的训练集基础上进行分类器设计工作的，所以分类方法又称为监督学习方法。 聚类分析方法使用的数据样本没有类标号，聚类分析又称为非监督学习方法。聚类分析是研究如何在没有训练的条件下把样本划分为若干类，聚类之后的数据集可以直接用来进行科学分析，也可以作为其他方法的训练集。 联系 宏观上，看起来都是把“杂乱的数据”进行划分成各种类。 TF-IDF算法是什么？有什么实际意义？ TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。 字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。 它经常被用作搜索信息检索，文本挖掘和用户建模的加权因子。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。 数据挖掘与统计的区别和联系？ 统计学主要利用概率论建立数学模型，是研究随机现象的常用数学工具之一。 数据挖掘分析大量数据，发现其中的内在联系和知识，并以模型或规则表达这些知识。 虽然两者采用的某些分析方法（如回归分析）是相同的，但是数据挖掘和统计学是有本质区别的： 一个主要差别在于处理对象（数据集）的尺度和性质。数据挖掘经常会面对尺度为GB甚至TB数量级的数据库，而用传统的统计方法很难处理这么大尺度的数据集。传统的统计处理往往是针对特定的问题采集数据（甚至通过试验设计加以优化）和分析数据来解决特定问题；而数据挖掘却往往是数据分析的次级过程，其所用的数据原本可能并非为当前研究而专门采集的，因而其适用性和针对性可能都不强，在数据挖掘的过程中，需要对异常数据及冲突字段等进行预处理，尽可能提高数据的质量，然后才对经过预处理的数据进行数据挖掘。 另一个差别在于面对结构复杂的海量数据，数据挖掘往往需要采用各种相应的数学模型和应用传统统计学以外的数学工具，才能建立最适合描述对象的模型或规则。 总之，统计学在生物医学研究中常采用假设检验（或称显著性检验）方法，其侧重假设驱动（hypothesis-driven）,即提出假设并加以检验；而数据挖掘则不具备这样的功能，其主要是数据驱动（data-driven），即从数据中发现规律并得到知识。 什么是关联规则？关联规则的应用有哪些？ 关联规则挖掘最初由R.Agrawal等人提出，用来发现超级市场中用户购买的商品之间的隐含关联关系，并用规则的形式表示出来，称为关联规则(Association Rule)。 关联规则除了可以发现超市购物中隐含的关联关系之外，还可以应用于其他很多领域。关联规则的应用还包括文本挖掘、商品广告邮寄分析、网络故障分析等。 什么是分类？分类的应用领域有哪些？ 分类是指把数据样本映射到一个事先定义的类中的学习过程，即给定一组输入的属性向量及其对应的类，用基于归纳的学习算法得出分类。 分类问题在商业、银行业、医疗诊断、生物学、文本挖掘、因特网筛选等领域都有广泛应用。 例如，在银行业中，分类方法可以辅助工作人员将正常信用卡用户和欺诈信用卡用户进行分类，从而采取有效措施减小银行的损失；在医疗诊断中，分类方法可以帮助医疗人员将正常细胞和癌变细胞进行分类，从而及时制定救治方案，挽救病人的生命；在因特网筛选中，分类方法可以协助网络工作人员将正常邮件和垃圾邮件进行分类，从而制定有效的垃圾邮件过滤机制，防止垃圾邮件干扰人们的正常生活。 什么是聚类分析？聚类分析的应用领域有哪些？ 聚类分析是将物理的或者抽象的数据集合划分为多个类别的过程，聚类之后的每个类别中任意两个数据样本之间具有较高的相似度，而不同类别的数据样本之间具有较低的相似度。 聚类分析在科学数据分析、商业、生物学、医疗诊断、文本挖掘、Web数据挖掘等领域都有广泛应用。 在科学数据分析中，比如对于卫星遥感照片，聚类可以将相似的区域归类，有助于研究人员根据具体情况做进一步分析；在商业领域，聚类可以帮助市场分析人员对客户的基本数据进行分析，发现购买模式不同的客户群，从而协助市场调整销售计划；在生物学方面，聚类可以帮助研究人员按照基因的相似度对动物和植物的种群进行划分，从而获得对种群中固有结构的认识；在医疗诊断中，聚类可以对细胞进行归类，有助于医疗人员发现异常细胞的聚类，从而对病人及时采取措施；在文本挖掘和Web数据挖掘领域中，聚类可以将网站数据按照读者的兴趣度进行划分，从而有助于网站内容的改进。 书上的题 简述你对数据仓库未来发展趋势的看法。 数据仓库技术的发展包括数据抽取、存储管理、数据表现和方法论等方面。在数据抽取方面，未来的技术发展将集中在系统集成化方面。它将互连、转换、复制、调度、监控纳入标准化的统一管理，以适应数据仓库本身或数据源可能的变化，使系统更便于管理和维护。在数据管理方面，未来的发展将使数据库厂商明确推出数据仓库引擎，作为数据仓库服务器产品与数据库服务器并驾齐驱。在这一方面，带有决策支持扩展的并行关系数据库将最具发展潜力。在数据表现方面，数理统计的算法和功能将普遍集成到联机分析产品中，并与Internet/Web技术紧密结合。按行业应用特征细化的数据仓库用户前端软件将成为产品作为数据仓库解决方案的一部分。数据仓库实现过程的方法论将更加普及，将成为数据库设计的一个明确分支，成为管理信息系统设计的必备。 请列出3种数据仓库产品，并说明其优缺点。 Essbase（MOLAP产品），采用以服务器为中心的分布式体系结构的OLAP服务器。 优点是提供丰富的API，具有几百个计算公式，支持多种计算，用户可以自己构建复杂的查询；可以充分定制开发，有30多个前端工具可供选择，支持多种财务标准，能与其他数据源集成。 缺点是开发难度较大，部署也不容易。 NCR Teradata 是高端数据仓库市场最有力的竞争者，主要运行在UNIX操作系统平台上。 优点是产品性能很好。 缺点是产品价格相对较高，中小企业用户难以接受，其联机多维分析相对较弱。 SAS系统是SAS公司提供的数据仓库解决方案包括30多个专用模块。 优点是功能强大、性能高、特长突出。 缺点是系统比较复杂。 什么是数据仓库的数据ETL过程？ 数据的ETL过程就是调和数据的过程。 数据ETL是用来实现异构数据源的数据集成，即完成数据的抓取/抽取、清洗、转换、加载与索引等数据调和工作。 简单地说，数据是从企业内外部的各业务处理系统（操作型数据）流向企业级数据仓库（EDW）或操作型数据存储区(ODS)，在这个过程中，要根据企业（或其他组织）的数据模型和元数据库对数据进行调和处理，形成一个中间数据层，然后再根据分析需求，从调和数据层（EDW、ODS）将数据引入导出数据层，如形成满足各类分析需求的数据集市。 什么是星型模式？它的特征是什么？ 星型模式是最流行的数据仓库导出数据层的设计结构。 它的特征是： 在星模式中，事实表居中，多个维表呈辐射状分布于其四周，并与事实表连接。 位于星形中心的实体是事实表，是用户最关心的基本实体和查询活动的中心，为数据仓库的查询活动提供定量数据。 位于星模式四周的实体是维度实体，其作用是限制和过滤用户的查询结果，缩小访问范围。 每个维表都有自己的属性，维表和事实表通过关键字相关联。 什么是信息包图法？它为什么适用于数据仓库的概念模型的设计？ 信息包图法，也叫用户信息需求表，就是在一张平面表格上描述元素的多维性，其中的每一个维度用平面表格的一列表示，通常的维度如时间、地点、产品和顾客等。 而细化本列的对象就是类别，例如时间维度的类别可以细化到年、月、日，甚至小时；平面表格的最后一行（代表超立方体中的单元格）即为指标度量值，例如，某年在某销售点的某类产品的实际销售额。创建信息包图时需要确定最高层和最低层的信息需求，以便最终设计出包含各个层次需要的数据仓库。 总之，信息包图法是一种自上而下的数据建模方法，即从用户的观点开始设计（用户的观点是通过与用户交流得到的），站在管理者的角度把焦点集中在企业的一个或几个主题上，着重分析主题所涉及数据的多维特性，这种自上而下的方法几乎考虑了所有的信息源，以及这些信息源影响业务活动的方式。 什么是关联规则？关联规则的应用有哪些？ 关联规则挖掘最初由R.Agrawal等人提出，用来发现超级市场中用户购买的商品之间的隐含关联关系，并用规则的形式表示出来，称为关联规则(Association Rule)。 关联规则除了可以发现超市购物中隐含的关联关系之外，还可以应用于其他很多领域。关联规则的应用还包括文本挖掘、商品广告邮寄分析、网络故障分析等。 关联规则的分类有哪些？关联规则挖掘的步骤包括什么？ 关联规则的分类： 基于规则中涉及到的数据的维数，关联规则可以分为单维的和多维的。 基于规则中数据的抽象层次，可以分为单层关联规则和多层关联规则。 基于规则中处理的变量的类型不同，关联规则可以分为布尔型和数值型。 关联规则挖掘的步骤： 找出交易数据库中所有大于或等于用户指定的最小支持度的频繁项集； 利用频繁项集生成所需要的关联规则，根据用户设定的最小可信度进行取舍，产生强关联规则。 Apriori 算法的计算题：P107 什么是分类？分类的应用领域有哪些？ 分类是指把数据样本映射到一个事先定义的类中的学习过程，即给定一组输入的属性向量及其对应的类，用基于归纳的学习算法得出分类。 分类问题在商业、银行业、医疗诊断、生物学、文本挖掘、因特网筛选等领域都有广泛应用。 例如，在银行业中，分类方法可以辅助工作人员将正常信用卡用户和欺诈信用卡用户进行分类，从而采取有效措施减小银行的损失；在医疗诊断中，分类方法可以帮助医疗人员将正常细胞和癌变细胞进行分类，从而及时制定救治方案，挽救病人的生命；在因特网筛选中，分类方法可以协助网络工作人员将正常邮件和垃圾邮件进行分类，从而制定有效的垃圾邮件过滤机制，防止垃圾邮件干扰人们的正常生活。 什么是聚类分析？聚类分析的应用领域有哪些？ 聚类分析是将物理的或者抽象的数据集合划分为多个类别的过程，聚类之后的每个类别中任意两个数据样本之间具有较高的相似度，而不同类别的数据样本之间具有较低的相似度。 聚类分析在科学数据分析、商业、生物学、医疗诊断、文本挖掘、Web数据挖掘等领域都有广泛应用。 在科学数据分析中，比如对于卫星遥感照片，聚类可以将相似的区域归类，有助于研究人员根据具体情况做进一步分析；在商业领域，聚类可以帮助市场分析人员对客户的基本数据进行分析，发现购买模式不同的客户群，从而协助市场调整销售计划；在生物学方面，聚类可以帮助研究人员按照基因的相似度对动物和植物的种群进行划分，从而获得对种群中固有结构的认识；在医疗诊断中，聚类可以对细胞进行归类，有助于医疗人员发现异常细胞的聚类，从而对病人及时采取措施；在文本挖掘和Web数据挖掘领域中，聚类可以将网站数据按照读者的兴趣度进行划分，从而有助于网站内容的改进。 请描述K-means聚类算法的操作步骤：P139 贝叶斯网络的三个主要议题是什么？ 预测 贝叶斯网络的预测是指从起因推测一个结果的推理，也成为由顶向下的推理。 诊断 贝叶斯网络的诊断是指从结果推测一个起因的推理，也称为由底至上的推理。 学习 贝叶斯网络的学习是指由先验的贝叶斯网络得到后验的贝叶斯网络的过程。 怎样从历史数据中训练出结点之间的条件概率或联合条件概率？ 要训练条件概率$P(B|A)$，可以在历史数据中统计A发生的次数$T(A)$，然后统计在A发生的数据中B发生的次数$T(A,B)$，条件概率$P(B|A) = T(B)/T(A)$。 要训练联合条件概率$P(C|A,B$)，可以在历史数据中统计A、B共同发生的次数$T(A,B)$，然后在A、B共同发生的数据中统计C发生的次数T$(A,B,C)$，联合条件概率$P(C|A,B)=T(A,B,C)/T(A,B)$。 以上的符号A、B、C可以表示某个事件，也可以表示该事件的相反事件。 如果贝叶斯网络的各个结点都没有任何证据，从历史数据中如何用两种不同的方法的得到各结点的发生概率？ 用各节点的发生次数除以总的数据条数，就是各个节点的发生概率。 首先，用第一种方法计算原因节点的发生概率，然后计算原因节点到中间节点或结果节点的条件概率，最后根据原因节点的概率和这些条件概率计算结果节点的概率。 前馈网络和递归网络有什么本质区别？ 前馈网络和递归网络的本质区别是网络的某些输出是不是循环作为网络的输入。 前馈网络的所有输出都不能作为输入，而递归网络的某些输出可以循环作为网络的输入。 多层前馈网络中隐藏层神经元的作用是什么？ 多层前馈网络中隐藏层神经元的作用是增强网络的适应能力。 通过隐藏层，多层前馈网络可以逼近系统中任意非线性的成分。 在 BP 算法中，总体误差对网络输出的偏导数和和有序导数是否一致？总体误差对网络输入的偏导数和有序导数是否一致？ 在BP算法中，总体误差对网络输出的偏导数和有序导数始终一致。 这是因为：总体误差与网络输出变量之间没有中间变量。 而总体误差对网络输入的偏导数和有序导数是不一致的。 这是因为：总体误差和输入变量之间有中间变量。 遗传算法的主要应用有哪些？ 函数优化问题 组合优化问题 生产调度问题 自动控制 图像处理 人工生命 遗传编程 机器学习 简单遗传算法包括哪些步骤？ SGA的基本流程如下： 初始化，产生初始种群。 个体评价，即计算种群中每个个体的适应度。 按选择概率Ps，执行选择算子，从当前种群中选择部分个体进入下一代种群。 按交叉概率Pc，执行交叉算子。 按变异概率Pm，执行变异算子。 若满足设定的终止条件，则输出种群中适应度最优的个体作为问题的最优解或满意解，否则执行（2）。","link":"/2020/12/24/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%A0%E9%A2%98/"},{"title":"数据库-概念","text":"信息与数据的概念。数据与信息的区别与联系。 信息：信息是现实世界各种事物通过人脑抽象后形成的概念。 数据：数据是信息的一种符号化表示方法。 联系：信息的载体是数据；数据的内涵是信息。 数据管理技术发展的三个阶段，三者之间最最最主要的区别是什么。 人工管理阶段、文件管理阶段、数据库管理阶段。 最主要的区别：数据的共享性和独立性程度。 数据库系统的组成（提示：有至少5个部分）及各自的作用。 数据库 BD：数据的汇集，数据以一定组织形式存储在存储介质上。 数据库管理系统 DBMS：管理数据库的专用软件。 数据库管理员 DMA：负责数据库的规划、建立、维护等工作。 应用系统：以数据库为基础的各种应用程序。 用户：通过应用程序或系统的用户接口使用数据库。 数据模型的三要素及各自的作用。 数据结构：数的静态特征，定义如何组织存储数据。 数据操作：数据的动态特征，操作及操作规则的集合。 完整性约束：数据必须具备的条件，保证数据的正确、有效、相容。 数据库管理系统的主要功能有哪一些。 数据定义、数据操作、运行管理、组织维护、其他（通信、数据转换）。 三级模式/二级映像的组成及其每一组成的作用。这种结构的意义是什么。 外模式：用户与数据库系统的接口，数据库用户看得见和使用的部分数据的描述，通常是模式的子集。 模式：又称逻辑模式或结构模式，对数据库全体数据的逻辑结构以及安全性、完整性的描述。（所有用户的公有逻辑数据视图） 内模式：又称存储模式，是对数据库物理存储结构的描述。 外（子）模式/模式映像：在外模式中定义的某一个外模式和模式之间的对应关系。当模式发生改变时，DBA 可以对此映像作出相应的改变，从而可以使外模式保持不变，这就是数据的逻辑独立性。 模式/内模式映像：在模式中定义的数据的全局逻辑结构与其存储结构之间的对应关系。当存储结构改变时，DBA 只需对该映像作出相应的调整，从而可以使模式保持不变，这就是数据的物理独立性。 意义：是数据库系统达到了高度的数据独立性。 数据独立性的概念与意义。有哪两级独立性。 数据的独立性是指物理独立性和逻辑独立性。 逻辑独立性：当数据的总体逻辑改变时，数据的局部逻辑结构不变。 物理独立性：当存储结构改变时，数据的逻辑结构不变。 意义：独立性越高，共享越方便、数据使用和程序的编写越灵活。 写出以下数据库专有名词的英文全称和中文。 数据库(DB)、数据库管理系统(DBMS)、数据库管理员(DBA) 数据库定义语言(DDL)、数据库操作（纵）语言(DML) 概念数据模型(CDM)、逻辑概念模型(LDM)、物理概念模型(PDM) 关系应该具有哪6个性质？ 写出每一个性质的意义。 关系中任意两个元组不能完全相同，每一个元组都是唯一的。 元组的顺序无关性，任意元组的次序可以任意交换。 列是同质的，即同一列中的属性值必须是同一种数据类型，出自同一个域。 一个关系中的属性名必须互不相同，但不同的属性可以出自同一个域。 属性的顺序无关性，一个关系中的属性顺序可以任意交换，对关系没有影响。 所有属性值都必须取原子值。 关系模型有几种完整性约束？ 定义或作用分别是什么？ 实体完整性：主键取值唯一，且主键属性组不能部分或全部为空。 作用：唯一地标识所有的实体。 参照完整性：对外键的限定，取空值或对应主键相等的值。 作用：不允许引用不存在的实体。 用户定义完整性：用户根据实际需求，对属性或元组定义的规则或条件。 作用：根据实际数据给出合理的约束。 SQL的中英文全称是什么。 Structured Query Language SQL包含哪四方面的功能？ 其英文缩写分别是什么？ 数据查询(DQL)：select 数据定义(DDL)：create、drop、alter 数据操纵(DML)：insert、update、delete 数据控制(DCL)：grant、revoke","link":"/2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5/"},{"title":"歌单-林俊杰","text":"林俊杰（JJ Lin），1981年3月27日出生于新加坡，祖籍中国福建省厦门市同安区，华语流行乐男歌手、词曲创作人、音乐制作人、影视演员、潮牌主理人。2003年发行首张创作专辑《乐行者》。2004年凭专辑《第二天堂》中的歌曲《江南》获得广泛关注。 点击“林俊杰图片”或“阅读更多”获取歌单。","link":"/2020/02/01/%E6%AD%8C%E5%8D%952/"},{"title":"数据链路层","text":"要解决的三个基本问题： 封装成帧 透明传输 差错检测 点对点传输协议（PPP） 广播信道（CSMA/CD） 以太网(MAC) 数据链路层使用的信道 点对点信道 这种信道使用一对一的点对点通信方式。 广播信道 这种信道使用一对多的广播通信方式，因此过程比较复杂。 使用点对点信道发的数据链路层数据链路和帧 链路（link） 所谓链路就是从一个结点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换结点。 数据链路（data link） 除物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用网络适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 帧 为了向网络层提供服务，数据链路层必须使用物理层提供的服务。 物理层，是以比特流进行传输的，这种比特流并不保证在数据传输过程中没有错误，接收到的位数量可能少于、等于或者多余发送的位数量。而且它们还可能有不同的值，这时数据链路层为了能实现有效的差错控制，就采用了一种“帧”的数据块进行分段传输。 采用帧格式传输，就必须有相应的帧同步技术，这就是数据链路层的“成帧”（也称帧同步）功能。 三个基本问题 封装成帧（framing） 在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。 确定帧的界限： 首部和尾部的一个重要作用就是进行帧定界。当数据是由可打印的ASII码组成的文本文件时，帧定界可以使用特殊的帧定界符。 控制字符SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一控制字符EOT（End Of Transmission）放在一帧最后，表示一帧的结束。 此外，首部和尾部还包括许多必要的控制信息，各种数据链路层协议都对帧首部和尾部的格式有明确规定。 为了提高帧的传输效率，应使帧的数据部分长度尽可能地大于首部和尾部的长度，但每一种种数据链路层协议都规定了所能传输的帧的数据部分长度上限——最大传输单元MTU（Maximum Transfer Unit）。 透明传输 如果数据中的某个字节的二进制码恰好和SOH 或 EOT一样，数据链路层就会错误地“找到帧地边界”。 解决方法： 字节填充（byte stuffing）或字符填充（character stuffing）。发送端的数据链路层在数据中出现控制字符“SOH”或“EOT“的前面插入一个转义字符”ESC“（其十六进制编码是1B）。接收端的数据链路层将在数据送往网络层之前删除插入的转义字符。 差错检测 在传输过程中可能会产生比特差错：1可能会变成0而0也可能变成1。在一段时间内，传输错误的比特与传输比特总数的比率称为误码率BER（Bit Error Rate）。误码率与信噪比有很大的关系。为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 循环冗余检验CRC的检错技术。 帧检测序列FCS（Frame Check Sequence）：FCS在数据后面添加上的冗余码称为帧检验序列FCS。 需要注意的是： 循环冗余检验CRC和帧检测序列FCS并不等同。 CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码。 FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法。 CRC检验 若得出的余数R=0，则判断这个帧没有差错，就接受。 若判断余数R≠0，则判断这个帧有差错，就丢弃。 CRC检验原理及例子。 仅用循环冗余检验CRC差错检测技术只能做到无差错接受。 注意： “无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。 要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 应当明确，无比特差错与无传输差错是不同的概念。 在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。 本章介绍的数据链路层协议都不是可靠传输的协议。 点对点协议PPP(重点) 点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议PPP (Point-to-Point Protocol)。用户使用拨号电话线接入互联网时，用户计算机和ISP进行通信时所使用的数据链路层协议就是PPP协议。 PPP协议应满足的需求(特点)： 简单：这是首要的要求。 封装成帧：必须规定特殊的字符作为帧定界符。 透明性：必须保证数据传输的透明性。 多种网络层协议：能够在同一条物理链路上同时支持多种网络层协议。 多种类型链路：能够在多种类型的链路上运行。 差错检测：能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。 检测连接状态：能够及时自动检测出链路是否处于正常工作状态。 最大传送单元：必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。 网络层地址协商：必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。 数据压缩协商：必须提供一种方法来协商使用数据压缩算法。 PPP协议不需要的功能： 纠错、流量控制、序号、多点线路、半双工或单工链路（只支持全双工链路）。 PPP协议有三个组成部分： 一个将IP数据报封装到串行链路的方法。 链路控制协议LCP(Link Control Protocol)，用来建立、配置和测试数据链路的连接。 网络控制协议NCP(Network Control Protocol)，其中每一个协议支持不同的网络层协议。 PPP协议的帧格式： PPP帧的首部和尾部分别为4个字段和2个字段。 标志字段F=0x7E、地址字段A只置为OxFF、控制字段C通常置为0x03。地址字段和控制字段实际上并不起作用。 PPP是面向字节的，所有的PPP帧的长度都是整数字节。 PPP有一个2个字节的协议字段： 若为0x0021,则信息字段就是IP数据报。 若为0x8021,则信息字段是网络控制数据。 若为0XC021,则信息字段是PPP链路控制数据。 若为0XC023,则信息字段是鉴别数据。 透明传输问题： 当PPP用在同步传输链路时，协议规定采用硬件来完成比特填充(和HDLC的做法一样）。 当PPP用在异步传输时，就使用一种特殊的字符填充法。将信息字段中出现的每一个0x7E字节转变成为2字节序列（0x7D,0x5E）。 若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列（0x7D,0x5D）。 若信息字段中出现ASCII码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。 PPP协议之所以不使用序号、确认和重传机制是出于以下的考虑： 在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。 在因特网环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。 帧检验序列FCS字段可保证无差错接受。 非必须让数据链路层提供可靠传输（不加入帧编号、确认和重传机制）的原因： 现在通信线路的质量大大提高，由通信链路质量不好引起差错的概率已经大大降低。 因此，现在的互联网采用区别对待的方法： 通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求提供可靠传输。 通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，即向上提供可靠传输。 实践证明，这样可以提高通信效率。 使用广播信道的数据链路层 局域网的数据链路层： 局域网最主要的特点是： 网络为一个单位所拥有；地理范围和站点数目均有限。 局域网具有如下主要优点： 具有广播功能，从一个站点可很方便地访问全网。 局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。 局域网拓扑结构： 以太网的两个标准： DIX Ethernet V2是世界上第一个局域网产品(以太网)的规约。 IEEE 802.3是第一个IEEE的以太网标准。 数据链路层的两个子层： 逻辑链路控制LLC (Logical Link Control)子层。 媒体接入控制 MAC (Medium Access Control)子层。 与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关。 不管采用何种协议的局域网，对LLC子层来说都是透明的即LLC子层看不见下面的局域网。 实际上，由于互联网发展很快而TCP/IP体系的使用局域网只剩下DIX Ethernet V2，因此LLC的作用已经消失了，很多厂商的适配器上仅有MAC协议而没有LLC协议。 适配器： 网络接口板又称为通信适配器(adapter)或网络接口卡NIC (Network Interface Card),或“网卡”。 适配器的重要功能： 进行串行（电缆或双绞线）/并行（主板上的I/O总线）转换。 对数据进行缓存（网络上的数据率与计算机上的数据率不同）。 实现以太网协议。 CSMA/CD协议： 为了通信的简便，以太网（符合DIX Ethernet V2标准的局域网）采取了两种重要的措施： 采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。对发送的数据帧不进行编号，也不要求对方发回确认。这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。因此，以太网提供的服务是尽最大努力的交付，即不可靠交付。 以太网发送的数据都使用曼彻斯特，曼彻斯特编码缺点是：它所占的频带宽度（这里指频率上下界差）比原始的基带信号增加了一倍。 CSMA/CD含义： 载波监听多点接入/碰撞检测（Carrier SenseMultiple Access with Collision Detection）。 多点接入表示许多计算机以多点接入的方式连接在一根总线上。 载波监听是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。总线上并没有什么“载波”。因此，“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 碰撞检测就是计算机边发送数据边检测信道上的信号电压大小。在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 为什么要进行碰撞检测？ 由于电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A向B发出的信息，要经过一定的时间后才能传送到B。B若在A发送的信息到达B之前发送自己的帧（因为这时B的载波监听检测不到A所发送的信息），则必然要在某个时间和A发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。所以需要在发送期间进行碰撞检测，以检测冲突。 争用期： 电磁波在1km电缆的传播时延约为5μs（这个数字应当记住）。 最先发送数据帧的站，在发送数据帧后至多经过时间2$\\tau$（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。因此，以太网的端到端往返时延2$\\tau$称为争用期，或碰撞窗口。 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 二进制指数类型退避算法： 发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。基本退避时间取为争用期2$\\tau$。 争用期的长度： 以太网在发送数据时，若前64字节没有发生冲突，则后续的数据就 不会发生冲突。 CSMA/CD协议的要点： 准备发送。但在发送之前，必须先检测信道 检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。 检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。 CSMA/CD重要特性： 使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。 使用集线器的星形拓扑： 集线器（hub）： 采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器（hub）。 星形以太网10BASE-T使用无屏蔽双绞线，采用星形拓扑，通信距离稍短，每个站到集线器的距离不超过100m。 特点： 集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD协议，并共享逻辑上的总线。 集线器很像一个多接口的转发器 集线器工作在物理层，简单地转发比特，不进行碰撞检测（由各站中的适配器执行CSMA/CD协议）。 集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。 以太网的信道利用率： 多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到100%。 在以太网中定义了参数a，它是以太网单程端到端时延$\\tau$与帧的发送时间$T_0$之比： $a=\\frac{\\tau}{T_0}$ 当a $\\rightarrow$ 0, 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。 a越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。 也就是说，以太网的连线长度受到限制（否则$\\tau$会太大）,同时以太网的帧不能太短（否则$T_0$会太小）。 以太网的MAC层（重要）： MAC层的硬件地址：在局域网中，硬件地址又称为物理地址，或MAC地址。 48位的MAC地址： IEEE 802标准规定MAC地址字段可采用6字（48位）或2字节（16位）这两种中的一种。（现在实际都使用48位的） IEEE的注册管理机构RA负责向厂家分配地址字段6个字节中的前三个字节（即高位24位），称为组织唯一标识符OUI（公司标识符）。 址字段6个字节中的后三个字节（即低位24位）由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址。 适配器检查MAC地址： 适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。 “发往本站的帧”包括以下三种帧： 单播(unicast)帧(一对一) 广播(broadcast)帧(一对全体) 多播(multicast)帧(一对多) 所有的适配器都至少能够识别前两种帧，即能够识别单播地址和广播地址。有的适配器可用编程方法识别多播地址。 只有目的地址才能使用广播地址和多播地址。 以混杂方式(promiscuous mode)工作的以太网适配器只要“听到”有帧在以太网上传输就2都接收下来。 MAC帧的格式：常用的以太网MAC帧格式有两种标准： DIX Ethernet V2标准、IEEE的802.3标准，最常用的MAC帧是以太网V2的格式。 无效的MAC帧： 数据字段的长度与长度字段的值不一致（IEEE 802.3第三个字段：长度/类型）； 帧的长度不是整数个字节； 用收到的帧检验序列FCS查出有差错； 数据字段的长度不在46 ~ 1500字节之间。 有效的MAC帧长度为64〜1518字节之间。 对于检查出的无效MAC帧就简单地丢弃。以太网不负责重传丢弃的帧。 扩展的以太网 在物理层扩展以太网： 集线器扩展，增加碰撞域。 在数据链路层扩展以太网： 交换式集线器（以太网交换机、第二层交换机）： 以太网交换机实质上就是一个多接口的网桥（根据MAC帧的目的地址进行转发和过滤）。 特点： 通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。 以太网交换机具有并行性。能同时连通多对接口，使多对主机能同时通信。相互通信的主机都是独占传输媒体，无碰撞地传输数据。 以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。 以太网交换机是一种即插即用设备，其内部的帧交换表(又称为地址表)是通过自学习算法自动地逐渐建立起来的。 以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。 以太网交换机的优点： 用户独享带宽，增加了总容量。 从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。 以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。 以太网交换机的交换方式：存储转发方式、直通(cut-through)方式。","link":"/2020/12/07/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"歌单-周杰伦","text":"周杰伦（Jay Chou），1979年1月18日出生于台湾省新北市，祖籍福建省泉州市永春县，中国台湾流行乐男歌手、音乐人、演员、导演、编剧等，毕业于淡江中学。2000年发行首张个人专辑《Jay》。2001年发行的专辑《范特西》奠定其融合中西方音乐的风格。2002年举行“The One”世界巡回演唱会。2003年成为美国《时代周刊》封面人物。 点击“周杰伦图片”或“阅读更多”获取歌单。 var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"稻香\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/dx.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"dx.lrc\"},{\"title\":\"一路向北\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/ylxb.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"ylxb.lrc\"},{\"title\":\"Mine Mine\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20MI%20NE%20%20MI%20NE%20.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - MI NE MI NE .lrc\"},{\"title\":\"枫\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20枫.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 枫.lrc\"},{\"title\":\"你听得到\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20你%20听%20得到.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 你 听 得到.lrc\"},{\"title\":\"七里香\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20七里香.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 七里香.lrc\"},{\"title\":\"青花瓷\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20青花%20瓷.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 青花 瓷.lrc\"},{\"title\":\"晴天\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20晴%20天.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 晴 天.lrc\"},{\"title\":\"夜的第七章\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20夜%20的第%20七%20章.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 夜 的第 七 章.lrc\"},{\"title\":\"说好不哭\",\"author\":\"周杰伦&五月天阿信\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20说好不哭.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 说好不哭.lrc\"},{\"title\":\"我是如此相信\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20我是如此相信.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 我是如此相信.lrc\"},{\"title\":\"暗号\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20暗%20号.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 暗 号.lrc\"},{\"title\":\"园游会\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20园游会.mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 园游会.lrc\"},{\"title\":\"园游会 (Live)\",\"author\":\"周杰伦\",\"url\":\"/2020/01/19/歌单/周杰伦%20-%20园游会%20(Live).mp3\",\"pic\":\"/2020/01/19/歌单/jay.jpg\",\"lrc\":\"周杰伦 - 园游会 (Live).lrc\"}]}; options.element = document.getElementById(\"aplayer-jIjyHxcF\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 周杰伦十大超神现场","link":"/2020/01/19/%E6%AD%8C%E5%8D%95/"},{"title":"歌单-陈奕迅","text":"陈奕迅（Eason Chan），1974年7月27日出生于中国香港，祖籍广东省东莞市，中国香港流行乐男歌手、演员，毕业于英国金斯顿大学。1995年因获得第14届新秀歌唱大赛冠军而正式出道。1996年发行个人首张专辑《陈奕迅》。 点击“陈奕迅图片”或“阅读更多”获取歌单。","link":"/2020/02/12/%E6%AD%8C%E5%8D%953/"},{"title":"歌单-赵海洋","text":"无论是白天还是夜晚，悦耳的旋律总能使你的心灵变得纯净；无论是晴天还是雨天，黑白键的交替总能组合出属于你的心情。 你可能不会弹钢琴，但钢琴懂你。 点击“图片”或“阅读更多”获取歌单。","link":"/2020/02/26/%E6%AD%8C%E5%8D%954/"},{"title":"正则表达式","text":"正则表达式 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 正则表达式中的一些基本符号进行的扼要总结： 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 匹配不在字符集中的任意单一字符 aeiou 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} 丨 分支 foo\\丨bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (? \\exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing andreading中的第一个ing (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.b和a.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 正则表达式30分钟入门教程：原文链接。","link":"/2020/02/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"秃头的汇编","text":"说明本篇博客记录的是博主在学习基于Intel 8086指令系统的汇编一些知识点。 什么是汇编语言 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。 在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 一些基础知识字节、字、bit、byte的关系12345678字 word字节 byte位 bit1字=2字节(1 word = 2 byte)1字节=8位(1 byte = 8bit)字长是指字的长度(所占的二进制位数) 80×86寄存器 8086 CPU中寄存器总共为14个，且均为16位。 即AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES共14个。 而这14个寄存器按照一定方式又分为了通用寄存器（8个），控制寄存器（2个）和段寄存器（4个）。 通用寄存器 AX，BX，CX，DX 称作为数据寄存器： AX (Accumulator)：累加寄存器，也称之为累加器 BX (Base)：基地址寄存器 CX (Count)：计数器寄存器 DX (Data)：数据寄存器 由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用。 AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器； BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器； CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器； DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器； SP 和 BP 又称作为指针寄存器： SP (Stack Pointer)：堆栈指针寄存器 BP (Base Pointer)：基指针寄存器 SI 和 DI 又称作为变址寄存器： SI (Source Index)：源变址寄存器 DI (Destination Index)：目的变址寄存器 控制寄存器 IP (Instruction Pointer)：指令指针寄存器 FLAG：标志寄存器 段寄存器 CS (Code Segment)：代码段寄存器 DS (Data Segment)：数据段寄存器 SS (Stack Segment)：堆栈段寄存器 ES (Extra Segment)：附加段寄存器 注意： 此图片还包含了80286的寄存器。 物理地址的产生 逻辑地址：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。 物理地址=段基址×16+偏移量 寻址方式 寻址：寻找操作数地址的过程 寻址方式与操作数位置有关 操作数位置 操作数名称 寻址方式名称 在指令中 立即数 立即寻址 在寄存器中 寄存器操作数 寄存器寻址 在储存器中 存储器操作数 存储器寻址 在I/O端口中 I/O操作数 I/O端口寻址 与数据有关的7种寻址方式 立即寻址 操作数在指令中，紧跟在操作码之后，这样的操作数成为立即数。 直接寻址 操作数的地址中的偏移量直接跟在操作码之后，默认情况下基址存放在DS中，这个时候不需要加前缀，如果是加了别的前缀，如ES，表示基址在ES中。 寄存器寻址 操作数在CPU的寄存器中，指令指定寄存器号，这种寻址速度快，它不需要访问存储器中的操作数，因为所有的操作数都在寄存器中 寄存器间接寻址 操作数在存储器中，操作数有效地址在SI，DI，BX，BP这四个寄存器之一中，在一般情况下，如果有效地址在SI，DI和BX中，则以DS段寄存器之内容为段值。如果有效地址在BP中，则以SS段寄存器之内容为段值。 寄存器相对寻址方式 基址相对寻址 1234对于BX寄存器来说,使用DS作为基址寄存器例如:MOV AX,COUNT[BX] 或 MOV AX, [COUNT+BX]------DS基址------ 1234对于BP寄存器来说,使用SS作为基址寄存器例如:MOV AX,COUNT[BP] 或 MOV AX, [COUNT+BP]------SS基址------ 变址相对寻址 123使用2个变址寄存器SI,DI.例如:MOV AX,COUNT[SI] 或 MOV AX,[COUNT+SI]MOV AX,COUNT[DI] 或 MOV AX,[COUNT+DI] 1234567物理地址=16×(DS)+(BX)+8或16位位移量 或(SI) 或(DI)注意：(SI)和(DI)替换的是(BX)物理地址=16×(SS)+(BP)+8或16位位移量 基址变址寻址 12345678910 (BP) (SI)即：EA= + EA即有效地址 (BX) (DI)例如：MOV, [BX][DI] 或 MOV, [BX+DI]物理地址=16×(DS)+(BX)+(DI)或物理地址=16×(SS)+(BP)+(DI) 相对基址变址寻址 12345678910 (BP) (SI) 8位位移量即：EA= + + (BX) (DI) 16位位移量例如：MOV, MASK[BX][DI] 或 MOV, MASK[BX+DI] 或 MOV, [BX+DI+MASK]物理地址=16×(DS)+(BX)+(DI)+位移量或物理地址=16×(SS)+(BP)+(DI)+位移量","link":"/2020/03/29/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"},{"title":"汇编算数指令","text":"简述 80×86的算数运算指令包括二进制运算和十进制运算指令。算数指令用来执行算数运算，它们中有双操作数指令，也有单操作数指令。 如前所述，双操作数指令的两个操作数中除源操作数为立即数的情况外，必须有一个操作数在寄存器中。单操作数指令不允许使用立即数方式。算数指令的寻址方式均遵循这一原则。 加减加法指令 ADD 加法 格式：ADD DST,SRC DST&lt;–DST+SRC ADC 带进位的加法 格式：ADC DST,SRC DST&lt;–DST+SRC+CF INC 加一 格式：INC OPR OPR&lt;–OPR+1 减法指令 SUB 减法 格式：SUB DST,SRC DST&lt;–DST-SRC SBB 带借位的减法 格式：SBB DST,SRC DST&lt;–DST-SRC-CF DEC 减一 格式：DEC OPR OPR&lt;–OPR-1 NEG 求补 格式：NEG OPR OPR&lt;-(-OPR) CMP 比较 格式：CMP OPR1, OPR2 OPR1-OPR2 类似SUB但不保存结果，只是根据结果设置标志位 CMP后往往跟着一条条件转移指令 乘法指令 MUL 无符号数乘法 格式：MUL SRC 字节操作：AX&lt;-AL*SRC 字操作：DX,AX&lt;-AX*SRC DX放高位字，AX放低位字 IMUL 带符号数乘法 格式：IMUL SRC 字节操作：AX&lt;-AL*SRC 字操作：DX,AX&lt;-AX*SRC DX放高位字，AX放低位字 除法指令 DIV 无符号数除法 格式：DIV SRC 字节操作：AL&lt;-AX/SRC的商 字节操作：AH&lt;-AX/SRC的余数 字操作：AX&lt;-(DX,AX)/SRC的商 字操作：DX&lt;-(DX,AX)/SRC的余数 IDIV 无符号数除法 格式：IDIV SRC 字节操作：AL&lt;-AX/SRC的商 字节操作：AH&lt;-AX/SRC的余数 字操作：AX&lt;-(DX,AX)/SRC的商 字操作：DX&lt;-(DX,AX)/SRC的余数 其他指令：指令手册。","link":"/2020/06/07/%E6%B1%87%E7%BC%96%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4/"},{"title":"爬虫初步","text":"爬虫简介 网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 爬虫的基本原理 网页请求的过程分为两个环节： Request （请求）：每一个展示在用户面前的网页都必须经过这一步，也就是向服务器发送访问请求。 Response（响应）：服务器在接收到用户的请求后，会验证请求的有效性，然后向用户（客户端）发送响应的内容，客户端接收服务器响应的内容，将内容展示出来。 网页请求的方式也分为两种： GET：最常见的方式，一般用于获取或者查询资源信息，也是大多数网站使用的方式，响应速度快。 POST：相比 GET 方式，多了以表单形式上传参数的功能，因此除查询信息外，还可以修改信息。 下面是我用GET方法爬取的某小说网站的小说的源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 引入库import requestsimport re #正则表达式# 写网站站点url = &quot;http://www.ddxsku.com/files/article/html/55/55756/index.html&quot;# 写入headers模拟浏览器上网,避免出现网站拒绝访问的情况headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0&quot;,}# get发送请求response = requests.get(url,headers=headers)# 将网页编码方式转换为utf-8response.encoding = 'utf-8'# 网站源码html = response.text# print(html)table = re.findall(r'&lt;table cellspacing=&quot;1&quot; cellpadding=&quot;0&quot; bgcolor=&quot;#E4E4E4&quot; id=&quot;at&quot;&gt;.*?&lt;/table&gt;',html,re.S)[0]# print(table)# 小说名字title = re.findall(r'&lt;h1&gt;(.*?)&lt;/h1&gt;',html)[0]# print(title)# 获取章节信息chapter_info_list = re.findall(r'href=&quot;(.*?)&quot;&gt;(.*?)&lt;',table)# print(chapter_info_list)# 创建文本文档（存小说内容）f = open('%s未格式化完全版本.txt' % title, 'w', encoding='utf-8')# 循环访问章节链接for chapter_info in chapter_info_list: # print(chapter_info) # chapter_title = chapter_info[1] # chapter_url = chapter_info[0] chapter_url, chapter_title = chapter_info # print(chapter_url, chapter_title) chapter_response = requests.get(chapter_url) chapter_response.encoding='utf-8' chapter_html = chapter_response.text chapter_content = re.findall(r'&lt;dd id=&quot;contents&quot;&gt;(.*?)&lt;/dd&gt;',chapter_html,re.S)[0] # 清洗数据 chapter_content = chapter_content.replace('&lt;br /&gt;','') chapter_content = chapter_content.replace(' ','') chapter_content = chapter_content.replace('&amp;nbsp;','') # print(chapter_content) # 写入文本(持久化) f.write(chapter_title) f.write(chapter_content) print(chapter_title)f.close()with open('%s.txt' % title, 'w', encoding='utf-8') as fn,open('%s未格式换完全版本.txt' % title, 'r', encoding='utf-8') as fo: for line in fo.readlines(): if line.split(): fn.write(line) fn.write('\\n')fo.close()fn.close() 值得注意的是，此代码并没有添加防止由于访问量（批量下载）过大而导致IP可能被封的方法代码。 这个问题的解决方案有两个： 增设延时（但影响效率）： 12import timetime.sleep(2) requests模块的proxies属性方法: 12345proxies={ &quot;http&quot;:&quot;http://10.10.1.10:3128&quot;, &quot;https&quot;:&quot;http://10.10.1.10:1080&quot;,}response = requests.get(url, proxies=proxies) 构建自己的代理IP池，将其以字典的形式赋值给proxies，传输给requests Beautiful Soup 模块的简单应用 Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 由于各个网站的网页代码结构不经相同，这次爬取中遇到了多个&lt;div&gt;标签嵌套的问题，如果用简单的正则表达式可能出现找不准对应末尾&lt;/div&gt;的问题（其他标签类型类似），于是我引入了Beautiful Soup模块。 12345678from bs4 import BeautifulSoupurl='http://www.mingchaonaxieshier.com/'response = requests.get(url)response.encoding = 'utf-8'html = response.textsoup = BeautifulSoup(html,'html.parser')divs = soup.findAll(name='div',attrs = {'class':'main'}) 经过以上代码的处理，&lt;div&gt;标签能够被准确地定位，并将其中地内容保存在变量divs中。 w3lib库html模块的简单应用 w3lib主要包括四个模块： html模块：处理与html标签相关的问题 http模块：处理与http报文相关的问题 url模块：处理与url地址相关的问题 encoding模块：处理与编码格式相关的问题 w3lib库中的html模块主要用于处理与html标签相关的问题。 此次我使用html模块解决了，爬出的html文档任然带有JavaScript标签的问题。 123from w3lib.html import remove_tags_with_contentchapter_content = remove_tags_with_content(chapter_content,which_ones=('script','ins'),encoding='utf-8') 使用以上代码删除&lt;script&gt;和&lt;ins&gt;标签及其内容。 当然html模块中肯定不止有remove_tags_with_content()函数。 通常用到的还有： 123html.remove_tags()html.remove_comments()html.remove_entities() 具体用法和更多html模块的函数可以参考官方文档或者这位CSDN博主的博客。 Python 爬虫中@retry装饰器的使用 在爬虫代码的编写中，requests请求网页的时候常常请求失败或错误，一般的操作是各种判断状态和超时，需要多次重试请求，可以用@retry装饰器来实现。 123456789from retrying import retry# 两次retry之间等待3秒，重试100次@retry(stop_max_attempt_number=100, wait_fixed=3000)def get_chapter_url(chapter_url): chapter_response = requests.get(chapter_url, headers=headers, timeout=1) chapter_response.encoding='utf-8' return chapter_response 更多详细用法参照：CSDN博主的博客。 最近写的小爬虫 前程无忧招聘信息爬取（岗位、公司、薪酬） 123456789101112131415161718192021222324252627282930313233343536373839import reimport requestskey = &quot;python&quot;headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0&quot;,}page_num = '1'response = requests.get(&quot;https://search.51job.com/list/090200,000000,0000,00,9,99,&quot;+key+&quot;,2,1.html&quot;, headers=headers)# 先根据源网页编码（response.encoding）转换为二进制编码（bytes）# 再用decode转换为gbk编码解决乱码问题data = bytes(response.text, response.encoding).decode(&quot;gbk&quot;, &quot;ignore&quot;)pat_page = &quot;共(.*?)条职位&quot;# print(data)allline = re.compile(pat_page, re.S).findall(data)[0]allpage = int(allline)//50+1for i in range(allpage): print(&quot;---正在爬&quot;+str(i+1)+&quot;页---&quot;) page_num = str(i+1) response = requests.get(&quot;https://search.51job.com/list/090200,000000,0000,00,9,99,&quot;+key+&quot;,2,&quot;+page_num+&quot;.html&quot;, headers=headers) data_page = bytes(response.text, response.encoding).decode(&quot;gbk&quot;, &quot;ignore&quot;) # print(data_page) job_url_pat = '&lt;em class=&quot;check&quot; name=&quot;delivery_em&quot; onclick=&quot;checkboxClick.this.&quot;&gt;&lt;/em&gt;.*?href=&quot;https://jobs.51job.com/(.*?).html.*?&quot;' job_url_all = re.compile(job_url_pat, re.S).findall(data_page) # print(job_url_all) for job_url in job_url_all: # print(job_url) thisurl = &quot;https://jobs.51job.com/&quot;+job_url+&quot;.html&quot; response = requests.get(thisurl) data_job = bytes(response.text, response.encoding).decode(&quot;gbk&quot;, &quot;ignore&quot;) # print(data_job) pat_title = '&lt;h1 title=&quot;(.*?)&quot;' pat_company = '&lt;p class=&quot;cname&quot;&gt;.*?title=&quot;(.*?)&quot;' pat_money = '&lt;div class=&quot;cn&quot;&gt;.*?&lt;strong&gt;(.*?)&lt;/strong&gt;' title = re.compile(pat_title, re.S).findall(data_job)[0] company= re.compile(pat_company, re.S).findall(data_job)[0] money = re.compile(pat_money, re.S).findall(data_job)[0] print('------------------') print(title) print(company) print(money)","link":"/2020/02/20/%E7%88%AC%E8%99%AB%E5%88%9D%E6%AD%A5/"},{"title":"物理层","text":"物理层的基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。 用于物理层的协议也常称为物理层规程。 物理层的主要任务 机械特性 ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性 ：指明对于不同功能的各种可能事件的出现顺序。 数据通信系统的模型 一个数据通信系统包括三大部分：源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。 常用术语 数据 (data) —— 运送消息的实体。 信号 (signal) —— 数据的电气的或电磁的表现。 模拟信号 (analogous signal) —— 代表消息的参数的取值是连续的。 数字信号 (digital signal) —— 代表消息的参数的取值是离散的。 码元 (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。 有关信道的几个基本概念 信道 —— 一般用来表示向某一个方向传送信息的媒体。 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 基带信号（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制 (modulation)。 两大类调制： 基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。 带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。 带通信号 ：经过载波调制后的信号。 常用编码方式： 不归零制：正电平代表 1，负电平代表 0。 归零制：正脉冲代表 1，负脉冲代表 0。 曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。 差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。 从信号波形中可以看出，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。 从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力），而曼彻斯特编码和差分曼彻斯特编码具有自同步能力。 基本的带通调制方法 调幅(AM)：载波的振幅随基带数字信号而变化。 调频(FM)：载波的频率随基带数字信号而变化。 调相(PM) ：载波的初始相位随基带数字信号而变化 信道的极限容量 码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 限制码元在信道上的传输速率的因素有以下两个： 信道能够通过的频率范围 具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰（码元之间的界限模糊不清）的问题，使接收端对码元的判决（即识别）成为不可能。 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。 信噪比 信噪比就是信号的平均功率和噪声的平均功率之比。 常记为 S/N，并用分贝 (dB) 作为度量单位。即：$信噪比(dB) = 10log_{10}(S/N) (dB)$ 香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）。 信道的极限信息传输速率 C 可表达为：$W\\log(1+S/N) (bit/s)$ 其中： W 为信道的带宽（以 Hz 为单位）； S 为信道内所传信号的平均功率； N 为信道内部的高斯噪声功率。 香农公式表明： 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 注意： 对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。 这就是：用编码的方法让每一个码元携带更多比特的信息量。 物理层下面的传输媒体 传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。 在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。 非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。 引导型传输媒体：双绞线（屏蔽双绞线 STP 、无屏蔽双绞线 UTP ）、同轴电缆（50Ω同轴电缆，70Ω同轴电缆）、光缆（多模光纤，单模光纤）。 光纤优点：通信容量非常大、传输损耗小、中继距离长、抗雷电和电磁干扰性能好、无串音干扰，保密性好、体积小，重量轻。 非导引型传输媒体： 短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。 微波在空间主要是直线传播。 传统微波通信有两种方式： 地面微波接力通信 卫星通信 信道复用技术 复用 (multiplexing) 是通信技术中的基本概念。它允许用户使用一个共享信道进行通信，降低成本，提高利用率。 频分复用 FDM： 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用TDM 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。 TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户是在不同的时间占用同样的频带宽度。 统计时分复用 STDM STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。 波分复用 WDM 波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。 码分复用 CDM 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。 在实用的系统中是使用伪随机码序列。 宽带接入技术 用户要连接到互联网，必须先连接到某个 ISP，美国联邦通信委员会 FCC 认为只要双向速率之和超过 200 kbit/s 就是宽带。 从宽带接入的媒体来看，可以划分为两大类：有线宽带接入、无线宽带接入。 ADSL 技术：非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。标准模拟电话信号的频带被限制在 300~3400 Hz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。 ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 ADSL 的传输距离 ADSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。 ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。 FTTx 技术：FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。（光纤到户 FTTH (Fiber To The Home)、光纤到大楼 FTTB (Fiber To The Building)、光纤到路边 FTTC (Fiber To The Curb)）。","link":"/2020/12/31/%E7%89%A9%E7%90%86%E5%B1%82/"},{"title":"我的图库","text":"用指尖记录生活神木垒 我慢慢的听，雪落下的声音。 记录 请走慢一点，等一等你的灵魂。 恬静 在春夏秋冬的里寻找属于你的恬静。 昆明 浅蓝色的天空，浅蓝色的滇池水。 重庆 热闹、喧嚣，绚烂的灯火。 峨眉 已识乾坤大，尤怜草木青。","link":"/2022/01/03/%E7%9B%B8%E5%86%8C/"},{"title":"算法基础概念","text":"递归 直接或间接地调用自身的算法称为递归算法，用函数自身给出定义的函数称为递归函数。 每个递归函数都要有非递归定义的初始值，如阶乘函数，斐波那契，汉诺塔。 分治策略 基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题相互独立且与原问题相同。递归地解这些子问题，然后将各个子问题的解合并得到原问题的解。 例如：二分查找、大整数乘法、strassen矩阵乘法、归并排序、快速排序、棋盘覆盖 动态规划（自底向上） 和分治法类似，都是将待求问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 动态规划从最小的问题开始，逐层向上求解，通过子问题之间的依赖关系，有效利用前面已经得到的结果，最大限度减少重复工作，以提高算法效率。 要素 最优子结构性质（优化原则） 当问题的最优解包含了其子问题的最优解时，则称该问题具有最优子结构性质。这个性质是动态规划算法求解的重要线索。 子问题重叠性质 在运用递归算法自顶向下解题时，每次产生的子问题并不总是新问题，动态规划将计算过的子问题保存在一个表格中，当再次使用时直接搜索到它拿过来用就行了。 例如：大矩阵乘法、最长公共子序列、流水作业调度、0-1背包 贪心法 贪心算法并不从整体的最优解考虑，而是做出当前的局部最优的选择。 要素 最优子结构（组合优化） 贪心选择性质 贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择(即贪心选择)来达到。 例如：活动安排问题、哈夫曼编码($O(nlogn)$) 动态规划算法与贪心算法的异同: 共同点： 都需要最优子结构性质。 都用来求有优化问题。 不同点： 动态规划： 每一步作一个选择——依赖于子问题的解。 贪心方法： 每一步作一个选择——不依赖于子问题的解。 动态规划方法的条件：最优子结构性质；子问题的重叠性质。 可用贪心方法的条件：最优子结构性质；贪心选择性质。 动态规划：自底向上求解（动态规划方法是自底向上计算各个子问 题的最优解，即先计算子问题的最优解，然后再利用子问题的最优解构造大问题的最优解，因此需要最优子结构） 贪心法：自顶向下求解。 可用贪心法时，动态规划方法可能不适用； 可用动态规划方法时，贪心法可能不适用。 回溯法 为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。 具有限界函数的深度优先生成法称为回溯法。 两种解空间树： 子集树 当我们求解的结果是集合的某一子集的时候，其对应的解空间是子集树。 例如：八皇后问题、0-1背包问题 排列树 当我们求解的结果是集合元素的某一种排列的时候，其对应的解空间就是排列树。 例如：货郎问题（$O(n!)$） 分支限界法（回溯法的改进） 队列式(FIFO)分支限界法—将活结点表组织成一个队列，按照先进先出(FIFO)原则选取下一个结点为扩展结点; 优先队列式分支限界法—将活结点表组织 成一个优先队列，按照规定的优先级选取优先级最高的结点成为当前扩展结点。","link":"/2020/12/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"title":"组成与系统结构-复习","text":"名词解释 对阶 浮点数加/减运算时，在尾数相加/减之前所进行的操作称为对阶。 对阶时，需要比较两个阶的大小。阶小的那个数的尾数右移（小数点左移），阶码增加。右移一次，阶码加1，直到两数的阶码相等为止。 真值 机器数真正的值(即原来带有正负号的数)称为机器数的真值。 机器数 通常将数值数据在计算机内部编码表示的数称为机器数。 机器字长 一个二进制位(bit,比特)是计算机内部信息表示的最小单位。 而机器字长指的是特定计算机中CPU用于定点整数运算的数据通路的宽度，通常也就是CPU内定点数运算器和通用寄存器的位数。 数据通路 数据通路是指，指令在执行过程中数据所经过的部件以及部件之间的连接线路，主要由 ALU 和一组寄存器、存储器、总线等组成。 国内许多教科书中提到的运算器即是运算数据通路。 立即寻址 指令中的地址码直接给出操作数本身。 直接寻址 指令中的地址码给出的是操作数所在的存储单元地址，称为直接地址。 间接寻址 指令中的地址码给出的是操作数所在的存储单元地址所在的存储单元地址，称为间接地址。 寄存器寻址 指令中的地址码给出的是操作数所在的寄存器的编号。 寄存器间接寻址 指令中的地址码给出的是操作数所在的存储单元的地址所在的寄存器的编号。 相对寻址 相对寻址方式下，指令中的形式地址给出一个位移量D，而基准地址由程序计数器PC提供。即有效地址$EA=(PC)+D$。 基址寻址 基址寻址方式下，指令中的地址码给出一个形式地址，作为位移量，并且隐含或明显地指定一个寄存器作为基址寄存器，基址寄存器的内容和形式地址相加，得到操作数的有效地址，根据有效地址到存储器中访问，去取操作数或写运算结果。 变址寻址 变址寻址方式下，指令中的地址码给出一个形式地址，并且隐含或明显地指定一个寄存器作为变址寄存器，变址寄存器的内容（变址值）和形式地址相加，得到操作数的有效地址，根据有效地址到存储器中访问，去取操作数或写运算结果。 中断向量 每个中断源都有对应的处理程序，我们称这个处理程序为中断服务程序，其入口地址称为中断向量。 向量中断 是指一种识别中断源的技术或方式。识别中断源的目的就是要找到中断源对应的中断服务程序的入口地址，即获得向量地址。 中断向量表 所有中断（包括异常）的中断服务程序入口地址构成一个表，称为中断向量表。 也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。 向量地址 中断向量表或中断向量跳转表中每个表项所在的内存地址称为向量地址。 结构冒险 在指令流水线中，同一个部件同时被不同指令所使用的现象称为结构冒险，也称为资源冲突。 数据冒险 在指令流水线中，后面指令用到前面指令的结果时，前面指令的结果还未产生的现象称为数据冒险，也称为数据相关。 控制冒险 在指令流水线中，转移指令或异常等情况改变了程序执行的流程，而使得在目标地址产生前已被取到流水线中的指令无效的现象称为控制冒险，也称分支冒险。 存储保护 虚拟存储器可以实现多道程序运行，也就是说，在一个主存物理空间中同时有多个进程共存。 为避免主存中多道程序的相互干扰，防止某进程出错而破坏其他进程的正确性，或某进程不合法地访问其他进程的存储器，应对每个进程进行存储保护。 缺页 需要访问的页不在内存中时，则发生“缺页异常”。通过检查“有效位”就可以判断是否“缺页”。 页表 每个进程有一个页表，记录该进程的每个页存放在主存的哪个页框中，或在辅存的哪个地方。 页表中一般有装入位（有效位）、修改位、使用位、实页号等。 DMA 方式 DMA 是Direct Memory Access(直接存储器存取)的缩写。 每次需要进行外设数据读写时，首先 CPU 把要传送的数据个数、数据块在内存的首址、数据传送的方向（是读还是写操作）、设备的地址等参数送给 DMA 控制器，然后发送一个命令给 DMA 接口，启动外设进行数据准备工作。在这些工作完成后，CPU 就继续进行其他工作。 此时，外设和 CPU 并行工作，而 I/O 设备和主存交换数据的事情就交给了 DMA 控制器。 简答题 为什么计算机内部采用二进制表示信息？既然计算机内部所有信息都用二进制表示，为什么还用到十六进制或八进制数？ 使用二进制原因： 二进制系统只有两个基本符号：0 和 1。所以它的基本符号少，易于稳态电路的实现。 二进制的编码、记数、运算等规则简单。 二进制中的 0 和 1 与逻辑命题的“真”和“假”的对应关系简单，为计算机中实现逻辑运算和程序中的逻辑判断提供了便利的条件，特别是能通过逻辑门电路方便地实现算术运算。 计算机内部在进行信息的存储、传送和运算时，都是以二进制形式来表示信息的。但在屏幕上或书本上书写信息时，由于二进制信息位数多，阅读、记忆不方便，而十六进制、八进制和二进制的对应关系简单，又便于阅读、记忆和书写，所以引入十六进制或八进制，使得人们在开发、调试程序和阅读机器内部代码时，能方便地用八进制或十六进制来等价表示二进制信息。 常用的定点数编码方式有哪几种？通常它们各自用来表示什么？ 定点数是计算机中小数点固定在最左边或最右边的数，有定点整数和定点小数两种。 定点数的编码方式有原码、反码、补码和移码。浮点数的尾数一般用原码小数来表示；浮点数的阶码一般用移码来表示；常用补码表示带符号整数；而反码很少被使用，只用在某些特殊场合。 在浮点数的基数和总位数一定的情况下，浮点数的表示范围和精度分别由什么决定？两者如何互制约？ 浮点数的精度取决于尾数的位数，数值范围取决于阶码的位数。在浮点数总位数不变的情况下，阶码位数越多，则尾数位数越少，即表示范围越大，则精度越差（数变稀疏）。 一条指令中应该显式或隐式地给出寻址信息是什么？ 操作码：指定操作类型，如移位、加减乘除、传送等。 源操作数或其地址：指出一个或多个源操作数或其地址，可以是主(虚)存地址、寄存器编号、或 I/O 端口，也可以在指令中直接给出一个立即数。 结果的地址：结果所存放的地址，可以是主(虚)存地址、寄存器编号、或 I/O 端口。 下一条指令地址：下一条指令存放的地址，可以是主(虚)存地址。 哪些寻址方式下的操作数在寄存器中？哪些寻址方式下的操作数在存储器中？ 操作数在寄存器中：寄存器寻址。 操作数在存储器中：直接寻址、间接寻址、寄存器间接寻址、偏移寻址（变址寻址、基址寻址、相对寻址）。 基址寻址方式和变址寻址方式的作用各是什么？有何相同点和不同点？ 相同点：变址寻址方式和基址寻址方式的有效地址形成过程类似。 不同点（两个方面）： 具体应用的场合不同： 变址寻址面向用户，可用于访问字符串、数组、表格等成批数据或其中的某些元素（变址寻址作用）。 基址寻址面向系统，用于解决程序的重定位问题和短地址访问大空间的问题（基址寻址作用）。 使用方式不同： 变址寻址时，指令中提供的形式地址是一个基准地址，位移量由变址寄存器给出。 而基址寻址时，指令中给出的形式地址为位移量，而基址寄存器中存放的是基准地址。 RISC(精简指令集计算机) 处理器的特点有哪些？ 指令数目少：只包含使用频度高的简单指令。 指令格式规整：寻址方式少，指令格式少，指令长度一致。 采用$Load/Store$型指令设计风格：只有 Load 和 Store 指令才能访存。 采用流水线方式执行指令：规整的指令格式有利于采用流水线方式执行，除$Load/Store$指令外，其他指令都只需一个或小于一个时钟周期就可完成，指令周期短。 采用大量通用寄存器：编译器可将变量分配到寄存器中，以减少访存次数。 采用硬连线控制器：指令少而规整使得控制器的实现变得简单，可以不用或少用微程序控制。 采用优化的编译系统：指令数少有利于编译器的优化。 CPU 中标志寄存器的功能是什么？有哪几种基本标志？ 标志寄存器又称程序状态字。用于存放条件标志、控制标志，反映处理器的状态和ALU运算结果的某些特征及控制指令的执行。 6个状态标志： CF(Carry Flag)——进位标志位。 PF(Parity Flag)——奇偶标志位。该标志位反映运算结果中1的个数是偶数还是奇数。 AF(Auxiliary carry Flag)——辅助进位标志位。当执行一个加法(或减法)运算，使结果的低4位向高4位有进位(或借位)时，AF=1；否则AF=0。 ZF(Zero Flag)——零标志位。 SF(Sign Flag)——符号标志位。 OF(Overflow Flag)——溢出标志位。 3个控制标志位用来控制CPU的操作，由指令进行置位和复位。 DF(Direction Flag)——方向标志位。它用以指定字符串处理时的方向。 IF(Interrupt enable Flag)——中断允许标志位。它用来控制8086是否允许接收外部中断请求。 TF(Trap Flag)——跟踪标志位。它是为调试程序而设定的陷阱控制位。当该位置“1”时，8086 CPU处于单步状态，此时CPU每执行完一条指令就自动产生一次内部中断。当该位复位后，CPU恢复正常工作。 CPU 的基本组成和基本功能各是什么？ CPU 主要由数据通路和控制单元(部件)组成。 数据通路中包含组合逻辑单元和存储信息的状态单元。组合逻辑单元用于对数据进行处理，如加法器、ALU、扩展器(0扩展或符号扩展)、多路选择器以及总线接口逻辑等；状态单元包括触发器、寄存器等，用于对指令执行的中间状态或最终结果进行保存。 控制单元也称为控制器，主要功能是对取出的指令进行译码，并与指令执行得到的条件码或当前机器的状态、时序信号等组合，生成对数据通路进行控制的控制信号。 CPU总是周而复始地执行指令，并在执行指令过程中检测和处理内部异常事件和外部中断请求。在此过程中，要求CPU具有以下各种功能： 取指令并译码：从存储器取出指令，并对指令操作码译码，以控制CPU进行相应的操作。 计算PC的值：通过自动计算PC的值来确定下一条指令地址，以正确控制执行顺序。 算数逻辑运算：计算操作数地址，或对操作数进行算术或逻辑运算。 取操作数或写结果：通过控制对存储器或I/O接口的访问来读取操作数或写结果。 异常或中断处理：检测有无异常事件或中断请求，必要时响应并调出相应处理程序执行。 时序控制：通过生成时钟信号来控制上述每个操作的先后顺序和操作时间。 取指令部件的功能是什么？ 取指令并计算下条指令地址。 下地址逻辑中，要区分是顺序执行还是转移执行。顺序执行，PC=PC+取出的指令长度；转移执行要根据当前指令是分支还是跳转指令来计算目标地址。 控制器的功能是什么？ 对指令进行译码，将译码结果和状态/标志信号和时序信号进行组合，产生各种操作信号，即产生各条指令所需的控制信号。 有两大类控制信号：CPU 内部控制信号和发送到系统总线上的控制信号。 硬连线控制器和微程序控制器的特点各是什么？ 硬连线路控制器的优点是速度快，适合于实现简单或规整的指令系统。但是，它是一个多输入/多输出的巨大逻辑网络。对于复杂的指令系统来说，其结构庞杂，实现困难，修改、维护不易，灵活性差。 微程序控制器的特点是具有规整性、可维护性和灵活性，但速度慢。 为了结合两种方式的优点，很多出理解采用两者结合的方式来实现。 为什么 CISC 大多用微程序控制器实现，RISC 大多用硬连线控制器实现？ CISC 的指令功能复杂，寻址方式多，指令长度可变，指令格式多样。对应的硬连线控制器结构庞杂，实现困难，修改、维护不易，灵活性差。所以适合采用微程序方式来设计控制器。 RISC 的指令集中只包含程序常用的指令，具有指令数目少、指令格式规整、采用(Load/Store)型指令风格等特点。所以适合采用硬连线方式来设计控制器。 流水线方式下，一条指令的执行时间缩短还是加长了？程序执行时间是缩短了还加长了？ 流水线方式会延长一条指令的执行时间，但不会缩短。原因是在一条确定的流水线的流水段个数中，是以最复杂的指令执行过程所需的流水段个数为标准设计的；在确定每个流水段宽度时也是以最复杂流水段所需的宽度来设计。此外每个流水段之间的信息缓存和传递等也会增加额外开销。 流水线方式可以缩短程序的执行时间，即大大增加指令执行的吞吐率。 具有什么特征的指令集易于实现指令流水线？ 指令长度应尽量一致（定长指令字和定长操作码）使得每条指令的预取及译码操作时间完全一致，便于流水线控制。 指令格式尽量规整，尽量保证源寄存器的位置相同，便于规划取操作数步骤，并使得对指令进行译码的同时，可以读取寄存器操作数。 采用装入/存储(Load/Store)型指令风格，便于利用执行运算步骤来进行地址计算，即将地址计算和运算指令的执行步骤规整在同一个周期。 流水线处理器中时钟周期如何确定？单条流水线处理器的 CPI 为多少？每个时钟周期一定有一条指令完成吗？为什么？ 流水线的流水段个数以最复杂的指令执行过程所需的流水段个数为标准设计的；在确定每个流水段宽度时也是以最复杂流水段所需的宽度来设计。 不能。理想情况下，经过若干周期后，能在每个时钟周期内执行完一条指令，即 CPI=1 但是，当程序中出现以下情况时，流水线被破坏，因而，不能达到CPI=1。 原因：有多条指令的不同阶段都要用到同一个功能部件时，发生资源冲突（结构冒险），后面指令要延时执行；当程序的执行流程发生改变时，发生控制相关（控制冒险），原来按顺序取出的指令无效；当后面指令的操作数是前面指令的运行结果时，发生数据相关（数据冒险），后面指令要延时执行。此外，还有cache缺失、TLB缺失、异常和中断等的发生都会阻塞流水线的执行。 为什么要在各流水段之间加寄存器？各流水段寄存器的宽度是否都一样？为什么？ 每两个相邻流水段之间需要设置一个流水段寄存器，用来存放前一个流水段中产生的并需要传输到其后所有流水段的信息，包括各种数据（PC、指令、立即数、运算结果、寄存器号等）和控制信号两大类信息。 每个流水段功能不同，所需传递到信息也不同，因此各流水段寄存器长度也不同。 计算机内部为何要采用层次化存储体系结构？层次化存储体系结构如何构成？ 原因：每一种单独的存储器都不是又快、又大、又便宜，为了构建这种理想的存储系统，计算机采用了一种层次化的存储体系结构。 按照速度从快到慢、容量从小到大、价格从高到低的顺序，由近到远地将不同存储器设置在离 CPU 远近不同地地方，这样的顺序是寄存器-&gt;cache-&gt;主存-&gt;SSD或磁盘-&gt;光盘和磁带。 SRAM 芯片和 DRAM 芯片各有哪些特点？各自用在哪些场合？ 静态随机访问存储器(Static RAM,SRAM)：靠触发器的双稳态的正负反馈电路存储信息，因而速度快，是非破坏性读出，但电路中元器件多，因而集成度小、价格贵、功耗大。适合做高速小容量的半导体存储器，如高速缓冲存储器(cache)。 动态随机访问存储器(Dynamic RAM,DRAM)：靠电容存储电荷来保存信息。集成度高、功耗小、价格相对较低，是破坏性读出，读出后需要再生，而且需要定时刷新。适合做慢速大容量的半导体存储器，如主存。 为什么在 CPU 和主存之间引入 cache 能提高 CPU 访存效率？ 原因：程序执行代码和数据的存储访问具有局部性特点，包括时间局部性和空间局部性。 时间局部性指某个单元在一个很短的时间段内被重复访问的可能性很大；空间局部性指某个单元被访问后其周围单元不久也将被访问的可能性很大。 只要将刚被访问的单元及其邻近单元一起复制到cache中，那么，在最近一段时间内CPU访问的信息都可以在cache中访问到，而不需要访问慢速的主存。 什么是页表？什么是快表(TLB)？ 页表：每个进程有一个页表，记录该进程的每个页存放在主存的哪个页框中，或在辅存的哪个地方。页表中一般有装入位（有效位）、修改位、使用位、实页号等。 快表：用一个特殊的 cache 来跟踪记录最近用过的页表表项。因为页表表项主要用于地址转换，所以把这种特殊的 cache 称为转换后援缓冲器(Translation-Lookaside Buffer,TLB)。因为在TLB中查找页表表项速度很快，所以TLB也被称为快表。 什么是 I/O 接口？I/O 接口的基本功能有哪些？按数据传送方式分有哪两种接口类型？ I/O 接口是用于连接主机和外设并通过接受主机命令来对外设进行控制的部件的总称。 功能： 数据缓冲：匹配主机和外设工作速度； 错误或状态检测：是否完成、是否出错； 控制和定时：协调内部资源和外设间动作的先后关系； 数据格式转换：串/并行转换，数据宽度转换等。 按数据传送方式分有：并行接口、串行接口。 CPU 如何进行设备的寻址？I/O 端口的编址方式有哪两种？各有何特点？ CPU 通过地址总线进行设备寻址。 I/O 端口一般有两种编址方式：独立编址和统一编址。 独立编址：将 I/O 端口和主存单元分别编号，不占用主存单元的地址空间，因而主存单元和 I/O 端口可能会有相同的编号，但地址位数大多不同，主存单元多，地址空间大，因而地址位数多；I/O 端口少，地址空间小，因而地址位数少。因为可能有相同的编号，指令中无法靠地址来区分要访问的是主存单元还是 I/O 端口，所以，需要有和访存指令不同的操作码，因此， 需要设计专门的I/O指令。 统一编址：I/O 端口和主存单元统一编址，所以也称为存储器映射I/O (memory-mapped I/O)方式。一个地址空间分成了两部分，各在不同的地址段中，但地址的位数是相同的，可根据地址范围的不同来区分访问的是主存单元还是 I/O 端口，所以无需专门的输入输出指令。 什么是程序查询 I/O 方式？说明其工作原理。 CPU 通过执行查询程序来完成对外设的控制，实现和外设的数据传送。 在查询程序中，CPU首先通过读取状态端口中的状态信息，了解接口是否已“就绪”(或“完成”)，若是，就通过数据端口进行新的数据传送，并查询外设是否空闲，在外设空闲的情况下，通过发送控制信息到命令端口，然后由接口发“启动”命令送外设；如果接口没有就绪，或外设不空闲，则CPU继续查询，以等待接口就绪或外设空闲。 所有信息(包括控制、数据、状态)的交换由查询程序中的I/O指令完成。 什么是中断 I/O 方式？说明其工作原理。 程序中断I/O方式下，CPU启动外设后，就转到另外一个程序执行，此时，外设和 CPU 并行工作。 一旦外设完成任务，便发中断请求给CPU，告知CPU此次任务已经完成。此时，CPU暂停正在执行的程序，转到一个中断服务程序进行中断处理，在中断处理过程中，进行外设下一步的准备工作(例如，传送下一个要打印的数据，或者取走键盘数据或采样数据，为下次输入腾空数据缓冲寄存器，等等)，最后启动外设，并回到原程序继续执行。此时，CPU和外设又能并行工作。 为什么在保护现场和恢复现场的过程中,CPU 必须关中断？ 在保护断点和现场以及恢复断点和现场过程中，如果又有新的中断被响应，则原被保护的断点或现场就会被破坏。 因而，需要一种机制能保证断点和现场的保护及恢复过程不被新的中断请求打断。 DMA 方式能够提高成批数据交换效率的主要原因何在？ DMA 方式下，CPU 只要在最初的 DMA 控制器初始化和最后处理“DMA 结束”中断时介入，而在整个一块数据传送过程中都不需要 CPU 参与，因而 CPU 用于 I/O 的开销非常小。 CPU 响应 DMA 请求和响应中断请求有什么区别？为什么通常使 DMA 请求具有高于中断请求的优先权？ DMA 方式下，向 CPU 请求的是总线控制权，要求 CPU 让出总线控制权给 DMA 控制器，由DMA控制器来控制总线完成主存和外设之间的数据交换。因此，CPU只要用完总线后就可以响应请求，释放总线，让出总线控制权。CPU 总是在一次总线事务完成后响应，因此，DMA 响应时间应该少于一个总线周期。 而中断方式下请求的是 CPU 时间，要求 CPU 中止正在执行的程序，转到中断服务程序去执行，通过执行中断服务程序，对中断事件进行相应的处理。CPU 总是要等到一条指令执行结束后，才去查询有无中断请求，所以响应时间少于一个指令周期的时间。 原因：DMA请求得不到及时响应，I/O传输数据可能会丢失。 如何解决结构冒险？ 通过以下两种规整流水线结构的方式可以解决部分结构冒险： 规定每个功能部件在每条指令执行过程中只能被使用一次。例如，每条指令只能用一次“寄存器写口”。 每个功能部件只能在一个特定的流水段内被使用。例如，“寄存器写口”只能在第5个流水阶段被使用。 另外，指令和数据分别存放在不同的存储器中，使得同时访问指令和数据不会引起存储器资源的结构冒险。 什么是控制冒险？哪些情况下会发生控制冒险？ 正常情况下PC的值按顺序增量，但在执行转移类指令或发生异常和中断时，PC 的值由指令或异常/中断处理部件给岀。 流水线方式下，如果在取下一条指令时，正确的下条指令地址还没有送到 PC 中，那么所取的下条指令就不是正确的，因而发生控制冒险。 可以看出，如果确定下条指令地址所用时间较长，就会因为来不及在一个时钟周期内得到正确的 PC 值而发生控制冒险。通常，转移类指令会发生控制冒险，例如，分支指令（条件转移指令）要根据条件测试结果来确定 PC 的值，因而会发生控制冒险；返回指令需要从存储器中读取返回地址送PC，因而也会发生控制冒险。","link":"/2020/12/17/%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%8D%E4%B9%A0/"},{"title":"物理层-对比","text":"数据 离散数据x∈{0,1} 连续数据：x∈[0,1] 信号 离散信号 连续信号 信道 信号某一方向的传输媒介，具有方向性（不可变）。 通常一条通信线路有两条信道（双向）。（信道不等于通信电路） 单工（一条），半双工/全双工（两条）（区别：能否同时发送和接收） 两个速率 码元传输速率（波特率）：单位时间内数字通信系统所传输的码元个数（脉冲个数，信号变化次数）。（Baud） 信息传输速率（比特率）：单位时间内数字通信系统传输的二进制码元个数（比特率）。 关系：若一个码元表示k进制数（k种形态），则有：信息传输速率=码元传输速率×$\\log_2(k)$（信息传输速率&gt;=码元传输速率）。 带宽 在计算机网络中：数据传输率的最高上限值，单位bps、bit/s。 在通信领域中：通信线路最高承受的信号频率与最低承受信号的频率的差值，单位Hz。 两个定理 奈斯定理（通信层面）： 内容：在理想低通（无噪声，带宽有限）的信道中，极限码元的传输速率为2W（Baud），其中W为通信领域的信道带宽，单位Hz。 作用：给出了码元传输速率的限制。 结论： 在任何信道上，码元的传输速率是有上限的，若超过此上限会出现码间串扰（码元之间的界限模糊不清）。 信道的频带越宽，就可以用更高的速率对码元进行有效传输。 香农定理（信息层面）： 内容：在高斯白噪声干扰的信道中，极限数据传输速率为$W\\log(1+\\frac{S}{N})$，单位为bps，S/N为信噪比，若用dB表示则需通过$dB=10\\lg(\\frac{S}{N})$来转换。 作用： 给出了数据传输速率的限制（实际传输速率可能低不少）。 结论： 信道的带宽越宽，信噪比越大，则信息的传输速率越高。 只要信息的传输速率低于极限传输速率，就一定能找到某种方法来实现无差错的传输。（意思是在物理层面上不会因传输速率过快而导致信号失真） 结合奈斯定理和香浓定理，可知：单个码元的所携带的二进制信息量是有限的。 题型： 若已知码元和比特的关系（一个码元有几种状态），次数可以通过奈斯定理去计算，最终结果受到两个公式的限制，即V=min{奈斯,香农}。 在脉码调制PCM中的采样频率即最终频率f，也就是说数据传输率为f×$\\log_2n$,而无需进行2f处理（采样定理）。 编码与调制编码 数据-&gt;数字信号 数字数据-&gt;数字信号： 曼彻斯特：每一个码元中间都有跳变，1下降沿，0上升沿。（可做时钟同步） 曼彻斯特关心一个码元内的跳变。 差分曼彻斯特：每一个码元中间都有跳变，1起始不跳，0起始跳。（可做时钟同步） 差分曼彻斯特关心码元间的跳变。 第一个是0的从低到高，第一个是1的从高到低，后面的就看有没有跳变来决定了。 （差分）曼彻斯特每个比特需要两个信号周期（与不归零相比），编码效率为50%。 4B/5B： 数据流4位一组转5位（为了保证有足够多的跳变，提取时钟信息），冗余码做控制或保留。 模拟信号-&gt;数字信号：常用于对音频信号编码的调制（脉码调制PCM） 采样：将时间上连续的模拟信号离散化。（根据奈斯定理2W原则有：采样频率必须&gt;=数字信号最大频率×2） 量化：将离散的模拟信号标准化为数字值。 编码：将量化的结果转化为二进制编码。 调制 数据-&gt;模拟信号 数字数据-&gt;模拟信号： 幅移键控（ASK）：以振幅的大小（有无）来表示1,0。 频移键控（FSK）：以频率大小来表示1,0。 相移键控（PSK）：以相位的正负来表示1,0。 正交振幅调制（QSK）：ASK+PSK 模拟数据-&gt;模拟信号： 为了实现传输的有效性同分利用带宽资源。 三种交换 电路交换 概念： 数据传输前，两节点间必须建立一条专用的物理通信路径（交换设备和链路逐段连接而成），整条线路的资源在传输期间一直被独占，直到通信结束后释放。 电路建立后是直连式：电路上任何节点直通式转发数据，无存储转发时延。 单位： 比特流 优点： 通信时延小 有序传输 无冲突 即可传输数字信号，又可传输模拟信号 实时性强 控制简单 缺点： 建立连接时间长 线路独占，使用效率低 灵活性差，通信线路任何一点出现故障都需要重新建立连接 差错： 无差错检测 报文交换 概念： 将整个报文一段链路一段链路地转发，可自由选择路由路径。 单位： 报文（源地址、目的地址、……） 优点： 无需建立链接（存储转发） 动态分配电路 提高线路可靠性：中间节点出现故障可另选择路由 提高线路利用率：通信双方不独占线路 提供多目标服务：可同时发往多个目的地址 缺点： 报文在传输途中，中间节点存储转发造成时延（包括检查正确性） 不可传输模拟信号 对报文无限制，需要网络节点有较大缓存 差错： 可通过报文尾部FCS进行差错（位错）检测（在交换节点中）。 分组交换 概念： 将整个报文拆分（添加控制信息）成合理大小地分组，各分组独立选择路由路径，与报文一样一段链路一段链路地转发 以太网采用分组交换 两种方式（网络层）：数据报方式（不可靠）、虚电路方式。 单位： 分组 优点： 无需建立链接（存储转发） 动态分配电路 提高线路可靠性：中间节点出现故障可另选择路由 提高线路利用率：通信双方不独占线路 提供多目标服务：可同时发往多个目的地址 缺点： 报文在传输途中，中间节点存储转发造成时延（包括检查正确性） 不可传输模拟信号 需要传输额外的信息量（各分组地控制信息） 可能出现失序、丢失、重复地分组（因为各分组独立自主选择路由路径） 差错： 可通过分组尾部FCS进行差错（位错）检测（在交换节点中）。 区别： 报文交换： 每个报文在发送时会产生一次时延 经过路由器存储转发会发生另一次时延 分组交换： 每个分组发送时会产生一次时延 路由器接收到第一个分组后直接开始转发，产生一次时延，除了第一个分组，其余分组经过路由器转发不会产生额外的时延（因为多个分组可以并行地被不同路由器转发）。 选择: 传输的信息量大，传输时间远大于呼叫时间：电路交换 端到端由很多链路组成：分组交换 转发时延：分组交换&lt;=报文交换 网络信道利用率：分组交换、报文交换&lt;=电路交换 数据传输率：电路交换&gt;报文交换&gt;分组交换 备注： 在四种交换：电路交换、报文交换、（网络层）分组交换（数据报服务、虚电路服务）中，只有虚电路服务能够提供可靠传输，报文交换未知。 电路交换：整个信号连续不断地直通式传送，不存在帧错（失序、丢失、重复）的问题，但是没有对位错的校验。 报文交换：只有一个传输单位（报文），不存在帧失序的问题，但是报文有没有FCS检测位错呢？待定不知道看可不可靠。 数据报服务（面向无连接）：可通过帧尾的FSC进行位错校验，但无法保证不帧错。 虚电路服务（面向连接）：可通过帧尾的FSC进行位错校验，由于建立了一条逻辑上的专用通信电路，故能保证不帧错。 面向链接，逻辑相连，AB可同时向对方发送数据，分组首部不包含目的地址，包含虚电路标识符，每个阶段可以链接多条虚电路。 可靠传输=不位错+不帧错 一般由于数据链路层总是能够通过FSC来保证不位错，故我们通常所说的可靠传输通过 超时 + 重传（保证不帧错）机制来实现即可。","link":"/2020/12/05/%E7%89%A9%E7%90%86%E5%B1%82-%E5%AF%B9%E6%AF%94/"},{"title":"网易云iframe插件","text":"关于网易云iframe插件自适应直接导出代码 使用网易云音乐直接导出的播放器插件代码width和height都是以px为单位的固定值（无单位默认px）。 12&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450src=&quot;//music.163.com/outchain/player?type=0&amp;id=3201058122&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; 所以不会根据屏幕分辨率自适应插件大小，导致插件覆盖其他布局内容。 改进 将iframe标签中的width属性以百分比为单位定义(width=100%)，即可。 12&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=3201058122&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;","link":"/2020/01/19/%E7%BD%91%E6%98%93%E4%BA%91iframe%E6%8F%92%E4%BB%B6/"},{"title":"网络层","text":"网络层提供的两种服务 虚电路服务 面向连接，可靠通信应当由网络来保证。 端到端的差错处理和流量控制可以由网络负责，也可以由用户主机负责。 数据报服务 无连接，可靠通信应当由用户主机来保证。 端到端的差错处理和流量控制由用户主机负责。 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。 网络层不提供服务质量的承诺。 网际协议 IP 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP (Address Resolution Protocol)(RARP是反向地址解析协议) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 分类的 IP 地址 三个历史阶段 分类的 IP 地址：这是最基本的编址方法。 子网的划分：这是对最基本的编址方法的改进。 构成超网：这是比较新的无分类编址方法。 分类 IP 地址 各类IP地址的网络号字段和主机号字段 点分十进制记法 ：机器中存放的 IP 地址是 32 位二进制代码，我们将每 8 位为一组将每 8 位的二进制数转换为十进制数，采用点分十进制记法，进一步提高可读性。 一般不使用的特殊的 IP 地址 IP 地址与硬件地址 硬件地址（或物理地址）是数据链路层和物理层使用的地址。 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。 地址解析协议 ARP 通信时使用了两个地址： IP 地址（网络层地址） MAC 地址（数据链路层地址） ARP 作用： 从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。 要点： 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。 如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。 ARP请求分组：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址。 本地广播 ARP 请求（路由器不转发ARP请求）。 ARP 响应分组：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。 ARP 分组封装在物理网络的帧中传输。 ARP 高速缓存的作用： 存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量。 注意的问题： ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。 如果所要找的主机和源主机不在同一个局域网上，就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 IP 数据报的格式 一个 IP 数据报由首部和数据两部分组成。 首部的前一部分是固定长度，共20字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 可变部分选项字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。 路由表： 路由表没有给分组指明到某个网络的完整路径。 路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。 划分子网和构造超网 划分子网 （重要） 划分原因： IP 地址空间的利用率有时很低。 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 两级的 IP 地址不够灵活。 从两级 IP 地址到三级 IP 地址，IP 地址中又增加了一个子网号字段，使两级的 IP 地址变成为三级的 IP 地址。 划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而不改变 IP 地址原来的网络号 net-id。 优点： 减少了 IP 地址的浪费 使网络的组织更加灵活 更便于维护和管理 划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。 子网掩码（重要） 设置原因： 从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。 使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。 规则： 子网掩码长度 ＝ 32 位 某位 ＝ 1：IP地址中的对应位为网络号和子网号 某位 ＝ 0：IP地址中的对应位为主机号 子网掩码是一个重要属性： 子网掩码是一个网络或一个子网的重要属性。 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。 路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。 若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。 子网划分方法 有固定长度子网和变长子网两种子网划分方法。 在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了。 子网划分为什么全0全1子网号不能使用？ 划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。 无分类编址 CIDR 网络前缀： 为了解决： B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！ 互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。 整个 IPv4 的地址空间最终将全部耗尽。 IP 编址问题的演进 使用变长子网掩码 VLSM (Variable Length Subnet Mask)可进一步提高 IP 地址资源的利用率。 在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是无分类域间路由选择 CIDR (Classless Inter-Domain Routing)。 CIDR 最主要的特点 CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。 CIDR使用各种长度的网络前缀(network-prefix)来代替分类地址中的网络号和子网号。 IP 地址从三级编址（使用子网掩码）又回到了两级编址。 CIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如：220.78.168.0/24 CIDR 地址块 CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。 128.14.32.0/20 表示的地址块共有$2^{12}$ 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。 这个地址块的起始地址是 128.14.32.0。 在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。 128.14.32.0/20 地址块的最小地址：128.14.32.0 128.14.32.0/20 地址块的最大地址：128.14.47.255 全 0 和全 1 的主机号地址一般不使用。 路由聚合 (route aggregation) 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。 路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 路由聚合也称为构成超网 (supernetting)。 CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。 对于 /20 地址块，它的掩码是 20 个连续的 1。斜线记法中的数字就是掩码中1的个数。 构成超网 前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。 这些 C 类地址合起来就构成了超网。 CIDR 地址块中的地址数一定是 2 的整数次幂。 网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。 CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。 网际控制报文协议 ICMP 使用原因： 为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。 ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 ICMP 报文的种类 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 ICMP 差错报文： 终点不可达 时间超过 参数问题 改变路由（重定向）(Redirect) 不应发送 ICMP 差错报告报文的几种情况 对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。 对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。 对具有多播地址的数据报都不发送 ICMP 差错报告报文。 对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。 ICMP 询问报文： 回送请求和回答报文 时间戳请求和回答报文 ICMP 的应用举例 PING (Packet InterNet Groper-因特网包探索器) PING 用来测试两个主机之间的连通性。 PING 使用了 ICMP 回送请求与回送回答报文。 PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 Traceroute 的应用举例 在 Windows 操作系统中这个命令是 tracert。 用来跟踪一个分组从源点到终点的路径。 它利用 IP 数据报中的 TTL 字段和 ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。 互联网的路由选择协议 自治系统 AS(Autonomous System) 自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。 现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。 互联网有两大类路由选择协议 内部网关协议 IGP (Interior Gateway Protocol) 在一个自治系统内部使用的路由选择协议。 目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。 外部网关协议 EGP (External Gateway Protocol) 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。 在外部网关协议中目前使用最多的是 BGP-4。 自治系统之间的路由选择也叫做域间路由选择 (interdomain routing) 在自治系统内部的路由选择叫做域内路由选择 (intradomain routing) 内部网关协议 IGP：具体的协议有多种，如 RIP 和 OSPF 等。 外部网关协议 EGP：目前使用的协议就是 BGP。 内部网关协议 RIP 工作原理 路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。 RIP 是一种分布式的、基于距离向量的路由选择协议。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 关于距离（跳数）： RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。 RIP 允许一条路径最多只能包含 15 个路由器。 “距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。 RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。 RIP 协议特点 仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。 好消息传播得快，坏消息传播得慢。RIP 存在的一个问题：当网络出现故障时，要经过比较长的时间(例如数分钟) 才能将此信息传送到所有的路由器。 RIP 协议的优缺点 优点： 实现简单，开销较小。 缺点： RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 “坏消息传播得慢”，使更新过程的收敛时间过长。 内部网关协议 OSPF 开放最短路径优先 OSPF (Open Shortest Path First)是为克服 RIP 的缺点在 1989 年开发出来的。 OSPF 的原理很简单，但实现起来却较复杂。 OSPF 协议的基本特点 开放表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 最短路径优先是因为使用了 Dijkstra 提出的最短路径算法 SPF 采用分布式的链路状态协议 (link state protocol)。 注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。 三个要点 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 链路状态数据库 (link-state database) 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。 这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。 OSPF 的更新过程收敛得快是其重要优点。 划分区域 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。在上层的区域叫做主干区域 (backbone area)。 主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 外部网关协议 BGP BGP 是不同自治系统的路由器之间交换路由信息的协议。 BGP 较新版本是 2006 年 1 月发表的 BGP-4（BGP 第 4 个版本），即 RFC 4271 ~ 4278。 可以将 BGP-4 简写为 BGP。 BGP 使用环境不同 互联网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。 当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。 比较合理的做法是在 AS 之间交换“可达性”信息。 自治系统之间的路由选择必须考虑有关策略。 不同AS性能相差可能会很大，所以依据跳数做路由选择不合适。而且还要考虑有关策略，有的AS愿意让别人过，有的AS不愿意让别人过，有的AS只愿意让交钱的人过，有的AS不愿意让自己的信息从某个AS中过。 因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。 BGP 发言人 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” (BGP speaker) 。 一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。 BGP 交换路由信息 一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。 使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。 使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站(neighbor)或对等站(peer) 。 BGP 协议的特点 BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。 每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。 BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。 在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。 路由器的构成 路由器是一种典型的网络层设备。 路由器是互联网中的关键设备。 路由器的主要作用是： 连通不同的网络。 选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来 典型的路由器的结构 整个的路由器结构可划分为两大部分： 路由选择部分 分组转发部分 路由选择部分 也叫做控制部分，其核心构件是路由选择处理机。 路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。 分组转发部分由三部分组成： 交换结构 (switching fabric)：又称为交换组织，其作用是根据转发表 (forwarding table) 对分组进行处理。 一组输入端口 一组输出端口（请注意：这里的端口就是硬件接口） “转发”和“路由选择”的区别 “转发”(forwarding) 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。 “路由选择”(routing) 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。 路由表是根据路由选择算法得出的。而转发表是从路由表得出的。 在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。 IPv6 解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP，即 IPv6。 IPv6 的基本首部 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组。为方便起见，本书仍采用数据报这一名词。 所引进的主要变化如下： 更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 扩展的地址层次结构。 灵活的首部格式。 IPv6 定义了许多可选的扩展首部。 改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。 允许协议继续扩充。 支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。 支持资源的预分配。IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。 IPv6 首部改为 8 字节对齐。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。 IPv4 向 IPv6 过渡 两种向 IPv6 过渡的策略： 使用双协议栈 协议栈 (dual stack) 是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有两个协议栈，一个 IPv4 和一个 IPv6。 根据 DNS 返回的地址类型可以确定使用 IPv4 地址还是 IPv6 地址。 使用隧道技术 在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报，整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。 当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的 IPv6 协议栈。 虚拟专用网 VPN和网络地址转换 NAT 虚拟专用网 VPN 由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。 考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。 假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。 本地地址与全球地址 本地地址——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。 全球地址——全球唯一的 IP 地址，必须向互联网的管理机构申请。 问题：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。 解决：RFC 1918 指明了一些专用地址 (private address)。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫做*专用网。 因为这些专用地址仅在本机构内部使用。专用IP地址也叫做可重用地址 (reusable address)。 虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN (Virtual Private Network)。 “专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。 “虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通信专线，而VPN只是在效果上和真正的专用网一样。 虚拟专用网 VPN 构建 如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。 一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。 网络地址转换 NAT 问题： 在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？ 解决： 再申请一些全球 IP 地址。但这在很多情况下是不容易做到的。 采用网络地址转换 NAT。这是目前使用得最多的方法。 网络地址转换 NAT (Network Address Translation) 方法于1994年提出。 需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球IP地址。 所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。","link":"/2020/12/12/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"Python+Selenium某校的自动打卡脚本","text":"使用selenium库 百度OCR API识别验证码 开启QQ邮箱SMTP服务，邮件提醒打卡状态 阿里云服务器Crontab定时启动 本脚本仅用于个人偷懒使用，并确保填写信息真实 可能需要用到的库 12345678910111213141516#!/usr/bin/env python3# -*- coding: utf-8 -*import timeimport unittestfrom selenium.common.exceptions import NoSuchElementExceptionfrom selenium import webdriverfrom PIL import Imagefrom aip import AipOcrimport refrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.select import Selectfrom smtplib import SMTP_SSLfrom email.mime.text import MIMETextfrom email.header import Headerfrom selenium.webdriver.chrome.options import Options 获取登陆界面的验证码 保存原始验证码code.png 由于原视验证码较模糊，转换为灰度模式，处理后保存code_process.png。 1234567891011121314def get_code(driver): png = driver.find_element_by_id('code-box') png.screenshot('code.png') img = Image.open('code.png') img = img.convert('L') # P模式转换为L模式(灰度模式默认阈值127) count = 185 # 设定阈值 table = [] for i in range(256): if i &lt; count: table.append(0) else: table.append(1) img = img.point(table, '1') img.save('code_process.png') # 保存处理后的验证码 调用百度OCR(文字识别API)识别验证码 验证码只有英文，并且只有4位。 识别过后可能会存在空格，使用正则表达式保留需要的元素返回。 12345678910111213141516171819202122def code_rec(): APP_ID = '' API_KEY = '' SECRET_KEY = '' client = AipOcr(APP_ID, API_KEY, SECRET_KEY) def get_file_content(file_path): with open(file_path, 'rb') as f: return f.read() image = get_file_content(file_path='code_process.png') options = {'language_type': 'ENG', } # 识别语言类型，默认为'CHN_ENG'中英文混合 # 调用通用文字识别 result = client.basicGeneral(image, options) # 高精度接口 basicAccurate for word in result['words_result']: captcha = (word['words']) print('验证码识别结果：' + captcha) captcha_list = re.findall('[a-zA-Z]', captcha, re.S)[:4] captcha_2 = ''.join(captcha_list) print('验证码去杂结果：' + captcha_2) return captcha_2 登陆 获取登陆界面表单元素 填入相应数据 提交 123456789101112131415def login(driver, captcha, stu_dic): try: # driver = webdriver.Chrome() stu_id = driver.find_element_by_name('txtUid') stu_pw = driver.find_element_by_name('txtPwd') code = driver.find_element_by_name('code') stu_id.send_keys(stu_dic['id']) stu_pw.send_keys(stu_dic['pw']) code.send_keys(captcha) driver.find_element_by_id('Submit').click() print(&quot;登陆表单提交成功！&quot;) return True except BaseException: print(&quot;登陆表单提交失败！&quot;) return False 测试元素是否存在(判断登陆结果)1234567891011121314# 方法必须要继承自unittest.TestCaseclass VisitSogouByIE(unittest.TestCase): def setUp(self): # 启动谷歌浏览器 self.driver = webdriver.Chrome() def isElementPresent(self, by, value, driver): try: driver.find_element(by=by, value=value) except NoSuchElementException: print(&quot;没有找到指定元素！&quot;) return False else: return True 填写并提交数据表单 Xpath语法或其他方法定位到对应填写入口 获取对应数据并填入表单提交 123456789101112131415161718192021222324252627282930313233343536def sub_form(driver): try: driver.find_element_by_xpath(&quot;//div[@id='platfrom2']/a&quot;).click() select_1 = driver.find_element_by_name('FaProvince').get_attribute('value') select1 = Select(driver.find_element_by_name('Province')) select1.select_by_value(select_1) print(&quot;行政区代码&quot; + select_1) select_2 = driver.find_element_by_name('FaCity').get_attribute('value') select2 = Select(driver.find_element_by_name('City')) select2.select_by_value(select_2) select_3 = driver.find_element_by_name('FaCounty').get_attribute('value') select3 = Select(driver.find_element_by_name('County')) select3.select_by_value(select_3) ck_cls = driver.find_element_by_xpath('//*[@id=&quot;form1&quot;]/div[1]/div[5]/div[3]/div/div/label') js = &quot;var q=document.documentElement.scrollTop=10000&quot; driver.execute_script(js) # ActionChains(driver).send_keys(Keys.END).perform() ck_cls.click() save_form = driver.find_element_by_class_name('save_form') save_form.click() print(&quot;信息表单提交成功！&quot;) driver.quit() return True except BaseException as erro: time.sleep(5) print(erro) already_text = driver.find_element_by_xpath( &quot;//*[@class='layui-m-layercont']&quot;).text if already_text == '当前采集日期已登记！': print(already_text) driver.quit() return already_text else: print(&quot;提交失败！&quot;) print(already_text) return False 邮件提醒打卡状态 利用QQ邮箱或其他SMTP服务或自己服务器搭建的邮件服务发送邮件 12345678910111213141516171819202122232425def send_email(text, stu_dic): try: email_from = '' email_to = stu_dic['email_to'] # 接收邮箱 hostname = 'smtp.qq.com' # QQ邮箱的smtp服务器地址 login = '' # 发送邮箱的用户名 password = '' # 发送邮箱的密码，即开启smtp服务得到的授权码。 subject = '打卡状态' # 邮件主题 # text = &quot;恭喜您！打卡成功！&quot; # 邮件正文内容 smtp = SMTP_SSL(hostname) # SMTP_SSL默认使用465端口 smtp.login(login, password) msg = MIMEText(text, 'plain', 'utf-8') msg['Subject'] = Header(subject, 'utf-8') msg['from'] = email_from msg['to'] = email_to smtp.sendmail(email_from, email_to, msg.as_string()) smtp.quit() print(&quot;发送成功！&quot;) return True except BaseException: print(&quot;发送失败！&quot;) return False 主函数 程序运行成功邮件提醒 程序运行失败异常处理及邮件提醒 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465if __name__ == &quot;__main__&quot;: try: chrome_options = Options() chrome_options.add_argument('--no-sandbox') chrome_options.add_argument('--disable-dev-shm-usage') chrome_options.add_argument('--headless') stu = [ {'id': 'xxxxx', 'pw': 'xxxxx', 'email_to': 'xxxxx@foxmail.com'}, ] for stu_dic in stu: test = VisitSogouByIE() # 实例化对象 # driver = webdriver.Chrome(options=chrome_options,executable_path='/usr/local/bin/chromedriver') # 实例化对象 driver = webdriver.Chrome(options=chrome_options) driver.get('http://xsc.sicau.edu.cn/SPCP/Web/') driver.implicitly_wait(20) get_code(driver) captcha = code_rec() while True: try: if len(captcha) &lt; 4: driver.refresh() time.sleep(2) get_code(driver) captcha = code_rec() else: login(driver, captcha, stu_dic) time.sleep(5) is_exist = test.isElementPresent( driver=driver, by='id', value='platfrom2') if not is_exist: if not test.isElementPresent(driver=driver, by='id', value='layui-m-layer0'): break driver.back() time.sleep(2) driver.refresh() time.sleep(2) get_code(driver) captcha = code_rec() print(&quot;登陆失败！&quot;) elif is_exist: print(&quot;登陆成功！&quot;) break except Exception as erro: print(erro) captcha = 'xxx' continue time.sleep(2) is_sub = sub_form(driver) if is_sub: text = &quot;恭喜您！打卡成功！&quot; if is_sub == '当前采集日期已登记！': text = is_sub send_email(text, stu_dic) elif not is_sub: print(&quot;打卡失败！稍后重试！&quot;) text = &quot;打卡失败！稍后重试！&quot; send_email(text, stu_dic) text = &quot;程序运行结束，所有STU均已操作一遍!&quot; send_email(text, stu[0]) except BaseException as E: me = {'id': 'xxxx', 'pw': 'xxxx', 'email_to': 'xxxx@foxmail.com'} print(E) print(&quot;程序意外终止！&quot;) text = &quot;程序意外终止！&quot; send_email(text,me) 写得比较匆忙有的地方还可以改进，已经开学了，不用打卡了，代码放出来做个记录，顺便水一篇博客。","link":"/2020/09/03/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"},{"title":"枣子·记者团的宣传片","text":"2019年第二学期期末拍摄剪辑的部门招新宣传片。 点击“ZTY的放映厅或“阅读更多”进入文章，播放视频。(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"screenshot\":\"yes\",\"video\":{\"url\":\"/2020/02/01/视频/枣子团队·学生记者团2019宣传片.mp4\"},\"danmaku\":{\"api\":\"https://api.prprpr.me/dplayer/\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()","link":"/2020/02/01/%E8%A7%86%E9%A2%91/"},{"title":"计算机网络-概述","text":"三大类网络 电信网络：提供电话、电报及传真等服务。 有线电视网路：向用户传送各种电视节目。 计算机网络：使用户能在计算机之间传送数据文件。 互联网概述 互联网的两个重要基本特点 连通性 (connectivity) 使上网用户之间都可以交换信息（数据，以及各种音频视频） ，好像这些用户的计算机都可以彼此直接连通一样。 共享 (Sharing) 指资源共享。 互联网的组成 边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分： 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器 (router)。 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 电路交换的特点 电路交换必定是面向连接的。 电路交换分为三个阶段： 建立连接、通信、释放连接 电路交换缺点 通信线路的利用率很低 分组交换的主要特点 分组交换则采用存储转发技术。 在发送端，先把较长的报文划分成较短的、固定长度的数据段。 分组交换的优点： 高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。 灵活：为每一个分组独立地选择最合适的转发路由。 迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。 可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。 分组交换带来的问题 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 三种交换的比较 若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。 报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。 由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。 计算机网络的类别 按照网络的作用范围进行分类 广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里。 城域网 MAN (Metropolitan Area Network)：作用距离约为 5 ~ 50 公里。 局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右）。 个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右。 按照网络的使用者进行分类 公用网 (public network) 按规定交纳费用的人都可以使用的网络。因此也可称为公众网。 专用网 (private network) 为特殊业务工作的需要而建造的网络。 计算机网络的性能 速率 速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate)或比特率 (bit rate)。 速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s 等。例如 $4×10^{10} bit/s$ 的数据率就记为 40 Gbit/s。 速率往往是指额定速率或标称速率，非实际运行速率。 带宽 两种不同意义： “带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。 在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s ，即 “比特每秒”。 在“带宽”的上述两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。 吞吐量 吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。 时延 (delay 或 latency) 发送时延 也称为传输时延。 发送数据时，数据帧从结点进入到传输媒体所需要的时间。 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 $发送时延=\\frac{数据帧长度(bit)}{发送速率(bit/s)}$ 传播时延 电磁波在信道中需要传播一定的距离而花费的时间。 $传播时延=\\frac{信道长度(米)}{发送速率(米/秒)}$ 处理时延 主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。 排队时延 分组在路由器输入输出队列中排队等待处理所经历的时延。 注意： 对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。 提高链路带宽减小了数据的发送时延。 “在高速链路（或高带宽链路）上，比特会传送得更快些”。是错的！ 时延带宽积 链路的时延带宽积又称为以比特为单位的链路长度。 $时延带宽积 = 传播时延×带宽$ 往返时间 RTT 往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率 分为信道利用率和网络利用率。 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。 计算机网络的非性能特征 费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护。 计算机网络的体系结构 分层的优点与缺点 优点 各层之间是独立的、灵活性好、结构上可分割开、易于实现和维护、能促进标准化工作。 缺点 降低效率、有些功能会在不同的层次中重复出现，因而产生了额外开销。","link":"/2020/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0/"},{"title":"运输层","text":"运输层协议概述 进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 运输层的作用 “逻辑通信”的意思是“好像是这样通信，但事实上并非真的这样通信”。 从IP层来说，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚。 严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。 在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。 这表明运输层有一个很重要的功能——复用 (multiplexing)和分用 (demultiplexing)。 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。 屏蔽作用 运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。 但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。 运输层的两个主要协议 用户数据报协议 UDP (User Datagram Protocol) 传输控制协议 TCP (Transmission Control) 当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。 当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 运输层的端口 运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。 解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口 (port)。 软件端口与硬件端口 在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。 用户数据报协议 UDP UDP概述 UDP 只在 IP 的数据报服务之上增加了很少一点的功能： 复用和分用的功能 差错检测的功能 虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。 UDP主要特点 UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。 UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。 UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 UDP 支持一对一、一对多、多对一和多对多的交互通信。 UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 UDP 的首部格式 用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8 个字节。 当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。 请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。 传输控制协议 TCP 概述 TCP 最主要的特点 TCP 是面向连接的运输层协议。 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。 面向字节流 TCP 中的“流”(stream)指的是流入或流出进程的字节序列。 “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。 TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。 但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。 注意 TCP 连接是一条虚连接而不是一条真正的物理连接。 TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。 TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。 TCP 可把太长的数据块划分短一些再传送。 TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 TCP 的连接 TCP 把连接作为最基本的抽象。 每一条 TCP 连接有两个端点。 TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口。 TCP 连接的端点叫做套接字 (socket) 或插口。 端口号拼接到 (contatenated with) IP 地址即构成了套接字。 可靠传输的工作原理 理想的传输条件有以下两个特点： 传输信道不产生差错。 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。 在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。 然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。 停止等待协议 停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。 全双工通信的双方既是发送方也是接收方 出现差错解决方法：超时重传 A 为每一个已发送的分组都设置了一个超时计时器。 A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。 确认丢失和确认迟到 注意 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。 分组和确认分组都必须进行编号。 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 自动重传请求 ARQ 通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。 像上述的这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。 信道利用率 停止等待协议的优点是简单，缺点是信道利用率太低。 流水线传输 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。 流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 连续ARQ协议 滑动窗口协议比较复杂，是 TCP 协议的精髓所在。 发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 累计确认 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 优点：容易实现，即使确认丢失也不必重传。 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 Go-back-N（回退 N） 如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。 这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。 可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 TCP 可靠通信的具体实现 TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。 TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。 TCP 两端的四个窗口经常处于动态变化之中。 TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。 TCP 报文段的首部格式 TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。 一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。 TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。 TCP 可靠传输的实现 以字节为单位的滑动窗口 TCP 的滑动窗口是以字节为单位的。 现假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节，而确认号是 31（这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。 根据这两个数据，A 就构造出自己的发送窗口。 根据 B 给出的窗口值，A 构造出自己的发送窗口。 发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 发送窗口里面的序号表示允许发送的序号。 显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。 需要强调三点 第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。 第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。 第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 选择确认 SACK 问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？ 答案是可以的。选择确认 SACK (Selective ACK) 就是一种可行的处理方法。 接收方收到了和前面的字节流不连续的两个字节块。 如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。 TCP 的流量控制 利用滑动窗口实现流量控制 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。 流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 可能发生死锁 B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。 但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。 如果没有其他措施，这种互相等待的死锁局面将一直延续下去。 为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。 持续计时器 TCP 为每一个连接设有一个持续计时器 (persistence timer) 。 只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。 若窗口不是零，则死锁的僵局就可以打破了。 TCP 的拥塞控制 拥塞控制的一般原理 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。 出现拥塞的原因：$∑对资源需求&gt;可用资源$ 增加资源能解决拥塞吗？ 不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。 网络拥塞往往是由许多因素引起的。例如： 增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞； 提高处理机处理的速率会会将瓶颈转移到其他地方； 拥塞常常趋于恶化 如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。 但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。 可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。 拥塞控制所起的作用 拥塞控制的一般原理 实践证明，拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。 当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的征兆而不是原因。 在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 开环控制和闭环控制 开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。 闭环控制方法是基于反馈环路（事后）的概念。属于闭环控制的有以下几种措施： 监测网络系统以便检测到拥塞在何时、何处发生。 将拥塞发生的信息传送到可采取行动的地方。 调整网络系统的运行以解决出现的问题。 监测网络的拥塞的指标 主要指标有： 由于缺少缓存空间而被丢弃的分组的百分数； 平均队列长度； 超时重传的分组数； 平均分组时延； 分组时延的标准差，等等。 上述这些指标的上升都标志着拥塞的增长。 TCP 的拥塞控制方法 TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。 TCP发送方维持一个拥塞窗口 CWND (Congestion Window) 拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。 所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：&lt;/br&gt;$真正的发送窗口值 = Min(公告窗口值，拥塞窗口值)$ 控制拥塞窗口的原则 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。 拥塞的判断 重传定时器超时 现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络可能出现了拥塞。 收到三个相同（重复）的 ACK 个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。 TCP拥塞控制算法 四种（ RFC 5681）： 慢开始 (slow-start) $拥塞窗口cwnd每次的增加量 = min (N,SMSS)$ 其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。 发送方的最大报文段 SMSS (Sender Maximum Segment Size)。 初始拥塞窗口 cwnd 根据SMMS设置。 慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。 指数增长 拥塞避免 (congestion avoidance) 每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1。 线性增长 快重传 (fast retransmit) 发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。 不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 快恢复 (fast recovery) 当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法。 FR (Fast Recovery) 算法： $慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2$； $新拥塞窗口 cwnd = 慢开始门限 ssthresh$； 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 拥塞控制与流量控制的区别 拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。 拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。 流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 拥塞控制和流量控制之所以常常被弄混，是因为某些拥塞控制算法是向发送端发送控制报文，并告诉发送端，网络已出现麻烦，必须放慢发送速率。这点又和流量控制是很相似的。 TCP 的运输连接管理 运输连接的三个阶段 TCP 是面向连接的协议。 运输连接有三个阶段： 连接建立 数据传送 连接释放 运输连接的管理就是使运输连接的建立和释放都能正常地进行。 TCP 的连接建立 TCP 建立连接的过程叫做握手。 握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。 采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。 TCP 的连接释放 TCP 连接释放过程比较复杂。 数据传输结束后，通信的双方都可释放连接。 TCP 连接释放过程是四报文握手。 第一次 数据传输结束后，通信的双方都可释放连接。 现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。 A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。 第二次 B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。 TCP 服务器进程通知高层应用进程。 从 A 到 B 这个方向的连接就释放了，TCP 连接 处于半关闭状态。B 若发送数据，A 仍要接收。 第三次 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 第四次 A 收到连接释放报文段后，必须发出确认。 在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 A 必须等待 2MSL 的时间 第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。 第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。","link":"/2020/12/15/%E8%BF%90%E8%BE%93%E5%B1%82/"}],"tags":[{"name":"C++内联函数","slug":"C-内联函数","link":"/tags/C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"name":"HTML5+CSS+JS初步","slug":"HTML5-CSS-JS初步","link":"/tags/HTML5-CSS-JS%E5%88%9D%E6%AD%A5/"},{"name":"模型迁移","slug":"模型迁移","link":"/tags/%E6%A8%A1%E5%9E%8B%E8%BF%81%E7%A7%BB/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"VS Code小坑","slug":"VS-Code小坑","link":"/tags/VS-Code%E5%B0%8F%E5%9D%91/"},{"name":"Python学习","slug":"Python学习","link":"/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"Python应用(爬虫-XPath)","slug":"Python应用-爬虫-XPath","link":"/tags/Python%E5%BA%94%E7%94%A8-%E7%88%AC%E8%99%AB-XPath/"},{"name":"旅行","slug":"旅行","link":"/tags/%E6%97%85%E8%A1%8C/"},{"name":"分区、分段、段页式","slug":"分区、分段、段页式","link":"/tags/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E6%AE%B5%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F/"},{"name":"第一篇文章","slug":"第一篇文章","link":"/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统-课后习题","slug":"操作系统-课后习题","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"name":"数据挖掘","slug":"数据挖掘","link":"/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"我的歌单-林俊杰","slug":"我的歌单-林俊杰","link":"/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E6%9E%97%E4%BF%8A%E6%9D%B0/"},{"name":"我的歌单-周杰伦","slug":"我的歌单-周杰伦","link":"/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E5%91%A8%E6%9D%B0%E4%BC%A6/"},{"name":"我的歌单-陈奕迅","slug":"我的歌单-陈奕迅","link":"/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E9%99%88%E5%A5%95%E8%BF%85/"},{"name":"我的歌单-赵海洋","slug":"我的歌单-赵海洋","link":"/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E8%B5%B5%E6%B5%B7%E6%B4%8B/"},{"name":"拓展","slug":"拓展","link":"/tags/%E6%8B%93%E5%B1%95/"},{"name":"80×86汇编语言","slug":"80×86汇编语言","link":"/tags/80%C3%9786%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Python应用(爬虫)","slug":"Python应用-爬虫","link":"/tags/Python%E5%BA%94%E7%94%A8-%E7%88%AC%E8%99%AB/"},{"name":"图库","slug":"图库","link":"/tags/%E5%9B%BE%E5%BA%93/"},{"name":"算法分析与设计","slug":"算法分析与设计","link":"/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"计算机组成与系统结构","slug":"计算机组成与系统结构","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"网易云插件小坑","slug":"网易云插件小坑","link":"/tags/%E7%BD%91%E6%98%93%E4%BA%91%E6%8F%92%E4%BB%B6%E5%B0%8F%E5%9D%91/"},{"name":"Python自动打卡","slug":"Python自动打卡","link":"/tags/Python%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"},{"name":"视频作品","slug":"视频作品","link":"/tags/%E8%A7%86%E9%A2%91%E4%BD%9C%E5%93%81/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"一些小坑","slug":"一些小坑","link":"/categories/%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/"},{"name":"摄与影","slug":"摄与影","link":"/categories/%E6%91%84%E4%B8%8E%E5%BD%B1/"},{"name":"歌单","slug":"歌单","link":"/categories/%E6%AD%8C%E5%8D%95/"},{"name":"脚本","slug":"脚本","link":"/categories/%E8%84%9A%E6%9C%AC/"},{"name":"视频","slug":"视频","link":"/categories/%E8%A7%86%E9%A2%91/"}]}