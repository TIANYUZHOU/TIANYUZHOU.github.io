<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>操作系统课后习题 - 程序员的文章</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="程序员的文章"><meta name="msapplication-TileImage" content="/img/1.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="程序员的文章"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="西安电子科技大学出版社出版的计算机操作系统（第四版）课后习题整理 作者：汤小丹 梁红兵 哲凤屏 汤子瀛  第一章 操作系统引论"><meta property="og:type" content="blog"><meta property="og:title" content="操作系统课后习题"><meta property="og:url" content="http://tianyuzhou.github.io/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"><meta property="og:site_name" content="程序员的文章"><meta property="og:description" content="西安电子科技大学出版社出版的计算机操作系统（第四版）课后习题整理 作者：汤小丹 梁红兵 哲凤屏 汤子瀛  第一章 操作系统引论"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://tianyuzhou.github.io/Mainpic/20.jpg"><meta property="article:published_time" content="2020-11-15T05:45:06.000Z"><meta property="article:modified_time" content="2021-02-17T13:29:04.000Z"><meta property="article:author" content="TIANYUZHOU"><meta property="article:tag" content="操作系统-课后习题"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/Mainpic/20.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://tianyuzhou.github.io/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},"headline":"程序员的文章","image":["http://tianyuzhou.github.io/Mainpic/20.jpg"],"datePublished":"2020-11-15T05:45:06.000Z","dateModified":"2021-02-17T13:29:04.000Z","author":{"@type":"Person","name":"TIANYUZHOU"},"description":"西安电子科技大学出版社出版的计算机操作系统（第四版）课后习题整理 作者：汤小丹 梁红兵 哲凤屏 汤子瀛  第一章 操作系统引论"}</script><link rel="canonical" href="http://tianyuzhou.github.io/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"><link rel="alternate" href="/atom.xml" title="程序员的文章" type="application/atom+xml"><link rel="icon" href="/img/1.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?66aa3594928a536d6d93ed30544fffe8";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2.png" alt="程序员的文章" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TIANYUZHOU"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/Mainpic/20.jpg" alt="操作系统课后习题"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-11-15T05:45:06.000Z" title="2020/11/15 13:45:06">2020-11-15</time>发表</span><span class="level-item"><time dateTime="2021-02-17T13:29:04.000Z" title="2021/2/17 21:29:04">2021-02-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="level-item">3 小时读完 (大约25924个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">操作系统课后习题</h1><div class="content"><ul>
<li>西安电子科技大学出版社出版的<strong>计算机操作系统（第四版）</strong>课后习题整理</li>
<li>作者：汤小丹 梁红兵 哲凤屏 汤子瀛</li>
</ul>
<h3 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h3><span id="more"></span>
<ol>
<li>设计现代OS的主要目标是什么？<ul>
<li>有效性</li>
<li>方便性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
<li>OS的作用可表现在哪几个方面？<ul>
<li>OS作为用户与计算机硬件系统之间的接口</li>
<li>OS作为计算机系统资源的管理者</li>
<li>OS实现了对计算机资源的抽象</li>
</ul>
</li>
<li>为什么没说OS实现了对计算机资源的抽象？<ul>
<li>OS首先在裸机上覆盖一层<strong>I/O设备管理软件</strong>，实现了对<strong>计算机硬件操作</strong>的第一层抽象</li>
<li>在第一层软件上再覆盖<strong>文件管理软件</strong>，实现了对<strong>硬件资源操作</strong>的第二层抽象</li>
<li>OS通过在计算机硬件上安装<strong>多层系统软件</strong>，增强了系统功能，隐藏了对硬件操作的细节，由它们共同实现了对<strong>计算机资源</strong>的抽象</li>
</ul>
</li>
<li>试说明推动多道批处理系统形成和发展的主要动力是什么？<ul>
<li>主要动力来源于四个方面的社会需求与技术发展<ul>
<li>不断提高计算机资源的利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求</li>
</ul>
</li>
</ul>
</li>
<li>何谓脱机I/O和联机I/O？<ul>
<li>脱机I/O是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在外围机的控制下，把纸带或卡片上的数据或程序输入到磁带上。该方式下的输入和输出由外围机控制完成，是在脱离主机的情况下进行的</li>
<li>联机I/O方式是指程序和数据的输入输出都是直接在主机的直接控制下进行的</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87">外围机（外围设备）？</a></li>
</ul>
</li>
<li>试说明推动分时系统形成和发展的主要动力是什么？<ul>
<li>主要动力是：更好地满足用户的需要</li>
<li>主要表现在：<ul>
<li>CPU的分时使用缩短了作业的平均周转时间</li>
<li>人机交互能力使用户能直接控制自己的作业</li>
<li>主机的共享使多用户能同时使用同一台计算机，独立地处理自己的作业</li>
</ul>
</li>
</ul>
</li>
<li>实现分时系统地关键问题是什么？应如何解决？<ul>
<li>关键问题：当用户在自己的终端上键入自己的命令时，系统应能及时接收并及时处理该命令，在用户能接受的时延内将结果返回给用户</li>
<li>解决办法：<ul>
<li>针对<strong>及时接收问题</strong>，可以在系统中设置<strong>多路卡</strong>，使主机能够同时接收用户从各个终端上输入的数据；为每个终端<strong>配置缓冲区</strong>，暂存用户键入的命令或数据</li>
<li>针对<strong>及时处理问题</strong>，应使所有用户的作业都<strong>直接进入内存</strong>，并且为每个作业分配一个<strong>时间片</strong>，允许作业只在自己的时间片内运行，这样在不长的时间内，能使每个作业都运行一次</li>
</ul>
</li>
</ul>
</li>
<li>为什么要引入实时OS？<ul>
<li>实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</li>
<li>引入实时OS是为了满足应用的需求，更好地满足<strong>实时控制领域</strong>和<strong>实时信息处理领域</strong>的需要。</li>
</ul>
</li>
<li>什么是硬实时任务和软实时任务？试举例说明。<ul>
<li>硬实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。<ul>
<li>例如：运载火箭的控制等</li>
</ul>
</li>
<li>软实时任务是指它的截止时间并不严格，偶尔错过任务截止时间，对系统产生的影响不大。<ul>
<li>例如：网页内容更新，火车售票系统。</li>
</ul>
</li>
</ul>
</li>
<li>试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。<ul>
<li>及时性：<strong>实时信息处理系统</strong>对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而<strong>实时控制系统</strong>的及时性，是以控制对象所要求的开始截止时间或完成时间来确定的，一般为<strong>秒级到毫秒级，甚至有的要低于100微秒</strong>。</li>
<li>交互性：<strong>实时信息处理系统</strong>具有交互性，但人与系统的交互仅限于访问系统中某些特定的专用服务程序。不像<strong>分时系统</strong>那样能向终端用户提供数据和资源共享等服务</li>
<li>可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至灾难性后果，所以在实时系统中，往往都采取了<strong>多级容错措施</strong>保障系统的安全性及数据的安全性</li>
</ul>
</li>
<li>OS有哪几大特征？其最基本的特征是什么？<ul>
<li>特征：<strong>并发性、共享性、虚拟性、异步性</strong>四个基本特征</li>
<li>最基本特征：共享和并发是操作系统的两个最基本的特征，虚拟以并发和共享为前提，异步是并发和共享的必然结果。</li>
</ul>
</li>
<li>在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对于独占资源应采取何种共享方式？<ul>
<li>一般情况下：只能说明资源能被大家使用，如图书馆中的图书能提供给大家借阅，但并<strong>未限定借阅者必须在同一时间（间隔）和同一地点阅读</strong>。这样的资源共享方式，只要通过适当的安排，用户之间并<strong>不会产生对资源的竞争</strong>，因此资源管理比较简单。</li>
<li>OS环境下：资源共享或称为资源复用是指系统中的资源可供内存中多个并发执行的进程共同使用。宏观上<strong>既限定了时间（进程在内存期间），也限定了地点（内存）</strong>。由于系统资源远少于多道程序需求的总合，<strong>会形成对共享资源的争夺</strong>，资源管理复杂得多。</li>
<li>独占资源：在一段时间内，只允许一个进程访问该资源。应采用<strong>互斥共享方式</strong>。</li>
<li>其他资源：允许在一段时间内由多个进程“同时”（微观上交替进行）访问。可采用<strong>同时访问方式</strong>。例如：磁盘设备等。</li>
</ul>
</li>
<li>什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。<ul>
<li>时分复用技术：利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使得设备得到最充分的利用（也是提高资源利用率的根本原因）。</li>
<li>举例：<ul>
<li>虚拟处理机技术：利用多道程序设计技术，为每道程序建立至少一个进程，然多道程序并发执行。实现为多个用户服务，将一台物理处理机逻辑上分为多台处理机。</li>
<li>虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，供多个用户“同时”使用。</li>
</ul>
</li>
</ul>
</li>
<li>是什么原因使操作系统具有异步性特征？<ul>
<li>由于<strong>资源等</strong>因素的限制，使进程通常都不可能“一气呵成”，而是以“停停走走”的方式运行，即异步方式运行。</li>
</ul>
</li>
<li>处理机管理有哪些主要功能？它们的主要任务是什么？<ul>
<li><strong>进程控制（管理）：</strong> 为作业创建进程，撤销已结束进程控制进程在运行过程中的状态转换</li>
<li><strong>进程同步：</strong> 为多个进程（含线程）的运行进行协调</li>
<li><strong>进程通信：</strong> 用来实现在相互合作的进程之间的信息交换</li>
<li><strong>（处理机）调度：</strong><ul>
<li>作业调度：从后备队列按照一定算法，选出若干个作业，为它们分配所需的资源（首先是分配内存）。</li>
<li>进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。</li>
</ul>
</li>
</ul>
</li>
<li>内存管理有哪些主要功能？它们的主要任务是什么？<ul>
<li><strong>内存分配：</strong> 为每道程序分配内存</li>
<li><strong>内存保护：</strong> 确保每道用户程序都只在自己的内存空间运行，彼此互不干扰</li>
<li><strong>地址映射：</strong> 将地址空间的逻辑地址转换为内存空间与对应的物理地址</li>
<li><strong>内存扩充：</strong> 用于实现请求调用功能，置换功能等</li>
</ul>
</li>
<li>设备管理有哪些主要功能？其主要任务是什么？<ul>
<li>主要功能:缓冲管理、设备分配和设备处理以及虚拟设备等。</li>
<li>主要任务:完成用户提出的I/O请求，为用户分配I/O设备；提高CPU和I/O设 备的利用率；提高I/O速度；以及方便用户使用I/O设备。</li>
</ul>
</li>
<li>文件管理有哪些主要功能？其主要任务是什么？<ul>
<li>主要功能：文件存储空间的管理、目录管理、文件的读/写管理和保护。</li>
<li>主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。</li>
</ul>
</li>
<li>试说明推动传统OS演变为现代OS的主要因素是什么？<ul>
<li>用户对OS的系统安全、网络功能和服务、多媒体功能的需求增加。</li>
<li>计算机技术的不断发展。</li>
</ul>
</li>
<li>什么是微内核OS？<ul>
<li>足够小的内核</li>
<li>基于客户/服务器模式</li>
<li>应用机制与策略分离原理</li>
<li>采用面向对象技术</li>
</ul>
</li>
<li>微内核操作系统具有哪些优点？它为何能有这些优点？<ul>
<li>提高了系统的可扩展性</li>
<li>增强了系统的可靠性</li>
<li>可移植性</li>
<li>提供了对分布式系统的支持</li>
<li>融入了面向对象技术</li>
</ul>
</li>
<li>现代操作系统较之传统操作系统又增加了哪些功能和特征？<ul>
<li>面向安全、面向网络、面向多媒体</li>
</ul>
</li>
<li>在微内核OS中，为什么要采用客户/服务器模式？<ul>
<li>C/S模式具有独特的优点：<ul>
<li>数据的分布处理和存储</li>
<li>便于集中管理</li>
<li>灵活性和可扩充性</li>
<li>易于改编应用软件</li>
</ul>
</li>
</ul>
</li>
<li>在基于微内核结构的OS中，应用了哪些新技术？<ul>
<li>采用面向对象的程序设计技术</li>
</ul>
</li>
<li>何谓微内核技术？在微内核中通常提供了哪些功能？<ul>
<li>把操作系统中更多的成分和功能放到更高的层次（即用户模式）中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。</li>
<li>在微内核中通常提供了<strong>进程（线程）管理</strong>、<strong>低级存储器管理</strong>、<strong>中断和陷入处理</strong>等功能。</li>
</ul>
</li>
</ol>
<h3 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h3><ol>
<li>什么是前趋图？为什么要引入前趋图？<ul>
<li>前趋图(Precedence Graph)是一个<strong>有向无循环图</strong>，记为DAG(Directed AcyclicGraph)，用于描述<strong>进程之间</strong>执行的<strong>前后关系</strong>。</li>
</ul>
</li>
<li>画出下列四条语句的前趋图<ul>
<li>略</li>
</ul>
</li>
<li>为什么程序并发执行会产生间断性特征？<ul>
<li>程序在并发执行时，由于它们<strong>共享系统资源</strong>，以及为完成同一项任务需要<strong>相互合作</strong>，致使这些并发进程之间形成了<strong>互相制约</strong>的关系，从而使得进程在执行期间出现间断性。</li>
</ul>
</li>
<li>程序并发执行时为什么会失去封闭性和可再现性？<ul>
<li>程序并发执行时，多个程序<strong>共享系统中的各种资源</strong>，因而这些<strong>资源的状态由多个程序改变</strong>，致使程序运行失去了封闭性，也会导致其失去可再现性。</li>
</ul>
</li>
<li>在操作系统中为什么要引入进程概念？它会产生什么样的影响?<ul>
<li>为了<strong>使程序</strong>在多道程序环境下<strong>能并发执行</strong>，并对并发执行的程序<strong>加以控制和描述</strong>，在操 作系统中引入了进程概念。</li>
<li>影响：使程序的并发执行得以实行。</li>
</ul>
</li>
<li>试从动态性，并发性和独立性上比较进程和程序?<ul>
<li><strong>动态性</strong>是进程<strong>最基本的特性</strong>，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是<strong>静态实体</strong>。</li>
<li><strong>并发性</strong>是进程的重要特征，同时也是<strong>OS的</strong>重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。</li>
<li><strong>独立性</strong>是指进程实体是一个能<strong>独立运行的基本单位</strong>，也是系统中<strong>独立获得资源</strong>和<strong>独立调度</strong>的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。</li>
</ul>
</li>
<li>试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？<ul>
<li><strong>作为独立运行基本单位的标志</strong><ul>
<li>PCB的建立表示程序成为一个能在多道程序环境下独立运行、合法的基本单位，也就获得了OS服务的权力。</li>
</ul>
</li>
<li><strong>能实现间断运行方式</strong><ul>
<li>PCB在进程阻塞时保存和恢复CPU现场信息</li>
</ul>
</li>
<li><strong>提供进程管理所需要的信息</strong><ul>
<li>PCB记录程序和数据在内存或外存中的始址指针，找到相应的程序和数据</li>
<li>访问系统中的文件或I/O需要借助PCB的信息</li>
<li>通过PCB的资源清单可了解到该进程所需的全部资源</li>
</ul>
</li>
<li><strong>提供进程调度所需要的信息</strong><ul>
<li>PCB存储了进程状态信息（就绪与否）</li>
<li>优先级、等待时间、已执行时间、事件（阻塞原因）</li>
</ul>
</li>
<li><strong>实现与其它进程的同步和通信</strong><ul>
<li>PCB中有用于实现进程通信的区域或通信队列指针等</li>
</ul>
</li>
<li>综上：<strong>PCB是进程实体的一部分</strong>，是操作系统中最重要的<strong>记录型数据结构</strong>。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。<strong>OS通过PCB感知进程的存在，根据PCB对并发执行的进程进行控制和管理</strong>。</li>
</ul>
</li>
<li>PCB提供了进程管理和进程调度的哪些信息？<ul>
<li>提供进程管理所需要的信息<ul>
<li>PCB记录程序和数据在内存或外存中的始址指针，找到相应的程序和数据</li>
<li>访问系统中的文件或I/O需要借助PCB的信息</li>
<li>通过PCB的资源清单可了解到该进程所需的全部资源</li>
</ul>
</li>
<li>提供进程调度所需要的信息<ul>
<li>PCB存储了进程状态信息（就绪与否）</li>
<li>优先级、等待时间、已执行时间、事件（阻塞原因）</li>
</ul>
</li>
</ul>
</li>
<li>进程控制块的组织方式有哪几种？<ul>
<li><strong>线性方式</strong><ul>
<li>将系统中所有PCB组织在一张线性表中。</li>
<li>实现简单，开销小，但每次查找需要扫描整张表，适合进程数目不多的系统。</li>
</ul>
</li>
<li><strong>链接方式</strong><ul>
<li>把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。这样就可以形成就绪队列、若干阻塞队列、空闲队列等。</li>
</ul>
</li>
<li><strong>索引方式</strong><ul>
<li>系统根据所有进程的状态不同，建立几张索引表。例如，就绪索引表、阻塞索引表等。</li>
</ul>
</li>
</ul>
</li>
<li>何谓操作系统内核？内核的主要功能是什么？<ul>
<li>操作系统内核：被安排在紧靠硬件的软件层次中，将它们常驻内存的与硬件紧密相关的模块。</li>
<li>支撑功能：<ul>
<li>中断处理（OS最基本的功能）、时钟管理、原语操作</li>
</ul>
</li>
<li>资源管理功能<ul>
<li>进程管理、存储器管理、设备管理</li>
</ul>
</li>
</ul>
</li>
<li>试说明进程在三个基本状态之间转换的典型原因。<ul>
<li>就绪状态→执行状态：进程分配到CPU资源</li>
<li>执行状态→就绪状态：时间片用完</li>
<li>执行状态→阻塞状态：I/O请求</li>
<li>阻塞状态→就绪状态：I/O完成</li>
</ul>
</li>
<li>为什么要引入挂起状态？该状态有哪些性质？<ul>
<li>引入挂起状态处于五种不同的需要:终端用户需要，父进程需要，操作系统需要，对换需要和负荷调节需要。</li>
<li>处于挂起状态的进程不能接收处理机调度。</li>
</ul>
</li>
<li>在进行进程切换时，所要保存的处理机状态信息有哪些？<ul>
<li>通用寄存器，进程当前暂存信息</li>
<li>指令计数器，下一指令地址信息</li>
<li>程序状态字PSW，进程状态信息</li>
<li>用户指针栈，过程和系统调用参数及调用地址信息</li>
</ul>
</li>
<li>试说明引起进程创建的主要事件。<ul>
<li>用户登录、作业调度、提供服务、应用请求（前三者由系统内核创建，最后一个为用户进程自己创建）</li>
</ul>
</li>
<li>试说明引起进程被撤销的主要事件。<ul>
<li>正常结束、异常结束（越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障）、外界干预（操作员或操作系统干预、父进程请求、父进程终止）。</li>
</ul>
</li>
<li>在创建一个进程时所要完成的主要工作是什么？<ul>
<li>OS发现请求创建新进程事件后，调用进程创建原语Creat()<ul>
<li><strong>申请空白PCB</strong>，为新进程申请获得唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB。</li>
<li><strong>为新进程分配其运行所需的资源</strong>，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。</li>
<li><strong>初始化进程控制块</strong>(PCB)，包括：初始化标识信息、初始化处理机状态信息、初始化处理机控制信息。</li>
<li><strong>将新进程插入就绪队列</strong>，如果进程就绪队列能够接纳新进程。</li>
</ul>
</li>
</ul>
</li>
<li>在撤销一个进程时所要完成的主要工作是什么？<ul>
<li>根据被终止进程标识符，从PCB集中检索出进程PCB，读出该进程状态。</li>
<li>若被终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。</li>
<li>若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。</li>
<li>将被终止进程拥有的全部资源，归还给父进程，或归还给系统。</li>
<li>将被终止进程PCB从所在队列或列表中移出，等待其它程序搜集信息。</li>
</ul>
</li>
<li>试说明引起进程阻塞或被唤醒的主要事件是什么？<ul>
<li>向系统请求共享<strong>资源</strong>失败-阻塞，其他进程始放该资源-唤醒。</li>
<li>等待某<strong>操作</strong>（事件）完成-阻塞，操作（事件）完成-唤醒。</li>
<li>新<strong>数据</strong>尚未到达-阻塞，数据到达-唤醒。</li>
<li>等待新<strong>任务</strong>-阻塞，新任务到达-唤醒。</li>
</ul>
</li>
<li>为什么要在OS中引入线程？<ul>
<li>在操作系统中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性，提高CPU的利用率。</li>
<li>进程是分配资源的基本单位，而线程则是系统调度的基本单位。</li>
</ul>
</li>
<li>试说明线程具有哪些属性？<ul>
<li>轻型实体、<strong>独立调度和分派</strong>的基本单位、可并发执行、共享进程资源。</li>
</ul>
</li>
<li>试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。<ul>
<li><strong>调度性</strong>：线程在OS中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。</li>
<li><strong>并发性</strong>：进程可以并发执行，一个进程的多个线程也可并发执行。</li>
<li><strong>拥有资源</strong>：进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源（TCB），本身基本不拥有系统资源，但可以访问隶属进程的资源。</li>
<li><strong>系统开销</strong>：操作系统在创建、撤消和切换进程时付出的开销显著大于线程。</li>
</ul>
</li>
<li>线程控制块TCB中包含了哪些内容？<ul>
<li>线程标识符</li>
<li>一组寄存器</li>
<li>线程运行状态</li>
<li>优先级</li>
<li>线程专有存储区</li>
<li>信号屏蔽</li>
<li>堆栈指针</li>
</ul>
</li>
<li>何谓用户级线程和内核支持线程？<ul>
<li>用户级线程：仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、 线程间的同步与通信等功能，都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。</li>
<li>内核支持线程：在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、撤销和切换等都是依靠内核，在内核空间中实现的。在内核空间里还为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。</li>
</ul>
</li>
<li>试说明用户级线程的实现方法。<ul>
<li>用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中 间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。</li>
</ul>
</li>
<li>试说明内核支持线程的实现方法。<ul>
<li>系统在创建新进程时，分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。创建一个线程分配一个TCB，有关信息写入TCB，为之分配必要的资源。当PTDA中的TCB用完，而进程又有新线程时，只要所创建的线程数目未超过系统允许值，系统可 在为之分配新的TCB；在撤销一个线程时，也应回收线程的所有资源和TCB。</li>
</ul>
</li>
<li>多线程模型有哪几种类型？多对一模型有何优缺点？<ul>
<li>多对一模型<ul>
<li>优点：线程管理开销小，效率高</li>
<li>缺点：一个线程访问内核时发生阻塞，整个进程都会被阻塞；在任意时刻只有一个线程能访问内核，多个线程不能同时在多个处理机上运行。</li>
</ul>
</li>
<li>一对一模型<ul>
<li>优点：一个线程阻塞时，允许调度另一个线程运行（更好的并发功能）</li>
<li>缺点：每创建一个用户线程，相应的需要创建一个内核线程，开销较大。</li>
</ul>
</li>
<li>多对多模型<ul>
<li>优点：结合上述两模型优点</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h3><ol>
<li>高级调度与低级调度的主要任务是什么？为什么要引入中级调度？<ul>
<li>高级调度的主要任务是根据某种算法，把外存上处于后备队列中的那些<strong>作业</strong>调入内存。</li>
<li>低级调度是保存处理机的现场信息，按某种算法先取进程，再把处理器分配给<strong>进程</strong>。</li>
<li>引入中级调度的主要目的是为了<strong>提高内存利用率和系统吞吐量</strong>。配合<strong>对换技术</strong>，调度换出到磁盘的进程进入内存，准备执行。（挂起状态-&gt;就绪状态）</li>
</ul>
</li>
<li>处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？<ul>
<li>处理机调度算法的目标：<ul>
<li>资源利用率：使系统中的处理机和其他所有资源都尽可能地保持忙碌状态。</li>
<li>公平性：使每个进程都获得合理的CPU时间，不会发生进程饥饿现象。</li>
<li>平衡性：进程的类型分<strong>计算型和I/O型</strong>，为使系统中的CPU和外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。</li>
<li>策略强制执行：对所制定的的策略其中包括安全策略，只要需要，就必须以准确地执行，即使会造成某些工作地延迟也要执行。</li>
</ul>
</li>
<li>批处理系统的目标：<ul>
<li>平均周转时间短：从作业提交给系统开始，到作业完成为止地这段时间间隔短/作业数。<ul>
<li>作业在外存后备队列等待调度的时间、进程在就绪队列等待调度的时间、进程在CPU执行的时间、进程等待I/O地时间，即周转时间。</li>
</ul>
</li>
<li>系统吞吐量高：单位时间内系统所完成的作业数多。</li>
<li>处理机利用率高：CPU的利用尽量不空闲。（单纯提高利用率应该选择计算量大的作业运行，由上述可看出这些要求存在一些矛盾。）</li>
</ul>
</li>
</ul>
</li>
<li>何谓作业、作业步和作业流？<ul>
<li>作业包含通常的<strong>程序和数据</strong>，还配有作业说明书。系统根据该说明书和JCB的内容对程序的运行进行控制。<strong>批处理系统</strong>中是以<strong>作业</strong>为<strong>基本单位</strong>从外存调入内存。</li>
<li>作业步是指每个作业运行期间都必须经过若干个相对独立相互关联的顺序<strong>加工的步骤</strong>。</li>
<li>作业流是指若干个作业进入系统后依次存放在外存上形成的输入作业流；在操作系统的控制下，逐个作业进行处理，于是形成了处理作业流。</li>
</ul>
</li>
<li>在什么情况下需要使用作业控制块JCB？其中包含了哪些内容？<ul>
<li>每当作业进入系统时，系统便为每个作业建立一个作业控制块JCB，根据作业类型将它插入到相应的后备队列中。</li>
<li>JCB包含的内容通常有：(1)作业标识 (2)用户名称 (3)用户账户 (4)作业类型（CPU繁忙型、I/O芳名型、批量型、终端型）(5)作业状态 (6)调度信息（优先级、作业已运行）(7)资源要求 (8)进入系统时间 (9)开始处理时间 (10)作业完成时间 (11)作业退出时间 (12)资源使用情况等</li>
</ul>
</li>
<li>在作业调度中应如何确定接纳多少个作业和接纳哪些作业？<ul>
<li>作业调度每次接纳进入内存的作业数，取决于<strong>多道程序度</strong>。应将哪些作业从外存调入内存，取决于采用的<strong>调度算法</strong>。最简单的是先来服务调度算法，较常用的是短作业优先调度算法和基于作业优先级的调度算法。</li>
</ul>
</li>
<li>为什么要引入高响应比优先调度算法？它有何优点？<ul>
<li>在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽略了作业的运行时间，而SJF算法正好与之相反。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的算法。</li>
<li>优点：因此既照顾了短作业，又不致使长作业等待时间过长，从而改善了处理机调度的性能。</li>
<li>$优先权=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}$</li>
</ul>
</li>
<li>试说明低级调度的主要功能。<ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理机分配给进程</li>
</ul>
</li>
<li>在抢占调度方式中，抢占的原则是什么？<ul>
<li>抢占的原则有：时间片原则、优先权原则、短作业优先权原则等。</li>
</ul>
</li>
<li>在选择调度方式和调度算法时，应遵循的准则是什么？<ul>
<li>面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。</li>
<li>面向系统的准则：系统吞吐量高、处理机利用率高、各类资源的平衡利用。</li>
</ul>
</li>
<li>在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？<ul>
<li>批处理系统的调度算法：先来先服务(FCFS)、短作业优先(SJF)、优先级、高响应比优先(HRRN)、多级反馈队列调度(MFQ)算法。 分时系统的调度算法：时间片轮转法（轮转调度算法 RR）。</li>
<li>实时系统的调度算法：最早截止时间优先(EDF)、最低松弛度优先(LLF)算法。</li>
</ul>
</li>
<li>何谓静态和动态优先级？确定静态优先级的依据是什么？<ul>
<li>静态优先级是指：在创建进程时确定且在进程的整个运行期间保持不变的优先级。</li>
<li>动态优先级是指：在创建进程时赋予的优先权，可以随进程推进或随其等待时间增加而改变的优先级，可以获得更好的调度性能。</li>
<li>确定进程优先级的依据：进程类型、进程对资源的需求和用户要求</li>
</ul>
</li>
<li>试比较FCFS和SJF两种进程调度算法。<ul>
<li>相同点：两种调度算法都可以用于作业调度和进程调度。</li>
<li>不同点：FCFS调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业，将它们调入内存、分配资源、创建进程、插入到就绪队列。<strong>该算法有利于长作业/进程，不利于短作业/进程</strong>。</li>
<li>SJF算法每次调度都从后备队列中选择一个或若干个估计运行时间最短的作业，调入内存中运行。<strong>该算法有利于短作业/进程，不利于长作业/进程</strong>。</li>
</ul>
</li>
<li>在时间片轮转法中，应如何确定时间片的大小？<ul>
<li>时间片应<strong>略大于</strong>一次典型的交互需要的时间。</li>
<li>一般应考虑三个因素：系统对响应时间的要求、就绪队列中进程的数目和系统的处理能力。</li>
<li>时间片太小，会频繁执行进程调度和进程上下文切换，增加系统开销；太长，RR算法退化为FCFS算法。</li>
</ul>
</li>
<li>通过一个例子来说明通常的优先级调度算法不能适用于实时系统？<ul>
<li>实时系统的调度算法很多，主要是基于任务的开始截止时间和任务紧急/松弛程度的任务优先级调度算法，<strong>通常的优先级调度算法</strong>(需要使用抢占式优先级调度算法)不能满足实时系统的调度实时性要求而不适用。例如：火箭发射系统，紧急停止发射。</li>
</ul>
</li>
<li>为什么说多级反馈队列调度算法能较好地满足各方面用户的需求？<ul>
<li>终端型作业用户提交的作业大多属于较小的交互型作业，系统只要使这些作业在第一队列规定的时间片内完成，终端作业用户就会感到满足。</li>
<li>短批处理作业用户，开始时像终端型作业一样，如果在第一队列中执行一个时间片段即可完成，便可获得与终端作业一样的响应时间。对于稍长作业，通常只需在第二和第三队列各执行一时间片即可完成，其周转时间仍然较短。</li>
<li>长批处理作业，它将依次在第1，2，…，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</li>
<li>所以，多级反馈队列调度算法能满足多用户需求。</li>
</ul>
</li>
<li>为什么说传统的几种调度算法都不能算是公平调度算法？<ul>
<li>传统的调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作用业占用了多少处理机时间。</li>
<li>另外也为考虑到调度的公平性。</li>
</ul>
</li>
<li>保证调度算法是如何做到调度的公平性的？<ul>
<li>保证每个相同类型的进程获得相同的处理机时间。</li>
<li>记录每个进程自创建以来已执行的处理时间。</li>
<li>计算每个进程应获得的时间，自创建以来已执行的处理时间/n（n为同时运行的同类型进程数）。</li>
<li>计算进程获得处理机的比率，进程实际执行的处理时间和应获得的时间之比。</li>
<li>比较进程获得处理机的比率，选择比率最小的进程分配处理机，直到它的比率不是最小为止。</li>
</ul>
</li>
<li>公平分享调度算法又是如何做到调度的公平性的？<ul>
<li>该算法调度的公平性主要是针对用户而言，使用户获得相同的处理机时间，或所要求的时间比例。即需考虑每一个用户所拥有的进程数目。</li>
</ul>
</li>
<li>为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？<ul>
<li>实时系统中通常有着多个实时任务。若处理机的处理能力不够强，有可能因为处理机忙不过来而使某些实时任务得不到及时处理，导致发生难以预料的后果。</li>
</ul>
</li>
<li>按照调度方式可将实时调度算法分为哪几种？<ul>
<li>可分为非抢占式和抢占式两种算法。而非抢占式算法又分为非抢占式轮转和优先调度算法；抢占式调度算法又分为基于时钟中断的抢占式优先权和立即抢占式优先权调度算法。</li>
</ul>
</li>
<li>什么是最早截止时间优先调度算法？举例说明。<ul>
<li>根据任务的开始截止时间确定的任务优先级调度算法。截止时间越早则优先级越高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。 举例：非抢占式调度方式用于非周期实时任务。举例：P108</li>
</ul>
</li>
<li>什么是最低松弛度优先调度算法？举例说明之。<ul>
<li>该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高， 为该任务所赋予的优先级就愈高，以使之优先执行。举例：P109</li>
</ul>
</li>
<li>何谓“优先级倒置”现象，可以采取什么方法来解决？<ul>
<li>在OS中存在着影响进程运行的资源而产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。（低优先级进程或线程占用了某些临界资源）</li>
<li>解决方法：<ul>
<li>（1）当低优先级进程进入临界区后不允许其处理机被抢占，让其执行完自己退出临界区。但可能使高优先级进程等待时间较长。</li>
<li>（2）低优先级进程进入临界区后，继承将要执行的高优先级进程的优先级，防止优先级在这两个进程之间的进程插队。</li>
</ul>
</li>
</ul>
</li>
<li>试分别说明可重用资源和可消耗资源的性质。<ul>
<li>可重用性资源是一种可供用户重复使用多次的资源。</li>
<li>性质：<ul>
<li>每一个可重用资源中的单元只能分配给一个进程使用，不允许多进程共享。</li>
<li>进程在使用可重用资源时，必须按照这样的顺序：<ul>
<li>请求资源，失败则阻塞或循环等待。</li>
<li>使用资源，对资源进程操作。</li>
<li>释放资源，使用完成释放资源。</li>
</ul>
</li>
</ul>
</li>
<li>可消耗性资源又称为临时资源，它是在进程运行期间，由进程动态地创建和消耗。</li>
<li>性质：<ul>
<li>每一类可消耗性资源地单元数目在进程运行期间是可以不断变化的。</li>
<li>进程在运行过程中，可以不断地创造可消耗性资源地单元，将它们放入缓冲区，以增加该资源类的单元数目。</li>
<li>进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给资源类中。</li>
</ul>
</li>
</ul>
</li>
<li>试举例说明竞争不可抢占资源引起的死锁。<ul>
<li>一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</li>
<li>两个进程P1、P2准备写两个文件F1、F2；P1先打开F1，P2“同时”打开“F2；P1试图打开F2，P2试图打开F1，各自阻塞无限等待。</li>
</ul>
</li>
<li>为了破环“请求和保持”条件而提出了两种协议，试比较两种协议。<ul>
<li>第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。<ul>
<li>优点：简单、易行且安全。</li>
<li>缺点：资源被严重浪费、使进程经常会发生饥饿现象.</li>
</ul>
</li>
<li>第二种协议：对第一种协议的改进，允许一个进程只获得运行初期所需地资源后，便开始运行。进程在运行过程中再逐步释放已分配给自己、且已用毕地全部资源，然后在请求新的资源。<ul>
<li>优点：使进程更快地完成任务，提高设备利用率、减少进程发生饥饿地机率。</li>
</ul>
</li>
</ul>
</li>
<li>何谓死锁？产生死锁的原因和必要条件是什么？<ul>
<li>如果一组进程中的每一个进程都在等待仅由该进程组中的其它进程才能引发的事件，那么该组进程就是死锁。</li>
<li>产生死锁的原因为竞争资源（不可抢占资源、可消耗资源）和进程间推进顺序非法。其必要条件是：互斥条件、请求和保持条件、不可抢占条件、循环等待条件。</li>
</ul>
</li>
<li>解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？<ul>
<li>决死锁的四种方法即预防、避免、检测和解除死锁中，预防死锁最容易实现；（检测）解除死锁使资源的利用率最高，并发程度提高（对应防范程度逐渐减弱）。</li>
</ul>
</li>
<li>请详细说明可通过哪些途径预防死锁。<ul>
<li>破坏“请求和保持”条件，就是如果系统有足够资源，便一次性把进程需要的所有资源分配给它；</li>
<li>破坏“不可抢占”条件，就是已经拥有资源的进程，当它提出新资源请求而不能立即满足时，必须释放它已保持的所有资源，待以后需要时再重新申请；</li>
<li>破坏“循环等待”条件，就是将所有资源按类型排序标号，所有进程对资源的请求 必须严格按序号递增的次序提出。</li>
</ul>
</li>
</ol>
<h3 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h3><ol>
<li>为什么要配置层次式存储器？<ul>
<li>无法同时满足对存储器速度快、容量大、价格低的要求。</li>
<li>设置多个存储器可以使存储器两端的硬件能并行工作；</li>
<li>采用多级存储系统，特别是 Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案；</li>
<li>在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力。增加CPU中寄存器数量大大缓解对存储器压力。</li>
</ul>
</li>
<li>可采用哪几种方式将程序装入内存？它们分别适用于何种场合？<ul>
<li>绝对装入方式，只适用于单道程序环境。<ul>
<li>程序中的相对地址（逻辑地址）与实际内存地址完全相同。</li>
</ul>
</li>
<li>可（静态）重定位装入方式，适用于多道程序环境。<ul>
<li>不允许程序<strong>运行时</strong>在内存中移位置。（运行前可移动，但必须修改程序和数据的绝对地址。）</li>
<li>逻辑地址与实际装入内存后的物理地址不同。</li>
</ul>
</li>
<li>动态运行时装入方式，用于多道程序环境。<ul>
<li>实际情况是程序在运行时在内存中的位置可能经常需要改变（换入换出）</li>
<li>装入内存的地址仍然都是逻辑地址，在真正执行时进行地址转换（需要重定位寄存器的支持）。</li>
</ul>
</li>
</ul>
</li>
<li>何谓静态链接？静态链接时需要解决两个什么问题？<ul>
<li>静态链接是指在程序运行前，先将各目标模块及它们所需的库函数，链接成<strong>一个完整的装配模块</strong>，以后<strong>不再拆开</strong>的链接方式。</li>
<li>需要解决的问题：<ul>
<li><strong>对相对地址进行修改</strong>。<ul>
<li>各模块内部的相对地址加上对应的偏移量</li>
</ul>
</li>
<li><strong>变换外部调用符号</strong>。<ul>
<li>各模块间的外部调用符号也变换为相对地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>何谓装入时动态链接？装入时动态链接方式有何优点？<ul>
<li>装入时动态链接是指将用户源程序编译后得到的<strong>一组目标模块</strong>（分开存放），在装入内存时采用边装入边链接的链接方式。</li>
<li>优点：<ul>
<li>便于修改和更新。<ul>
<li>不需要重新打开装入模块。</li>
</ul>
</li>
<li>便于实现对目标模块的共享。<ul>
<li>对比静态链接（不能实现共享），不需要每个应用都含有其目标模块的拷贝，可以将一个模块链接到多个应用上。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>运行时的动态链接？运行时动态链接方式有何优点？<ul>
<li>运行时动态链接是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。</li>
<li>优点：<ul>
<li>加快程序装入过程、节省大量的内存空间。<ul>
<li>不需要将所有可能运行的模块全部装入内存，因为有些模块根本不会运行。</li>
<li>例如：错误处理的目标模块，若整个运行过程都不出现错误，这个模块就不会被使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？<ul>
<li>在每个分区的起始部分，设置一些控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部设置一个后向指针，通过前后向链接指针，将所有空闲分区链成一个双向链。当分区分配出去后，把状态位由“0”改为“1”。</li>
</ul>
</li>
<li>为什么要引入动态重定位？如何实现？<ul>
<li>动态可重定位分区分配（动态分区分配的改进），使用了紧凑技术，程序或数据的地址发生变化，每次紧凑都要修改地址，很麻烦且大大影响系统效率。</li>
<li>在程序执行过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，即引入了动态重定位；</li>
<li>具体实现方法是在系统中增加一个<strong>重定位寄存器</strong>，用来装入程序在内存中的起始地址， 程序执行时，真正访问的内存地址是<strong>相对地址与重定位寄存器中的地址相加之和</strong>，从而实现动态重定位。</li>
</ul>
</li>
<li>什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？<ul>
<li>指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。</li>
<li>可分为：首次适应算法（First Fit，FF）、循环首次适应算法（Next Fit，NF）、最佳适应算法（Best Fit，BT）、最坏适应算法（Worst Fit，WF）</li>
</ul>
</li>
<li>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？<ul>
<li>在采用首次适应算法回收内存时可能出现4种情况：<ul>
<li>回收区前邻空闲区。将回收区与前邻空闲区合并，将前邻空闲区大小修改为两者之和。</li>
<li>回收区后邻空闲区。将两区合并，改后邻空闲区始址为回收区始址，大小为两者之和。</li>
<li>回收区前后均邻空闲区。将三个分区合并，修改前邻空闲区大小为三者之和。</li>
<li>回收区前后均不邻空闲区。为回收区设置空闲区表项，填入回收区始址和大小并插入空闲区队列。</li>
</ul>
</li>
</ul>
</li>
<li>什么是基于索引搜索的动态分区分配算法？它可分为哪几种？<ul>
<li>基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，分区很多，采用顺序搜索分区方法可能会很慢，这时会采用基于索引的分配算法。</li>
<li>常用的有：快速适应算法（Quick Fit）、伙伴系统（Buddy System）、哈希算法。</li>
</ul>
</li>
<li>伙伴系统表达式计算<ul>
<li>略（P141）</li>
</ul>
</li>
<li>分区存储管理中常用那些分配策略？比较它们的优缺点。<ul>
<li>分区存储管理中的常用分配策略：<strong>首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法</strong>。</li>
<li>首次适应算法优缺点：<ul>
<li>保留了高址部分的大空闲区，有利于后来的大型作业分配。</li>
<li>低址部分不断被划分，留下许多难以利用的小空闲区，每次查找都从低址开始增加了系统开销。</li>
</ul>
</li>
<li>循环首次适应算法优缺点：<ul>
<li>内存空闲分区分布均匀，减少了查找系统开销。</li>
<li>缺乏大空闲分区，导致不能装入大型作业。</li>
</ul>
</li>
<li>最佳适应算法优缺点：<ul>
<li>每次分配给文件的都是最适合该文件大小的分区。</li>
<li>内存中留下许多难以利用的小空闲区。</li>
</ul>
</li>
<li>最坏适应算法优缺点：<ul>
<li>剩下空闲区不太小，产生碎片几率小，对中小型作业分配分区操作有利。</li>
<li>存储器中缺乏大空闲区，对大型作业分区分配不利。</li>
</ul>
</li>
</ul>
</li>
<li>为什么要引入对换？对换可分为哪几种类型？<ul>
<li>最早用于用于麻省理工单用户分时系统CTSS，由于当时计算机内存非常小，为了使该系统能分时运行多个用户程序而引入。</li>
<li>两方面原因：<ul>
<li>一方面，多道程序环境下，内存中存在某些进程由于某事件未发生而被阻塞运行，占用了大量内存空间。</li>
<li>另一方面，外存中又有许多作业，因内存空间不足而不能进入内存运行。</li>
<li>这是对系统资源的严重浪费，且使系统吞吐量下降。</li>
</ul>
</li>
<li>对换类型：<ul>
<li>整体对换：以整个进程为单位的对换，又称“进程对换”。</li>
<li>页面(分段)对换：以进程的一个页面或分段为单位的对换，又称“部分对换”。</li>
</ul>
</li>
</ul>
</li>
<li>对文件区管理的目标和对对换空间管理的目标有何不同？<ul>
<li>在具有对换功能的OS中，通常把磁盘空间分为<strong>文件区和对换区</strong>两部分。</li>
<li>对文件区管理的主要目标：提高文件的空间利用率，然后才是提高对文件的访问速度。因此，采取离散分配的方式。</li>
<li>对对换空间管理的主要目标：提高进程换入换出的速度，然后才是提高文件存储空间的利用率。为此，采取连续分配方式，较少考虑外存中的碎片问题。</li>
</ul>
</li>
<li>为实现对换，系统应具备哪几方面的功能？<ul>
<li>系统应具备三方面功能：对换空间管理、进程换出、进程换入。</li>
</ul>
</li>
<li>在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？<ul>
<li>并非每次将整个进程换出</li>
<li>原因：<ul>
<li>从结构上讲，进程是由程序段、数据段和进程控制块PCB组成的，其中进程控制块总有部分或全部常驻内存，不被换出。</li>
<li>程序段和数据段可能正被若干进程共享，此时它们也不能被换出。</li>
</ul>
</li>
</ul>
</li>
<li>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？<ul>
<li>分页存储管理方式、分段存储管理方式、段页式存储管理方式。</li>
</ul>
</li>
<li>.什么是页面?什么是物理块?页面的大小应如何确定？<ul>
<li>页面：分页存储管理将<strong>进程</strong>的<strong>逻辑地址空间</strong>分成若干个页，并为各页加以编号。</li>
<li>物理块：把<strong>内存</strong>的<strong>物理地址空间</strong>分成若干个块，并为各块加以编号。</li>
<li>页面大小应选择适中，且页面大小应该是2的幂，通常为1KB~8KB。</li>
</ul>
</li>
<li>什么是页表？页表的作用是什么？<ul>
<li>页表是分页式存储管理使用的数据结构。一个进程分为多少页，它的页表就有多少行。每一行记录进程的一页页号和它存放的物理块的块号对应关系。</li>
<li>作用：页表用于进行地址变换，即实现页号到物理块号的地址映射。</li>
</ul>
</li>
<li>为实现分页存储管理，需要哪些硬件的支持？<ul>
<li>页表寄存器PTR</li>
<li>地址变换机构<ul>
<li>基本的地址变换机构</li>
<li>具有快表（高速缓冲寄存器或称联想寄存器）的地址变换机构</li>
</ul>
</li>
</ul>
</li>
<li>在分页系统中是如何实现地址变换的？<ul>
<li>利用地址变换机构实现从逻辑地址到物理地址的转变换，通过页表来实现从页号到物理块号的变换，将逻辑地址中的页号转换为内存中的物理块号。</li>
</ul>
</li>
<li>具有快表时是如何实现地址变换的？<ul>
<li>在CPU给出有效地址后，由地址变换机构自动将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号比较。</li>
<li>若找到匹配页号，表示要访问的页表项在快表中。可直接从快表读出该页对应物理块号，送到物理地址寄存器中。</li>
<li>如快表中没有对应页表项，则再访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页表项存入快表。</li>
</ul>
</li>
<li>较详细的说明引入分段存储管理方式是为了满足用户哪几个方面的需求。<ul>
<li><strong>方便编程</strong>。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定</li>
<li><strong>信息共享</strong>。在实现对程序和数据的共享时，是以信息逻辑单位为基础。<ul>
<li>分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适</li>
</ul>
</li>
<li><strong>信息保护</strong>。对信息的逻辑单位进行保护（标上标记即可），分段能更有效方便地实现信息保护功能。</li>
<li><strong>动态增长</strong>。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题</li>
<li><strong>动态链接</strong>。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。</li>
</ul>
</li>
<li>在具有快表的段页式存储管理方式中，如何实现地址变换?<ul>
<li>类似第22题</li>
</ul>
</li>
<li>为什么说分段系统较之分页系统更易于实现信息共享和保护？<ul>
<li>对于分页系统，每个页面是分散存储的，为了实现信息共享和保护，则页面之间需要一一对应起来，为此需要建立大量的页表项；</li>
<li>而对于分段系统，每个段都从0开始编址，并采用一段连续的地址空间，这样在实现共享和保护时，只需为所要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应起来即可。</li>
</ul>
</li>
<li>分页和分段有何区别?<ul>
<li>分页和分段都采用离散分配的方式，且都要通过地址映射机构来实现地址变换，这是它们的共同点；</li>
<li>对于它们的不同点有三：<ul>
<li>第一，从功能上看，页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率，即满足系统管理的需要，而不是用户的需要；而段是信息的逻辑单位，它含有一组其意义相对完整的信息，目的是为了能更好地满足用户的需要；</li>
<li>第二，页的大小固定且由系统确定，而段的长度却不固定，决定于用户所编写的程序；</li>
<li>第三分页的作业地址空间是一维的，而分段的作业地址空间是二维的。</li>
</ul>
</li>
</ul>
</li>
<li>试全面比较连续分配和离散分配方式<ul>
<li>连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单，只用于单用户单任务操作系统；分区方式分固定和动态分区。</li>
<li>离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段式存储管理旨在满足用户(程序员)的需要，段页式存储管理则将两者结合起来，具有分段系统便于实现、可共享、易于保护和动态链接等优点，又能像分页系统很好解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式；</li>
</ul>
</li>
</ol>
<h3 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h3><ol>
<li><p>常规存储器管理方式具有哪两大特征？它对系统性能有何影响？</p>
<ul>
<li>一次性：进程（作业）必须<strong>一次性地全部装入内存</strong>，对空间浪费非常大；</li>
<li>驻留性：在程序<strong>运行过程中</strong>，进程（作业）全部<strong>驻留在内存</strong>，暂时不用的数据无法释放，占用内存资源。</li>
</ul>
</li>
<li><p>什么是程序运行时的时间局限性和空间局限性？</p>
<ul>
<li>时间局限性：<ul>
<li>如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久的将来<strong>该存储单元</strong>可能再次被访问。</li>
<li>产生时间局限性的典型原因是在程序中存在着大量的循环操作。</li>
</ul>
</li>
<li>空间局限性：<ul>
<li>一旦程序访问了某个存储单元，则在不久的将来，其<strong>附近的存储单元</strong>也最有可能被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围内。</li>
<li>产生空间局限性的典型原因是程序是顺序执行的。</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟存储器有哪些特征？其中最本质的特征是什么？</p>
<ul>
<li>虚拟存储器有<strong>多次性、对换性、虚拟性</strong>三大特征。</li>
<li><strong>多次性</strong>：多次性是相对于传统存储器管理方式而言地，是指一个作业中地程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行，即只需将当前要运行地那部分程序和数据装入内存即可开始运行。</li>
<li><strong>对换性</strong>：对换性是相对于传统存储器管理方式的常驻性而言，是指一个作业中的程序和数据，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出。</li>
<li><strong>虚拟性</strong>：虚拟性是指能够从逻辑上扩充内存容量，使用户看到的内存内容远大于实际内存容量。</li>
<li>最本质的特征是<strong>虚拟性</strong>。</li>
</ul>
</li>
<li><p>实现虚拟存储器需要哪些硬件支持?</p>
<ul>
<li>请求分页（段）的页（段）表机制。</li>
<li>缺页（段）中断机构。</li>
<li>地址变换机构。</li>
</ul>
</li>
<li><p>实现虚拟存储器需要哪几个关键技术?</p>
<ul>
<li>在分页请求系统中是在分页的基础上，增加了<strong>请求调页功能和页面置换功能</strong>所形成的页式虚拟存储系统。允许只装入少数页面的程序（及数据），即可启动运行。</li>
<li>在请求分段系统中是在分段系统的基础上，增加了<strong>请求调段及分段置换功能</strong>后形成的段式虚拟存储系统。允许只装入少数段（而非所有段）的用户程序和数据，即可启动运行。</li>
</ul>
</li>
<li><p>在请求分页系统中，页表应包括哪些数据项？每项的作用是什么?</p>
<ul>
<li>页表应包括：<strong>页号、物理块号、状态位P、访问字段A、修改位M和外存地址</strong>。</li>
<li>其中状态位P指示该页<strong>是否调入内存</strong>，供程序访问时参考；</li>
<li>访问字段A用于记录本页在一段时间内<strong>被访问的次数</strong>，或最近<strong>己有多长时间未被访问</strong>，提供给置换算法选择换出页面时参考；</li>
<li>修改位M表示该页在调入内存后<strong>是否被修改过</strong>；</li>
<li>外存地址用于指出<strong>该页在外存上的地址</strong>，通常是物理块号，供调入该页时使用。</li>
</ul>
</li>
<li><p>试比较缺页中断机构与一般的中断，它们之间有何明显的区别？</p>
<ul>
<li>一般中断只需要保护现场然后就直接跳到需及时处理的地方。</li>
<li>缺页中断除了保护现场之外，还要判断内存中是否有足够的空间存储所需的页或段，然后再把所需页调进来再使用。</li>
</ul>
</li>
<li><p>试说明请求分页系统中的地址变换过程。<br><img src="https://pic.zty.plus/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.jpg" alt="请求分页地址变换"></p>
<ul>
<li>取逻辑地址分解为页号P和页内偏移w；</li>
<li>根据页号查找页表，获得该页的描述信息；</li>
<li>若该页中断位为1，产生缺页中断；　　</li>
<li>更新该页的描述信息；</li>
<li>根据页块号和页内偏移w，计算物理地址。</li>
<li>P170</li>
</ul>
</li>
<li><p>何谓固定分配局部置换和可变分配全局置换的内存分配策略?</p>
<ul>
<li>固定分配局部置换：<ul>
<li>固定分配是指，为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。</li>
<li>局部置换是指，如果进程在运行中发现缺页，则只能从分配给<strong>该进程的</strong>n个页面中，选出一页换出，然后再调入一页。</li>
</ul>
</li>
<li>可变分配全局置换：<ul>
<li>可变分配是指，先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地改变。</li>
<li>全局置换是指，如果进程在运行中发现缺页，则将<strong>OS所保留的空闲物理块</strong>或者以<strong>所有进程的全部物理块为标的</strong>，选择一块换出，然后将所缺之页调入。</li>
</ul>
</li>
</ul>
</li>
<li><p>在请求分页系统中，应从何处将所需页面调入内存？</p>
<ul>
<li>请求分页系统中的缺页从何处调入内存分三种情况：<ul>
<li><strong>系统拥有足够对换区空间时</strong>，可以全部从对换区调入所需页面，提高调页速度。在进程运行前将与该进程有关的文件从文件区拷贝到对换区。</li>
<li><strong>系统缺少足够对换区空间时</strong>，不被修改的文件直接从文件区调入，当换出这些页面时，未被修改的不必换出，再调入时，仍从文件区直接调入。对于可能修改的，在换出时便调到对换区，以后需要时再从对换区调入。</li>
<li><strong>UNIX方式</strong>。未运行页面从文件区调入。曾经运行过但被换出页面，下次从对换区调入。UNIX系统允许页面共享，某进程请求的页面有可能已调入内存，直接使用不再调入。</li>
</ul>
</li>
</ul>
</li>
<li><p>试说明在请求分页系统中页面的调入过程。</p>
<ul>
<li>每当程序所要访问的页面未在内存时（存在位为“0”），便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。</li>
<li>该程序通过查找页表，得到该页在外存的物理块后：<ul>
<li>如果此时内存能容纳新页，则启动磁盘I/O，将所缺之页调入内存，然后修改页表。</li>
<li>如果内存已满，则须先按照某种置换算法，从内存中选出一页准备换出；<ul>
<li>如果该页未被修改过（修改位为“0”），可不必将该页写回磁盘；</li>
<li>但如果此页已被修改（修改位为“1”），则必须将它写回磁盘，然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中。</li>
</ul>
</li>
</ul>
</li>
<li>在缺页调入内存后，利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据。整个页面的调入过程对用户是透明的。</li>
</ul>
</li>
<li><p>在请求分页系统中，常采用哪几种页面置换算法？</p>
<ul>
<li>采用的页面置换算法有：<ul>
<li>最佳（Optimal）置换算法和先进先出（FIFO）置换算法，最近最久未使用（LRU）置换算法，最少使用（LFU）置换算法，Clock置换算法，页面缓冲算法（PBA）等。</li>
</ul>
</li>
</ul>
</li>
<li><p>在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。</p>
<ul>
<li>M=3时，采用FIFO页面置换算法的缺页次数为9次，缺页率为75%；</li>
<li>M=4时，采用FIFO页面置换算法的缺页次数为10次，缺页率为83%。</li>
<li>增加分配给作业的内存块数，反而增加了缺页次数，提高了缺页率，这种现象被称为是Belady现象。</li>
</ul>
</li>
<li><p>实现LRU算法所需的硬件支持是什么？</p>
<ul>
<li>需要寄存器和栈两类硬件之一的支持。<ul>
<li>寄存器：<ul>
<li>给在内存中的每个页配置移位寄存器，当进程访问某物理块时，将相应寄存器的Rn-1位置1，此时，定时每隔一定时间将寄存器右移一位。最小数值对应的页面就是最近最久未使用的页面。</li>
</ul>
</li>
<li>栈：<ul>
<li>利用一个特殊栈保存当前使用的各页面的页面号，每当进程访问某页面时将该页面的页面号从栈中移出，将它压入栈顶。因此栈顶始终时最新被访问的页面的编号，栈底则是最近最久未使用的页面的页面号。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>试说明改进型Clock置换算法的基本原理。</p>
<ul>
<li>因为修改过的页面在换出时付出的开销比未被修改过的页面大，在改进型Clock算法中，既考虑页面的使用情况，还要增加<strong>置换代价</strong>的因素；在选择页面作为淘汰页面时，把同时满足<strong>未使用过</strong>和<strong>未被修改</strong>作为首选淘汰页面。</li>
</ul>
</li>
<li><p>影响页面换进换出效率的若干因素是什么？</p>
<ul>
<li><strong>页面置换算法</strong>：影响页面换进换出效率最重要的因素，直接影响进程在运行过程中的缺页率，影响页面换进换出的开销。</li>
<li><strong>写回磁盘的频率</strong>：如果是采取每个页面换出时，就将它写回磁盘的策略，这意味着每换出一个页面，便需要启动一次磁盘。但如果在系统中建立了一个已修改换出页面链表，对每一个要被换出的页面（已修改），系统可暂不把它们写回磁盘，而是将它们挂在已修改换出页面链表上，仅当被换出页面数目达到一定值时，再将它们一起写回到磁盘上，这样就显著地<strong><em>减少了磁盘I/O的操作次数</em></strong>。或者说，减少已修改页面换出的开销。</li>
<li><strong>读入内存的频率</strong>：在设置了已修改换出页面链表后，在该链表上就暂时有一批装有数据的页面，如果需要再次访问这些页面时，就不需从外存上调入，而直接从已修改换出页面链表中获取，这样也可以<strong><em>减少将页面从磁盘读入内存的频率</em></strong>，减少页面换进的开销。或者说，只需花费很小的开销，便可使这些页面，又回到该进程的驻留集中。</li>
</ul>
</li>
<li><p>页面缓冲算法的主要特点是什么？它是如何降低页面换进换出的频率的？</p>
<ul>
<li>显著地降低了页面换进、换出的频率，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销；</li>
<li>由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如先进先出（FIFO）算法，它不需要特殊硬件的支持，实现起来非常简单。</li>
<li>在该系统中，内存分配策略上采用了<strong>可变分配</strong>和<strong>局部置换方式</strong>。<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mahuangping/p/5468577.html">请求分页中的内存分配方式</a></li>
</ul>
</li>
<li>为了能显著地降低了页面换进、换出的频率，在内存中设置了如下两个链表：<ul>
<li><strong>空闲页面链表</strong>：是一个空闲物理块链表，用于分配给频繁发生缺页的进程，以降低该进程的缺页率。当有一个未被修改的页要换出时，实际上并不将它换出到外存，而是把它们所在的物理块，挂在空闲链表的末尾。</li>
<li><strong>修改页面链表</strong>：由已修改的页面所形成的链表。设置该链表的目的，是为了减少已修改页面换出的次数。降低将已修该页面写回磁盘的频率，以及降低将磁盘内容读入内存的频率。</li>
</ul>
</li>
</ul>
</li>
<li><p>在请求分页系统中产生抖动的原因是什么？</p>
<ul>
<li><strong>抖动（Thrashing)</strong> ：<ul>
<li>指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页程序或数据送磁盘的对换区中，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此<strong>频繁更换页面</strong>，使得<strong>系统把大部分时间用在了页面的调进换出上</strong>，而几乎不能完成任何有效的工作，我们称这种现象为”抖动”。</li>
</ul>
</li>
<li>产生抖动的原因：<ul>
<li><strong>CPU的利用率和多道程序度的对立统一矛盾关系</strong>，为了提高CPU利用率，可提高多道程序度，但单纯提高多道程序度又会造成缺页率的急剧上升，导致CPU的利用率下降，而系统的调度程序又会为了提高CPU利用率而继续提高多道程序度，形成恶性循环，我们称这时的进程是处于”抖动”状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>何谓工作集？它是基于什么原理确定的？</p>
<ul>
<li>工作集:<ul>
<li><strong>某段时间间隔内，进程要访问的页面集合</strong>。</li>
<li>工作集可用于指导驻留集大小。</li>
</ul>
</li>
<li>驻留集：<ul>
<li><strong>进程已装入内存的页面的集合</strong>，与系统采用的页面装入和页面置换算法有关。</li>
<li>经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。为了防止系统出现抖动现象，需要选择合适的驻留集体大小。</li>
<li>驻留集尺寸：<ul>
<li>进程驻留在内存中的页面数量，与系统采用的页面分配策略有关。</li>
</ul>
</li>
</ul>
</li>
<li>工作集模型的原理：<ul>
<li>让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。</li>
<li>如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</li>
<li>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</li>
</ul>
</li>
<li>不同提法：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43101637/article/details/106672208">工作集≠驻留集</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gettogetto/article/details/56005716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">工作集=驻留集</a></li>
</ul>
</li>
</ul>
</li>
<li><p>当前可以利用哪几种方法来防止“抖动”？</p>
<ul>
<li>采取局部置换策略<ul>
<li>将”抖动”影响限制在较小范围内，但效果不太好，”抖动“发生后该进程会长期在磁盘I/O的等待队列中，还是会延长其它进程的缺页中断处理时间。</li>
</ul>
</li>
<li>把工作集算法融入到处理机调度中<ul>
<li>调入新作业前，必须检查每个进程在内存驻留的页面是否足够多。若是则可调入，若不是则应首先增加缺页率居高的作业的物理块。</li>
</ul>
</li>
<li>利用“L=S”准则调节缺页率<ul>
<li>L：缺页之间的平均时间，S：平均缺页服务时间（置换一个页面所需的时间）。</li>
<li>L远大于S：很少缺页，磁盘能力未得到充分利用；S大于L：频繁缺页，缺页速度超过磁盘处理能力；L=S：磁盘和处理机达到最大利用率。</li>
</ul>
</li>
<li>选择暂停的进程<ul>
<li>多道程序度偏高时，影响处理机利用率，为防止发生”抖动“，系统必须减少多道程序的数目。</li>
</ul>
</li>
</ul>
</li>
<li><p>试试说明如何利用“L=S”准则来调节缺页率，以避免“抖动”的发生?</p>
<ul>
<li>L：缺页之间的平均时间，S：平均缺页服务时间（置换一个页面所需的时间）。</li>
<li>L远大于S：很少缺页，磁盘能力未得到充分利用；S大于L：频繁缺页，缺页速度超过磁盘处理能力；L=S：磁盘和处理机达到最大利用率。</li>
</ul>
</li>
<li><p>为了实现请求分段式存储管理，应在系统中增加配置哪些硬件结构？</p>
<ul>
<li>请求段表机制、缺段中断机制和地址变换机构。</li>
</ul>
</li>
<li><p>在请求段表机制中，应设置哪些段表项？<br>| 段名 | 段长 | 段基址 | 存取方式 | 访问字段A | 修改位M | 存在位P | 增补位 | 外存始址 |<br>| —— | —— | ——— | ———— | ————- | ———- | ———- | ——— | ———— |</p>
</li>
<li><p>说明请求分段系统中的缺页中断处理过程。</p>
<ul>
<li><img src="https://pic.zty.plus/%E7%BC%BA%E6%AE%B5%E4%B8%AD%E6%96%AD.png" alt="缺段中断"></li>
</ul>
</li>
<li><p>请对共享段表中的各项作简要说明。</p>
<ul>
<li><img src="https://pic.zty.plus/%E5%85%B1%E4%BA%AB%E6%AE%B5%E8%A1%A8%E9%A1%B9.png" alt="共享段表项"></li>
<li>共享进程计数器count：<ul>
<li>记录有多少进程正在共享该分段，当某进程不再需要它时，检查是否为0，从而决定系统是否回收该段所占的内存区。</li>
</ul>
</li>
<li>存取控制字段：<ul>
<li>为不同进程赋予不同的存取权限（读写）。</li>
</ul>
</li>
<li>段号：<ul>
<li>对于一个共享段，在不同的进程中可以具有不同的段号，每个进程可用自己的段号去访问该共享段。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何实现共享分段的分配和回收?</p>
<ul>
<li>共享段的分配：<ul>
<li>在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，当又有其它进程需要调用该共享段时，无须再为该段分配内存。</li>
</ul>
</li>
<li>共享段的回收：<ul>
<li>当共享此段的某进程不再需要该段时，若无其他进程使用该段，则由系统回收该共享段的物理内存，否则只是取消调用者进程在共享段表中的有关记录。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h3><ol>
<li><p>试说明I/O系统的基本功能。</p>
<ul>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
<li>提高处理机和I/O设备的利用率</li>
<li>对I/O设备进行控制e.确保对设备的正确共享</li>
<li>错误处理</li>
</ul>
</li>
<li><p>简要说明I/O软件的4个层次的基本功能。</p>
<ul>
<li><strong>中断处理程序：</strong><ul>
<li>用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后恢复现场，并返回到被中断的进程。</li>
</ul>
</li>
<li><strong>设备驱动程序：</strong><ul>
<li>与硬件直接有关，用来具体实现系统对设备发出的操作指令，驱动I/O设备工作。</li>
</ul>
</li>
<li><strong>设备独立性软件：</strong><ul>
<li>用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等。</li>
</ul>
</li>
<li><strong>用户层I/O软件：</strong><ul>
<li>用于实现用户与I/O设备交互。</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O系统接口与软件/硬件（RW/HW）接口分别是什么接口?</p>
<ul>
<li><strong>I/O系统接口：</strong><ul>
<li>I/O系统接口是I/O系统与<strong>上层系统</strong>之间的接口，向上层提供对设备进行操作的抽象I/O命令，以<strong>方便高层对设备的使用</strong>。</li>
</ul>
</li>
<li><strong>软件/硬件（RW/HW）接口：</strong><ul>
<li>软件/硬件（RW/HW）接口的上面是<strong>中断处理程序</strong>和用于不同设备的<strong>设备驱动程序</strong>，它的下面是各种<strong>设备的控制器</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>与设备无关性的基本含义是什么？为什么要设置该层？</p>
<ul>
<li>基本含义：<ul>
<li>应用程序独立于具体使用的物理设备。</li>
<li>为了实现设备独立性而引入了逻辑设备和物理设备两概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，还必须使用物理设备名称。</li>
</ul>
</li>
<li>设置原因：<ul>
<li>为了提高0S的可适应性和可扩展性，在现代0S中都毫无例外地实现了设备独立性，也称设备无关性。</li>
</ul>
</li>
<li>优点：<ul>
<li>增加了设备分配时的灵活性。</li>
<li>易于实现I/O重定向（用于I/O操作的设备可以更换（即重定向），而不必改变应用程序。</li>
</ul>
</li>
</ul>
</li>
<li><p>试说明设备控制器的组成。</p>
<ul>
<li>设备控制器与处理机的接口；</li>
<li>设备控制器与设备的接口；</li>
<li>I/O逻辑。</li>
</ul>
</li>
<li><p>为了实现CPU与设备控制器之间的通信，设备控制器应该具备哪些功能?</p>
<ul>
<li>基本功能：接收和识别命令；数据交换；标识和报告设备的状态；地址识别；数据缓冲；差错控制。</li>
</ul>
</li>
<li><p>什么是内存映像I/O？它是如何实现的？</p>
<ul>
<li>驱动程序将抽象I/O命令转换出的一系列具体的命令、参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的控制。这一工作可用两种方法来完成：利用特定的I/O指令、内存I/O映像。</li>
<li>内存映像I/O：<ul>
<li>在编址上<strong>不再区分</strong>内存单元地址和设备控制器中的寄存器地址，都采用k。当k值处于0~n-1范围时，被认为是内存地址，若k≥n时，被认为是某个控制器的寄存器地址。</li>
<li>内存映像I/O方式统一了对内存和对控制器的访问方法，简化了I/O的编程。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么说中断是0S赖以生存的基础？</p>
<ul>
<li>中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，没有中断，就不可能实现多道程序，因为<strong>进程之间的切换是通过中断来完成的</strong>。</li>
<li>另一方面，中断也是<strong>设备管理的基础</strong>，为了提高处理机的利用率和实现CPU和I/O设备并执行，也必需有中断的支持。中断处理程序是I/O系统中最低的一层。</li>
</ul>
</li>
<li><p>对中断源的两种处理方式分别用于那种场合？</p>
<ul>
<li>屏蔽（禁止)中断：<ul>
<li>当处理机正在处理一个中断时，将屏蔽掉所有的中断，直到处理机已处理完本次中断，再去检查是否有中断产生。所有中断按顺序处理，优点是简单，但不能用于实时性要求较高的中断请求。</li>
</ul>
</li>
<li>嵌套中断：<ul>
<li>在设置了中断优先级的系统中，当同时有多个不同优先级的中断请求，CPU优先响应优先级最高的中断请求，高优先级的中断请求可以抢占正在运行的低优先级中断的处理机。</li>
</ul>
</li>
</ul>
</li>
<li><p>设备中断处理程序通常需完成哪些工作？</p>
<ul>
<li>唤醒被阻塞的驱动进程。</li>
<li>保护被中断进程的CPU环境。</li>
<li>转入相应的设备处理程序。</li>
<li>中断处理。</li>
<li>恢复被中断进程的现场。</li>
</ul>
</li>
<li><p>简要说明中断处理程序对中断进行处理的几个步骤。</p>
<ul>
<li>测定是否有未响应的中断信号</li>
<li>唤醒被阻塞的驱动进程。</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断</li>
</ul>
</li>
<li><p>试说明设备驱动程序具有哪些特点。</p>
<ul>
<li>驱动程序是请求I/O进程（与设备无关的软件）与设备控制器间的一个通信和转换程序。</li>
<li>驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，不同类型的设备应配置不同的驱动程序。</li>
<li>驱动程序与I/O设备采用的控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。</li>
<li>由于驱动程序与硬件紧密相关，部分程序必须用汇编语言书写，很多驱动程序的基本部分往往固化在ROM中。</li>
<li>驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。</li>
</ul>
</li>
<li><p>设备驱动程序通常需要完成哪些工作？</p>
<ul>
<li>接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。</li>
<li>检查用户I/O请求合法性，了解I/O设备状态，传递有关参数，设置设备工作方式。</li>
<li>发出I/O命令，如果设备空闲，便启动分配到的I/O设备，完成指定I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。</li>
<li>及时响应由控制器或通道发来的中断请求，根据中断类型调用相应中断处理程序处理。</li>
<li>对于有通道的计算机，驱动程序还应该根据用户I/O请求自动构成通道程序。</li>
</ul>
</li>
<li><p>简要说明设备驱动程序的处理过程可分为哪几步。</p>
<ul>
<li>将抽象要求转换为具体要求</li>
<li>对服务请求进行校验</li>
<li>检查设备的状态</li>
<li>传送必要的参数</li>
<li>启动I/O设备</li>
</ul>
</li>
<li><p>试说明I/O控制发展的主要推动因素是什么？</p>
<ul>
<li>尽量减少CPU对I/O控制的干预，把CPU从繁杂的I/O控制中解脱出来，以便更多地去完成数据处理任务。</li>
<li>缓和CPU的高速性和设备的低速性之间速度不匹配的矛盾，以提高CPU的利用率和系统的吞吐量。</li>
<li>提高CPU和I/O设备操作的并行程度，使CPU和I/O设备都处于忙碌状态，从而提高整个系统的资源利用率和系统吞吐量。</li>
</ul>
</li>
<li><p>有哪几种I/O控制方式？各适用于何种场合？</p>
<ul>
<li><strong>程序 I/O 方式、中断驱动 I/O 控制方式、DMA I/O 控制方式、I/O 通道控制方式</strong>。</li>
<li><strong>程序 I/O 方式（使用轮询的可编程 I/O 方式）</strong>，以字（符）为单位进行I/O，适用于早期的计算机系统中，并且是无中断的计算机系统。</li>
<li><strong>中断驱动 I/O 控制方式（使用中断的可编程 I/O 方式）</strong>，以字（节）为单位进行I/O，是普遍用于现代的计算机系统中。</li>
<li><strong>DMA I/O 控制方式（直接存储器访问方式）</strong>，数据传输基本单位是<strong>数据块</strong>，适用于I/O设备为块设备时在和主机进行数据交换的一种I/O控制方式。</li>
<li>当I/O设备和主机进行数据交换是<strong>一组数据块</strong>时通常采用<strong>I/O通道控制方式</strong>（DMA方式的发展），但此时要求系统必须配置相应的通道及通道控制器。</li>
</ul>
</li>
<li><p>试说明DMA的工作流程。</p>
<ul>
<li>DMA是Direct Memory Access的缩写，意为存储器直接访问。可以不通过CPU而在DMA控制器的控制下，高速地与I/O设备和存储器之间交换数据。</li>
<li>CPU需要访问外存时便发送一条访问命令给DMA的<strong>命令寄存器CR</strong>、一个内存地址码给DMA的内存<strong>地址寄存器MAR</strong>、本次要传送的字（节）数给DMA的<strong>数据计数器DC</strong>、外存地址给DMA的<strong>I/O控制逻辑</strong>。</li>
<li>CPU启动DMA控制器后转向其他处理。</li>
<li>DMA控制器负责控制数据在内存与外设之间传送。每传送一个字（节）就需挪用一个存储器周期，按MAR从内存读出或写入内存一个字（节），修改MAR和计算器DC。</li>
<li>当DC修改为0时，表示传送结束，由DMA向CPU发出中断请求。<br><img src="https://pic.zty.plus/DMA%E6%B5%81%E7%A8%8B.png" alt="DMA流程"></li>
</ul>
</li>
<li><p>为什么要引入与设备的无关性?如何实现设备的独立性？</p>
<ul>
<li>设备无关性（独立性）的基本含义是应用程序独立于具体使用的物理设备，应用程序以逻辑设备名请求使用某类设备。</li>
<li>引入原因：<ul>
<li>为了方便用户和提高OS的可适应性与可扩展性。</li>
<li>实现了设备独立性功能可带来两方面的好处：<ul>
<li>设备分配时的灵活性。</li>
<li>易于实现I/O重定向。</li>
</ul>
</li>
</ul>
</li>
<li>如何实现：<ul>
<li>为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中，使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件，必须在驱动程序之上设置一层<strong>设备独立性软件</strong>，执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件<strong>提供统一接口</strong>，从而实现设备的独立性。</li>
</ul>
</li>
</ul>
</li>
<li><p>与设备的无关的软件中，包括了哪些公有操作的软件?</p>
<ul>
<li>设备驱动程序的统一接口</li>
<li>缓冲管理</li>
<li>差错控制</li>
<li>对独立设备的分配与回收</li>
<li>独立于设备的逻辑数据块</li>
</ul>
</li>
<li><p>在考虑到设备的独立性时，应如何分配独占设备？</p>
<ul>
<li>进程以逻辑设备名提出I/O请求。</li>
<li>根据逻辑设备表获得I/O请求的逻辑设备对应物理设备在系统设备表中的指针。</li>
<li>检索系统设备表，找到属于请求类型、空闲可用且分配安全设备的设备控制表，将对应设备分配给请求进程。如果未找到安全可用的空闲设备，则把请求进程的进程控制块挂到相应类型设备的等待队列上等待唤醒和分配。</li>
<li>到设备控制表中找出与其相连接的控制器的控制器控制表，根据状态字段判断是否忙 碌，忙则等待；否则将该控制器分配给进程。</li>
<li>到该控制器的控制器控制表中找出与其相连接的通道的通道控制表，判断通道是否忙 碌，忙则等待；否则将该通道分配给进程。</li>
<li>只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功，然后便可启 动设备进行数据传送。</li>
</ul>
</li>
<li><p>何谓设备虚拟？实现设备虚拟式所依赖的关键技术是什么？</p>
<ul>
<li>通过虚拟技术可将一台独占设备变换成若干台逻辑设备，供若干个用户（进程）同时使用，通常把这种经过虚拟技术处理后的设备称为虚拟设备。</li>
<li>其实现所依赖的关键技术是SPOOLING技术。</li>
</ul>
</li>
<li><p>在实现后台打印时，SPOOLing 系统应为请求I/O的进程提供哪些服务？</p>
<ul>
<li>由输出进程在输出井中为之申请一空闲盘块区，并将要打印的数据送入其中；</li>
<li>输出进程再为用户进程申请一张空白的用户打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。</li>
<li>一旦打印机空闲，输出进程便从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据从输出井传送到内存缓冲区，再由打印机进行打印。</li>
</ul>
</li>
<li><p>假脱机系统向用户提供共享打印机的基本思想是什么？</p>
<ul>
<li>对每个用户而言，系统并非及时执行其程序输出数据的真实打印操作，而只是即时将数据输出到缓冲区，这时的数据并未真正被打印，只是让用户感觉系统已为他打印；</li>
<li>真正的打印操作，是在打印机空闲且该打印任务在等待队列中已排到队首时进行的；以上过程是对用户屏蔽的，用户是不可见的。</li>
</ul>
</li>
<li><p>引入缓冲的主要原因是什么？</p>
<ul>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾；</li>
<li>减少对CPU的中断频率，放宽对中断响应时间的限制；</li>
<li>解决数据粒度（数据单元大小）不匹配的问题；</li>
<li>提高CPU和I/O设备之间的并行性。</li>
</ul>
</li>
<li><p>在单缓冲情况下，为什么系统对一块数据的处理时间为$Max(C,T)+M$？</p>
<ul>
<li>在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T；</li>
<li>操作系统将缓冲区数据传送给用户区的时间为M；</li>
<li>而CPU对这一块数据进行计算得时间为C。</li>
<li>在单缓冲情况下，由于<strong>设备的输入操作</strong>和<strong>CPU的处理操作</strong>可以<strong>并行</strong>，所以系统对每一整块数据的处理时间为 $Max(C,T)+M$。</li>
</ul>
</li>
<li><p>为什么在双缓冲情况下，系统对一块数据的处理时间为$Max(C,T)$？</p>
<ul>
<li>该方式又称<strong>缓冲对换</strong>方式，在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。</li>
<li>此时操作系统可以从第一缓冲区移出数据，并送入用户进程。</li>
<li>接着由CPU对数据进行计算。</li>
<li>在双缓冲区中，不仅<strong>设备的输入操作</strong>和<strong>CPU的处理操作</strong>可以并行，<strong>设备的输入操作</strong>和<strong>数据的传送操作</strong>也可以并行，因此耗时大约为$Max(C,T)$。考虑到M是内存中数据块的“搬家”耗时，非常短暂可以省略，因此<strong>近似地</strong>认为是：$Max(C,T)$。</li>
</ul>
</li>
<li><p>试绘图说明把多缓冲用于输出时的情况。<br><img src="https://pic.zty.plus/%E5%8F%8C%E7%BC%93%E5%86%B2.png" alt="双缓冲"></p>
</li>
<li><p>试说明收容输入工作缓冲区和提取输出工作缓冲区的工作情况。</p>
<ul>
<li>收容输入工作缓冲区的工作情况为：<ul>
<li>在输入进程需要输入数据时，调用GetBuf（EmptyQueue)过程，从EmptyQueue队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区Hin。</li>
<li>然后把数据输入其中，装满后再调用PutBuf（InputQueue,Hin)过程，将该缓冲区挂在输入队列InputQueue的队尾。</li>
</ul>
</li>
<li>提取输出工作缓冲区的工作情况为：<ul>
<li>当要输出数据时，调用GetBuf（OutputQueue)过程，从输出队列的队首取得一装满输出数据的缓冲区作为提取输出工作缓冲区Sout。</li>
<li>在数据提取完后，再调用PutBuf(EmptyQueue,Sout)过程，将该缓冲区挂到空缓冲队列EmptyQueue的队尾。</li>
</ul>
</li>
</ul>
</li>
<li><p>何谓安全分配方式和不安全分配方式？</p>
<ul>
<li>安全分配方式是指每当进程发出I/0请求后，便进入阻塞状态，直到其I/0操作完成时才被唤醒。<ul>
<li>在采用这种分配策略时，一旦进程已获得某种设备资源后便阻塞，使它不可能再请求任何资源，而在它运行时又不保持任何资源。这种分配方式已经摒弃了造成死锁的“<strong>请求和保持</strong>”条件，分配是安全的。缺点是进程进展缓慢，CPU与I/0设备<strong>串行</strong>工作。</li>
</ul>
</li>
<li>不安全分配方式是指进程发出I/0请求后仍继续执行，需要时又可发出第二个I/0请求、第三个I/0请求。仅当进程请求的设备已被另一个进程占有时，进程才进入阻塞状态。<ul>
<li>优点是一个进程可同时操作多个设备，进程推进迅速。缺点是分配不安全，可能具有“<strong>请求和保持</strong>”条件，可能造成死锁。因此，在设备分配程序中需增加一个功能，用于对本次的设备分配是否会发生死锁进行安全性计算，仅当计算结果表明分配安全的情况下才进行分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘访问时间由哪几部分组成？每部分时间应如何计算？</p>
<ul>
<li>磁盘访问时间由<strong>寻道时间$T_s$</strong>、<strong>旋转延迟时间$T_\tau$</strong>、<strong>传输时间$T_t$</strong> 三部分组成。<ul>
<li>$T_s$是<strong>启动磁臂时间 s</strong> 与<strong>磁头移动 n 条磁道的时间</strong>和，即$T_s=m×n+s$。</li>
<li>$T<em>\tau$是指定<strong>扇区移动到磁头下面所经历的时间</strong>，即$T</em>\tau=1/2r$。<ul>
<li>硬盘$15000r/min$时，每转需时$4ms$$T<em>r$为$2ms$；软盘$300$或$600r/min$时$T</em>\tau$为$50$~$100ms$。</li>
</ul>
</li>
<li>$T_t$是指<strong>数据从磁盘读出或向磁盘写入经历的时间</strong>，即$T_t=b/rN$。<ul>
<li>$T<em>t$的大小与每次读/写的字节数 <strong>b</strong> 和旋转速度 <strong>r</strong> 有关，<strong>N</strong> 为一条磁道上的字节数，其中当一次读/写的字节数相当于半条磁道上的字节数时 $T</em>\tau=T_t$。</li>
</ul>
</li>
</ul>
</li>
<li>因此访问时间：$T_a=T_s+\frac{1}{2r}+\frac{b}{rN}$</li>
</ul>
</li>
<li><p>目前常用的磁盘调度算法有哪几种？每种算法优先考虑的问题是什么？</p>
<ul>
<li>目前常用的磁盘调度算法有<strong>先来先服务</strong>（FCFS）、<strong>最短寻道时间优先</strong>（SSTF）及<strong>扫描</strong>（SCAN）等算法。<ul>
<li>先来先服务算法优先考虑<strong>进程请求访问磁盘的先后次序</strong>。</li>
<li>最短寻道时间优先（Shortest Seek Time First）算法优先考虑<strong>要求访问的磁道与当前磁头所在磁道距离是否最近</strong>。</li>
<li>扫描算法考虑欲访问的磁道与当前磁道间的距离，更优先<strong>考虑磁头当前的移动方向</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>操作系统课后习题</p><p><a href="http://tianyuzhou.github.io/2020/11/15/操作系统课后习题/">http://tianyuzhou.github.io/2020/11/15/操作系统课后习题/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TIANYUZHOU</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-11-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-02-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/">操作系统-课后习题</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=602d045cb772eb001285a6af&amp;product=sticky-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/wodezhibaoshoukuanma.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wodeweixinshoukuanma.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/05/%E7%89%A9%E7%90%86%E5%B1%82-%E5%AF%B9%E6%AF%94/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">物理层-对比</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="level-item">内存管理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "A2kHmiggH1okBvKiadft61wn-gzGzoHsz",
            appKey: "vSLtbph2vNIIeyBEDtPk8RGX",
            placeholder: "快来评论吧！",
            avatar: "wavatar",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/%E6%88%91%E7%9A%84%E5%A4%B4%E5%83%8F.jpg" alt="TIANYU同学"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TIANYU同学</p><p class="is-size-6 is-block">计算机硕士研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>四川 成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TIANYUZHOU" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TIANYUZHOU"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="微博" href="https://m.weibo.cn/u/2911735563?uid=2911735563&amp;t=0&amp;luicode=10000011&amp;lfid=100103type%3D1%26q%3Dcuz_tian"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/rss.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://space.bilibili.com/381497449" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我的B站</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li><li><a class="level is-mobile" href="https://www.baidu.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度搜索</span></span><span class="level-right"><span class="level-item tag">www.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://cn.bing.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">必应搜索</span></span><span class="level-right"><span class="level-item tag">cn.bing.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/"><span class="level-start"><span class="level-item">一些小坑</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">学习笔记</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%91%84%E4%B8%8E%E5%BD%B1/"><span class="level-start"><span class="level-item">摄与影</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AD%8C%E5%8D%95/"><span class="level-start"><span class="level-item">歌单</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%A7%86%E9%A2%91/"><span class="level-start"><span class="level-item">视频</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/01/24/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><img src="/Mainpic/27.jpg" alt="LeetCode刷题笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-01-24T12:33:33.000Z">2022-01-24</time></p><p class="title"><a href="/2022/01/24/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">LeetCode刷题笔记</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/01/03/%E7%9B%B8%E5%86%8C/"><img src="/Mainpic/9.jpg" alt="我的图库"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-01-03T14:30:00.000Z">2022-01-03</time></p><p class="title"><a href="/2022/01/03/%E7%9B%B8%E5%86%8C/">我的图库</a></p><p class="categories"><a href="/categories/%E6%91%84%E4%B8%8E%E5%BD%B1/">摄与影</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5/"><img src="/Mainpic/24.jpg" alt="数据库-概念"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-01-10T03:06:47.000Z">2021-01-10</time></p><p class="title"><a href="/2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5/">数据库-概念</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/"><img src="/Mainpic/24.jpg" alt="数据库语句"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-01-03T12:45:46.000Z">2021-01-03</time></p><p class="title"><a href="/2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/">数据库语句</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/12/31/%E7%89%A9%E7%90%86%E5%B1%82/"><img src="/Mainpic/22.jpg" alt="物理层"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-12-31T00:22:36.000Z">2020-12-31</time></p><p class="title"><a href="/2020/12/31/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/80%C3%9786%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="tag">80×86汇编语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"><span class="tag">C++内联函数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML5-CSS-JS%E5%88%9D%E6%AD%A5/"><span class="tag">HTML5+CSS+JS初步</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python%E5%AD%A6%E4%B9%A0/"><span class="tag">Python学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python%E5%BA%94%E7%94%A8-%E7%88%AC%E8%99%AB/"><span class="tag">Python应用(爬虫)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python%E5%BA%94%E7%94%A8-%E7%88%AC%E8%99%AB-XPath/"><span class="tag">Python应用(爬虫-XPath)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"><span class="tag">Python自动打卡</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VS-Code%E5%B0%8F%E5%9D%91/"><span class="tag">VS Code小坑</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E6%AE%B5%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F/"><span class="tag">分区、分段、段页式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%BA%93/"><span class="tag">图库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E5%91%A8%E6%9D%B0%E4%BC%A6/"><span class="tag">我的歌单-周杰伦</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E6%9E%97%E4%BF%8A%E6%9D%B0/"><span class="tag">我的歌单-林俊杰</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E8%B5%B5%E6%B5%B7%E6%B4%8B/"><span class="tag">我的歌单-赵海洋</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%91%E7%9A%84%E6%AD%8C%E5%8D%95-%E9%99%88%E5%A5%95%E8%BF%85/"><span class="tag">我的歌单-陈奕迅</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8B%93%E5%B1%95/"><span class="tag">拓展</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"><span class="tag">操作系统-课后习题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"><span class="tag">数据挖掘</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%85%E8%A1%8C/"><span class="tag">旅行</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"><span class="tag">第一篇文章</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"><span class="tag">算法分析与设计</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E6%98%93%E4%BA%91%E6%8F%92%E4%BB%B6%E5%B0%8F%E5%9D%91/"><span class="tag">网易云插件小坑</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%A7%86%E9%A2%91%E4%BD%9C%E5%93%81/"><span class="tag">视频作品</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"><span class="tag">计算机组成与系统结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">7</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=ztyzhou/YjNL&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="ztyzhou/YjNL" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2.png" alt="程序员的文章" height="28"></a><p class="is-size-7"><span>&copy; 2023 TIANYUZHOU</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="摄与影" href="https://ztyzhou.com/categories/%E6%91%84%E4%B8%8E%E5%BD%B1/"><i class="fas fa-camera-retro"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="视频" href="https://ztyzhou.com/2020/02/01/%E8%A7%86%E9%A2%91/"><i class="fas fa-spinner fa-spin"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub 登录" href="https://github.com/"><i class="fab fa-github"></i></a></p></div><div style="text-align:center"><p>备案号：<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">蜀ICP备20006402号-2</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>