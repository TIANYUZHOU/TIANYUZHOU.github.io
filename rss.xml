<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员的文章</title>
  
  <subtitle>TIANYU的文章</subtitle>
  <link href="http://tianyuzhou.github.io/rss.xml" rel="self"/>
  
  <link href="http://tianyuzhou.github.io/"/>
  <updated>2023-04-05T07:42:54.115Z</updated>
  <id>http://tianyuzhou.github.io/</id>
  
  <author>
    <name>TIANYUZHOU</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UIE迁移</title>
    <link href="http://tianyuzhou.github.io/2023/04/05/UIE%E8%BF%81%E7%A7%BB/"/>
    <id>http://tianyuzhou.github.io/2023/04/05/UIE%E8%BF%81%E7%A7%BB/</id>
    <published>2023-04-05T07:18:43.000Z</published>
    <updated>2023-04-05T07:42:54.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="UIE模型"><a href="#UIE模型" class="headerlink" title="UIE模型"></a>UIE模型</h2><p>UIE模型是指Unified Information Extraction，即通用信息抽取模型。该模型是由Yaojie Lu等人在ACL-2022中提出的通用信息抽取统一框架，实现了实体抽取、关系抽取、事件抽取、情感分析等任务的统一建模，并使得不同任务间具备良好的迁移和泛化能力。</p><h2 id="模型迁移"><a href="#模型迁移" class="headerlink" title="模型迁移"></a>模型迁移</h2><p>一般模型迁移，需要经历以下步骤：</p><span id="more"></span><ul><li>模型代码迁移<ul><li>这一步需要进行<code>API</code>接口映射（比如把<code>Pytorch</code>实现的模型代码映射成使用<code>MindSpore</code>的<code>API</code>接口实现，如果所需<code>API</code>在目标框架中没有或者区别较大就可能需要自己实现了）</li></ul></li><li>模型/模块验证<ul><li>完成模型代码迁移后，必然少不了对其进行验证。在预训练权重迁移之前，如果模型结构比较简单，可以手动构造<code>Tensor</code>并且手动替代随机初始化权重等随机因素，然后将模型实例设置为<strong>预测模式</strong>，进行初步的输入输出验证（输出<code>Tensor</code>的<code>shape</code>应该相等、值应该误差在<code>1e-5/1e-3/5e-3</code>内），这样可以验证出模型/模块的基本结构和前向计算过程是否正确。</li></ul></li><li>预训练权重迁移<ul><li>当然最正确最有效的验证方式，是将模型的预训练权重加载到模型中，然后将模型设为<strong>预测模式</strong>，进行前向推理比较输出<code>Tensor</code>的<code>shape</code>和值，并且一个完整的模型迁移过程通常本来就需要将预训练权重迁移也进行迁移。<ul><li>这时就出现一个问题，我们知道不同的深度学习框架除了<code>API</code>有所区别外，保存权重（也就是模型的参数）的格式也有所不同。该如何转换呢？</li><li>实际上，模型的权重（参数）就是一堆数值矩阵，在模型结构一致的情况下可能出现的区别也就在权重矩阵的维度以及它们的名称上。因此，要实现迁移，只需要将它们的参数名字以及维度转化成适应目标框架的形式即可。（因此分析出两个框架之间的参数名称和权重维度对应关系<strong>非常重要</strong>！）</li></ul></li></ul></li></ul><h2 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h2><p>主要记录遇到的<strong>坑</strong></p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li><code>PaddleNLP-&gt;MindNLP</code></li></ul><h3 id="模型代码迁移"><a href="#模型代码迁移" class="headerlink" title="模型代码迁移"></a>模型代码迁移</h3><ul><li><p><code>paddle.nn.MultiHeadAttention</code>与<code>mindspore.nn.MultiheadAttention</code></p><ul><li><p><code>paddle.nn.MultiHeadAttention</code>的<code>attention mask</code>的输入维度：<code>[batch_size，n_head，sequence_length，sequence_length]</code></p></li><li><p><code>mindspore.nn.MultiheadAttention</code>的的<code>attention mask</code>的输入维度： <code>[batch_size * n_head, sequence_length，sequence_length]</code></p><blockquote><p>尾部两个<code>sequence_length</code>维度分别代表源序列长度和目标序列长度</p></blockquote></li><li><p>因此在<code>MindNLP</code>中需要对<code>attention mask</code>加一步<a href="https://www.mindspore.cn/docs/zh-CN/master/api_python/ops/mindspore.ops.tile.html?highlight=tile#mindspore.ops.tile">tile</a>操作， 将<code>Tensor</code>维度变成第二种形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># paddle 中的 attention mask</span></span><br><span class="line">attention_mask = paddle.unsqueeze(</span><br><span class="line">    (input_ids == self.pad_token_id).astype(self.pooler.dense.weight.dtype) * -<span class="number">1e4</span>, axis=[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment"># mindspore 中的 attention mask</span></span><br><span class="line">attention_mask = ((input_ids == self.pad_token_id).astype(self.pooler.dense.weight.dtype) * -<span class="number">1e4</span>).unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>)</span><br><span class="line">attention_mask = ops.tile(attention_mask, (<span class="number">1</span>, self.nheads, seq_length, <span class="number">1</span>)).reshape(-<span class="number">1</span>, seq_length, seq_length)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：mindspore 的 unsqueeze 一次只支持增加一维，但可以使用链式调用</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="权重迁移"><a href="#权重迁移" class="headerlink" title="权重迁移"></a>权重迁移</h3><ul><li><p>坑同样出现在<code>MultiHeadAttention</code>当中，首先来看看源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># paddle MultiHeadAttention 中参数定义</span></span><br><span class="line"></span><br><span class="line">self.q_proj = Linear(embed_dim, embed_dim, weight_attr, bias_attr=bias_attr)</span><br><span class="line">self.k_proj = Linear(self.kdim, embed_dim, weight_attr, bias_attr=bias_attr)</span><br><span class="line">self.v_proj = Linear(self.vdim, embed_dim, weight_attr, bias_attr=bias_attr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mindspore MultiHeadAttention 中参数定义</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self._qkv_same_embed_dim:</span><br><span class="line">    self.q_proj_weight = Parameter(initializer(XavierUniform(), (embed_dim, embed_dim)), <span class="string">&#x27;q_proj_weight&#x27;</span>)</span><br><span class="line">    self.k_proj_weight = Parameter(initializer(XavierUniform(), (embed_dim, self.kdim)), <span class="string">&#x27;k_proj_weight&#x27;</span>)</span><br><span class="line">    self.v_proj_weight = Parameter(initializer(XavierUniform(), (embed_dim, self.vdim)), <span class="string">&#x27;v_proj_weight&#x27;</span>)</span><br><span class="line">    self.in_proj_weight = <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.in_proj_weight = Parameter(initializer(XavierUniform(), (<span class="number">3</span> * embed_dim, embed_dim)), <span class="string">&#x27;in_proj_weight&#x27;</span>)</span><br><span class="line">    self.q_proj_weight = <span class="literal">None</span></span><br><span class="line">    self.k_proj_weight = <span class="literal">None</span></span><br><span class="line">    self.v_proj_weight = <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>首先可以看到，在<code>paddle</code>中，<code>qkv</code>参数是直接用全连接层定义的，而在<code>mindspore</code>中使用的是<code>Parameter</code>，当然实际上两种方式的效果一样所以这一点区别不重要。</li><li><p>重点在于，在<code>mindspore</code>中，如果<code>qkv</code>的维度相同的话，它会把原本的<code>qkv</code>对应的三个参数矩阵拼接成一个<code>in_proj_weight</code>，也就是<code>esle</code>部分的代码所做的事。因此，在checkpoint转化时，也需要将这三个参数矩阵进行拼接融合成一个。</p></li><li><p>下面分别打印在两个框架中实现的模型的参数名及权重维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># paddle实现UIE的权重</span></span><br><span class="line">ernie.embeddings.word_embeddings.weight[<span class="number">40000</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.position_embeddings.weight[<span class="number">2048</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.token_type_embeddings.weight[<span class="number">4</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.task_type_embeddings.weight[<span class="number">3</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.layer_norm.weight[<span class="number">768</span>]</span><br><span class="line">ernie.embeddings.layer_norm.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.q_proj.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.q_proj.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.k_proj.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.k_proj.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.v_proj.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.v_proj.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.out_proj.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.out_proj.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear1.weight[<span class="number">768</span>, <span class="number">3072</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear1.bias[<span class="number">3072</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear2.weight[<span class="number">3072</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear2.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm1.weight[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm1.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm2.weight[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm2.bias[<span class="number">768</span>]</span><br><span class="line">...</span><br><span class="line">ernie.pooler.dense.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.pooler.dense.bias[<span class="number">768</span>]</span><br><span class="line">linear_start.weight[<span class="number">768</span>, <span class="number">1</span>]</span><br><span class="line">linear_start.bias[<span class="number">1</span>]</span><br><span class="line">linear_end.weight[<span class="number">768</span>, <span class="number">1</span>]</span><br><span class="line">linear_end.bias[<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># mindspore实现UIE的权重</span></span><br><span class="line">ernie.embeddings.word_embeddings.embedding_table[<span class="number">40000</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.position_embeddings.embedding_table[<span class="number">2048</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.token_type_embeddings.embedding_table[<span class="number">4</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.task_type_embeddings.embedding_table[<span class="number">3</span>, <span class="number">768</span>]</span><br><span class="line">ernie.embeddings.layer_norm.gamma[<span class="number">768</span>]</span><br><span class="line">ernie.embeddings.layer_norm.beta[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.in_proj_weight[<span class="number">2304</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.in_proj_bias[<span class="number">2304</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.out_proj.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.self_attn.out_proj.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear1.weight[<span class="number">3072</span>, <span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear1.bias[<span class="number">3072</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear2.weight[<span class="number">768</span>, <span class="number">3072</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.linear2.bias[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm1.gamma[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm1.beta[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm2.gamma[<span class="number">768</span>]</span><br><span class="line">ernie.encoder.layers<span class="number">.0</span>.norm2.beta[<span class="number">768</span>]</span><br><span class="line">...</span><br><span class="line">ernie.pooler.dense.weight[<span class="number">768</span>, <span class="number">768</span>]</span><br><span class="line">ernie.pooler.dense.bias[<span class="number">768</span>]</span><br><span class="line">linear_start.weight[<span class="number">1</span>, <span class="number">768</span>]</span><br><span class="line">linear_start.bias[<span class="number">1</span>]</span><br><span class="line">linear_end.weight[<span class="number">1</span>, <span class="number">768</span>]</span><br><span class="line">linear_end.bias[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为了方便分析，<code>...</code>省略了11层<code>ernie.encoder.layers</code>（总共12层）。下面表格列出两个框架之间的参数区别（不同之处已加粗）：</p></li></ul><div class="table-container"><table><thead><tr><th>paddle</th><th>mindspore</th></tr></thead><tbody><tr><td>word_embeddings.<strong>weight</strong>[40000, 768]</td><td>word_embeddings.<strong>embedding_table</strong>[40000, 768]</td></tr><tr><td>position_embeddings.<strong>weigh</strong>[2048, 768]</td><td>word_embeddings.<strong>embedding_table</strong>[2048, 768]</td></tr><tr><td>token_type_embeddings.<strong>weight</strong>[4, 768]</td><td>token_type_embeddings.<strong>embedding_table</strong>[4, 768]</td></tr><tr><td>layer_norm.<strong>weight</strong>[768]</td><td>layer_norm.<strong>gamma</strong>[768]</td></tr><tr><td>layer_norm.<strong>bias</strong>[768]</td><td>layer_norm.<strong>beta</strong>[768]</td></tr><tr><td>layers.0.self_attn.q_proj.<strong>weight[768, 768]</strong><br/>layers.0.self_attn.q_proj.<strong>bias[768]</strong><br/>layers.0.self_attn.k_proj.<strong>weight[768, 768]</strong><br />layers.0.self_attn.k_proj.<strong>bias[768]</strong><br/>layers.0.self_attn.v_proj.<strong>weight[768, 768]</strong><br/>layers.0.self_attn.v_proj.<strong>bias[768]</strong></td><td>layers.0.self_attn.<strong>in_proj_weight[2304, 768]</strong><br/>layers.0.self_attn.<strong>in_proj_bias[2304]</strong></td></tr><tr><td>layers.0.linear1.weight<strong>[768, 3072]</strong></td><td>layers.0.linear1.weight<strong>[3072, 768]</strong></td></tr><tr><td>layers.0.linear2.weight<strong>[3072, 768]</strong></td><td>layers.0.linear2.weight<strong>[768, 3072]</strong></td></tr><tr><td>layers.0.norm1.<strong>weight</strong>[768]</td><td>layers.0.norm1.<strong>gamma</strong>[768]</td></tr><tr><td>layers.0.norm1.<strong>bias</strong>[768]</td><td>layers.0.norm1.<strong>beta</strong>[768]</td></tr><tr><td>layers.0.norm2.<strong>weight</strong>[768]</td><td>layers.0.norm2.<strong>gamma</strong>[768]</td></tr><tr><td>layers.0.norm2.<strong>bias</strong>[768]</td><td>layers.0.norm2.<strong>beta</strong>[768]</td></tr><tr><td>linear_start.weight<strong>[768, 1]</strong></td><td>linear_start.weight<strong>[1, 768]</strong></td></tr><tr><td>linear_end.weight<strong>[768, 1]</strong></td><td>linear_end.weight<strong>[1, 768]</strong></td></tr></tbody></table></div><ul><li><p>可以看到，对于<code>embeddings</code>和<code>layer_norm/norm</code>区别在于参数名而维度形状相同；对于全连接层<code>liner</code>区别在于维度形状<strong>交换</strong>而参数名相同；再看表格的第6行，前面源代码已经分析过了，<code>paddle</code>使用了全连接层并且没有将<code>qkv</code>的参数融合在一起，所以它的<code>qkv</code>的权重矩阵刚好是<code>mindspore</code>中权重矩阵的拆分（<strong>这里需要注意拼接<code>weight</code>的时候先沿<code>axis=1</code>拼接成<code>[760,2304]</code>，然后再转置/交换维度成<code>[2304,768]</code>，如果沿<code>axis=0</code>直接拼接，<code>qkv</code>所对应的权重矩阵就乱了</strong>）。</p></li><li><p>好到这里就分析完了？未列入上表的其他参数说明一模一样，即参数名相同维度也没反？</p></li><li><p><strong>注意：</strong>大坑来了！！！</p></li></ul><div class="table-container"><table><thead><tr><th>paddle</th><th>mindspore</th></tr></thead><tbody><tr><td>layers.0.self_attn.q_proj.weight<strong>[768, 768]</strong></td><td>layers.0.self_attn.out_proj.weight<strong>[768, 768]</strong></td></tr></tbody></table></div><ul><li><p>特意把这<code>self_attn.q_proj.weight</code>单独提出来，这个参数乍一看在两个框架中完全一样！无论是参数名称还是其维度！<strong>但是，实际上是不同的！</strong>这两个矩阵虽然在维度大小上完全一致，但是是一个转置关系！也就说这个参数矩阵也需要交换一下维度！</p></li><li><p>经过上面分析，接下来要做的就是：1. 将参数名进行转换 2. 将维度进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> mindspore <span class="keyword">import</span> Tensor</span><br><span class="line"><span class="keyword">from</span> mindspore.train.serialization <span class="keyword">import</span> save_checkpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paddle_to_mindspore</span>(<span class="params">pth_file, size:<span class="built_in">str</span>=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    size = <span class="string">&quot;mindspore&quot;</span> <span class="keyword">if</span> <span class="keyword">not</span> size <span class="keyword">else</span> size <span class="comment"># rename ckpt</span></span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">&#x27;Starting checkpoint conversion.&#x27;</span>)</span><br><span class="line">    ms_ckpt = []</span><br><span class="line">    state_dict = paddle.load(<span class="string">&quot;model_state.pdparams&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    cnt1 = <span class="number">0</span></span><br><span class="line">    in_p_w = np.empty((<span class="number">768</span>,<span class="number">0</span>),dtype=np.float32) <span class="comment"># 创建一个维度与embedding相同的空矩阵以便拼接</span></span><br><span class="line">    cnt2 = <span class="number">0</span></span><br><span class="line">    in_p_b = np.empty(<span class="number">0</span>,dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> state_dict.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;embeddings.weight&#x27;</span> <span class="keyword">in</span> k:</span><br><span class="line">            k = k.replace(<span class="string">&#x27;embeddings.weight&#x27;</span>, <span class="string">&#x27;embeddings.embedding_table&#x27;</span>)</span><br><span class="line">            ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(v.numpy())&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        pattern = <span class="string">r&quot;norm.*?\.weight&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.search(pattern, k):</span><br><span class="line">            k = re.sub(<span class="string">&quot;weight&quot;</span>, <span class="string">&quot;gamma&quot;</span>, k)</span><br><span class="line">            ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(v.numpy())&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        pattern = <span class="string">r&quot;norm.*?\.bias&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.search(pattern, k):</span><br><span class="line">            k = re.sub(<span class="string">&quot;bias&quot;</span>, <span class="string">&quot;beta&quot;</span>, k)</span><br><span class="line">            ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(v.numpy())&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        pattern = <span class="string">r&quot;linear.*\.weight&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.search(pattern, k):</span><br><span class="line">            ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(np.transpose(v.numpy()))&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        pattern = <span class="string">r&quot;self_attn\.._proj.weight&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.search(pattern, k):</span><br><span class="line">            k = re.sub(<span class="string">r&quot;self_attn\.._proj.weight&quot;</span>, <span class="string">&quot;self_attn.in_proj_weight&quot;</span>, k)</span><br><span class="line">            <span class="keyword">if</span> cnt1 % <span class="number">3</span> != <span class="number">0</span> <span class="keyword">or</span> cnt1 == <span class="number">0</span>:</span><br><span class="line">                in_p_w = np.concatenate((in_p_w, v.numpy()), axis=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (cnt1+<span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                    ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(in_p_w).swapaxes(<span class="number">0</span>,<span class="number">1</span>)&#125;)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 每三个拼接一次（qkv）对齐 mindspore 的 in_proj_weight</span></span><br><span class="line">                in_p_w = v.numpy()</span><br><span class="line">            cnt1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        pattern = <span class="string">r&quot;self_attn\.._proj.bias&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.search(pattern, k):</span><br><span class="line">            k = re.sub(<span class="string">r&quot;self_attn\.._proj.bias&quot;</span>, <span class="string">&quot;self_attn.in_proj_bias&quot;</span>, k)</span><br><span class="line">            <span class="keyword">if</span> cnt2 % <span class="number">3</span> != <span class="number">0</span> <span class="keyword">or</span> cnt2 == <span class="number">0</span>:</span><br><span class="line">                in_p_b = np.append(in_p_b, v.numpy())</span><br><span class="line">                <span class="keyword">if</span> (cnt2+<span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                    ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(in_p_b)&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                in_p_b = v.numpy()</span><br><span class="line">            cnt2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 很关键，padlle权重维度与mindspore的权重维度很多都是反的，特别注意多个维度相等的时候也要转换！</span></span><br><span class="line">        pattern = <span class="string">r&quot;self_attn\.out_proj.weight&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.search(pattern, k):</span><br><span class="line">            ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(np.transpose(v.numpy()))&#125;)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        ms_ckpt.append(&#123;<span class="string">&#x27;name&#x27;</span>: k, <span class="string">&#x27;data&#x27;</span>: Tensor(v.numpy())&#125;)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    ms_ckpt_path = pth_file.replace(<span class="string">&#x27;.pdparams&#x27;</span>,<span class="string">&#x27;.ckpt&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        save_checkpoint(ms_ckpt, ms_ckpt_path)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&#x27;Save checkpoint to <span class="subst">&#123;ms_ckpt_path&#125;</span> failed, please checkout the path.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ms_ckpt_path</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;UIE模型&quot;&gt;&lt;a href=&quot;#UIE模型&quot; class=&quot;headerlink&quot; title=&quot;UIE模型&quot;&gt;&lt;/a&gt;UIE模型&lt;/h2&gt;&lt;p&gt;UIE模型是指Unified Information Extraction，即通用信息抽取模型。该模型是由Yaojie Lu等人在ACL-2022中提出的通用信息抽取统一框架，实现了实体抽取、关系抽取、事件抽取、情感分析等任务的统一建模，并使得不同任务间具备良好的迁移和泛化能力。&lt;/p&gt;
&lt;h2 id=&quot;模型迁移&quot;&gt;&lt;a href=&quot;#模型迁移&quot; class=&quot;headerlink&quot; title=&quot;模型迁移&quot;&gt;&lt;/a&gt;模型迁移&lt;/h2&gt;&lt;p&gt;一般模型迁移，需要经历以下步骤：&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://tianyuzhou.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="模型迁移" scheme="http://tianyuzhou.github.io/tags/%E6%A8%A1%E5%9E%8B%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="http://tianyuzhou.github.io/2022/01/24/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://tianyuzhou.github.io/2022/01/24/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-24T12:33:33.000Z</published>
    <updated>2022-02-20T14:12:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>最近在学习<code>JavaScript</code>，刷题也用顺便巩固，两全其美。</li></ul><h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></h3><ul><li>思路<ul><li>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。<span id="more"></span></li><li>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// 声明对象，存储罗马数字对应的整数值</span></span><br><span class="line">    <span class="keyword">let</span> romanOBJ=&#123;</span><br><span class="line">        <span class="string">&#x27;M&#x27;</span> : <span class="number">1000</span>,</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span> : <span class="number">500</span>,</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span> : <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;L&#x27;</span> : <span class="number">50</span>,</span><br><span class="line">        <span class="string">&#x27;X&#x27;</span> : <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;V&#x27;</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="string">&#x27;I&#x27;</span> : <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历源字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = romanOBJ[s[i]];</span><br><span class="line">        <span class="comment">// 值小的罗马数字在前则减，否则加</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;  s.<span class="property">length</span>-<span class="number">1</span> &amp;&amp; value &lt; romanOBJ[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">            result -= value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></h3><ul><li>描述<ul><li>编写一个函数来查找字符串数组中的最长公共前缀。</li><li>如果不存在公共前缀，返回空字符串<code>&quot;&quot;</code>。</li></ul></li><li>思路<ul><li>纵向扫描</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">strs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="keyword">function</span> (<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 需要一个标指记录内层循环是正常结束还是不匹配后的break出来的</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 找出最短的字符串长度 以此为行最大扫描长度</span></span><br><span class="line">    <span class="keyword">let</span> n = strs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">max, current</span>) =&gt;</span> </span><br><span class="line">    max &lt; current.<span class="property">length</span> ? current.<span class="property">length</span> : max, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i][j] === strs[i + <span class="number">1</span>][j]) &#123;  <span class="comment">// 匹配成功继续下一轮循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 匹配失败结束循环（此时j的值是最近一次成功的下标）</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;   <span class="comment">// flag === true说明匹配结束，否则进行下一个字符的匹配</span></span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="title function_">slice</span>(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的返回表示全部匹配成功（几个字符串完全一样）</span></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="title function_">slice</span>(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>改进版本</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 行列下标范围</span></span><br><span class="line">    <span class="keyword">const</span> rows = strs.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> cols = strs[<span class="number">0</span>].<span class="property">length</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> firstChar = strs[<span class="number">0</span>][i];   <span class="comment">// 首行 i 列字符（以首行字符串为基准比较）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; rows; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果第 j 行字符串的长度 === i（此时j行的字符串最短，即最长公共前缀）</span></span><br><span class="line">            <span class="comment">// 或 字符不匹配（说明最长前缀已经找到）</span></span><br><span class="line">            <span class="comment">// 此时 i 即最长前缀下标结束位置</span></span><br><span class="line">            <span class="keyword">if</span> (strs[j].<span class="property">length</span> == i || strs[j][i] != firstChar) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若前面循环没有 return 说明第一行字符串肯定是最长公共前缀</span></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></h3><ul><li>描述<ul><li>给定一个只包括<code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 s ，判断字符串是否有效。</li><li>有效字符串需满足：<ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul></li></ul></li><li>思路<ul><li>栈</li><li>遍历字符串，遇左括号入栈，遇右括号进行匹配校验，匹配成功出栈，失败返回<code>false</code>。</li><li>遍历完毕，栈为空（说明全部匹配）则返回<code>true</code>，栈不空（说明有括号”落单“）返回<code>false</code>。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span> || s[i] === <span class="string">&#x27;[&#x27;</span> || s[i] === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里当栈中无元素时，前面表达式值为undefined也不与 &#x27;(&#x27; 相等</span></span><br><span class="line">        <span class="comment">// 正好考虑到了这种情况（其他语言可能出现语法错误 最好加上一个stack不为空的判断条件）</span></span><br><span class="line">        <span class="comment">// 即 stack.length!==0 &amp;&amp; stack[stk.length-1]===&#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="title function_">slice</span>(-<span class="number">1</span>)[<span class="number">0</span>] === <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 也可以用stack[stack.length - 1]</span></span><br><span class="line">          stack.<span class="title function_">pop</span>();</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="title function_">slice</span>(-<span class="number">1</span>)[<span class="number">0</span>] === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>();</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="title function_">slice</span>(-<span class="number">1</span>)[<span class="number">0</span>] === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>();</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>改进（哈希）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m =s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(m%<span class="number">2</span>!==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 奇数个括号肯定不匹配</span></span><br><span class="line">    <span class="keyword">let</span> map =<span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>]</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">let</span> stk=[]</span><br><span class="line">    <span class="keyword">for</span>(ch <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(ch))&#123;  <span class="comment">// 左括号进栈</span></span><br><span class="line">            stk.<span class="title function_">push</span>(ch)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 右括号进行匹配校验</span></span><br><span class="line">        <span class="comment">// stk.length === 0 说明栈中无左括号，也是不匹配的一种情况</span></span><br><span class="line">        <span class="comment">//（其实可以不写，因为stk为空的话那么前面的表达式值为 undefined）</span></span><br><span class="line">            <span class="keyword">if</span>(map.<span class="title function_">get</span>(stk[stk.<span class="property">length</span>-<span class="number">1</span>])!==ch || stk.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">else</span> stk.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stk.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></h3><ul><li>描述<ul><li>给你一个数组<code>nums</code>和一个值<code>val</code>，你需要<strong>原地</strong>移除所有数值等于<code>val</code>的元素，并返回移除后数组的新长度。</li><li>不要使用额外的数组空间，你必须仅使用<code>O(1)</code>额外空间并 原地 修改输入数组。</li><li>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</li></ul></li><li>思路<ul><li>遍历 + <code>splice()</code>，此法有点流氓，我猜不是题目考察本意。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须用 nums.length而不能提前赋值个变量</span></span><br><span class="line">    <span class="comment">// 因为删除过程中长度是变化的</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; nums.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val === nums[i])&#123;</span><br><span class="line">            nums.<span class="title function_">splice</span>(i,<span class="number">1</span>);</span><br><span class="line">            i--;  <span class="comment">// 删除之后指针回溯一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li><li>思路（双指针）<ul><li>右指针<code>right</code>指向当前将要处理的元素，左指针<code>left</code>指向下一个将要赋值的位置。</li><li>如果右指针指向的元素不等于<code>val</code>，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于<code>val</code>，它不能在输出数组里，此时左指针不动，右指针右移一位。</li><li>最后返回<code>left</code>即是数组应当输出得到长度。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[right] === val)&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></h3><ul><li>描述<ul><li>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</li><li>请必须使用时间复杂度为$O(log_n)$的算法。</li></ul></li><li>思路<ul><li>有序且要求时间复杂度 <code>-&gt;</code> 二分查找。</li><li>需要注意的是，查找失败时应该返回的下标是<code>right  + 1</code> 或 <code>left</code>（循环结束条件为<code>left &lt;= right</code>时）。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 根据if的判断条件，left左边的值一直保持小于target，right右边的值一直保持大于等于target，而且left最终一定等于right+1;</span></span><br><span class="line"><span class="comment">    这么一来，循环结束后，在left和right之间画一条竖线，恰好可以把数组分为两部分：</span></span><br><span class="line"><span class="comment">    left左边的部分和right右边的部分，而且left左边的部分全部小于target，并以right结尾；</span></span><br><span class="line"><span class="comment">    right右边的部分全部大于等于target，并以left为首。所以最终答案一定在left的位置。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/">最大子数组和</a></h3><ul><li>描述<ul><li>给你一个整数数组<code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li><li><strong>子数组</strong>是数组中的一个连续部分。</li></ul></li><li>思路（贪心）<ul><li>从左向右迭代，一个个数字加过去如果<code>tempSum &lt; 0</code>, 那说明加上它只会变得越来越小, 所以我们将<code>tempSum</code>置零后重新开始找子序串。</li><li>在迭代的过程中要注意，我们需要用<code>maxSum</code>来不断维持当前的最大子序和, 因为<code>maxSum</code>的值是在不断更新的, 所以我们要及时记录下它的最大值。</li><li>有一个注意点是: 当数组全是负数的时候其实是没有问题的。因为在<code>tempSum</code>不断遍历的过程中, 早已将最大值不断传给<code>maxSum</code>，即使<code>tempSum</code>一直是负数被不断置零也不用担心，<code>maxSum</code>还是会记录下最大的那个负数。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> tempSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        tempSum += nums[i];</span><br><span class="line">        maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(tempSum, maxSum);</span><br><span class="line">        <span class="keyword">if</span>(tempSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            tempSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>思路（动态规划）<ul><li>略</li></ul></li></ul><h3 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a></h3><ul><li>描述<ul><li>给你一个字符串<code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</li><li><strong>单词</strong>是指仅由字母组成、不包含任何空格字符的最大子字符串。</li></ul></li><li>思路<ul><li>反向遍历，忽略尾部的空格，找到最后一个单词。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> lastWLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>; <span class="comment">// 记录是否遍历到非“空格“的标识</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">&#x27; &#x27;</span> &amp;&amp; !flag)&#123;  <span class="comment">// 此处匹配的是末尾的“空格”字符</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] === <span class="string">&#x27; &#x27;</span> &amp;&amp; flag)&#123; <span class="comment">// 此处匹配的是末尾单词前一个空格</span></span><br><span class="line">            <span class="keyword">return</span> lastWLen;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 此处匹配的是单词字符</span></span><br><span class="line">            lastWLen++;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastWLen;  <span class="comment">// 注意：若末尾没有空格应当在此处返回，否则函数将无返回值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>简化（实际上<code>lastWLen</code>本身就可以作为<code>flag</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastWLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = s.<span class="property">length</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="title function_">charAt</span>(i) === <span class="string">&#x27; &#x27;</span> &amp;&amp; lastWLen) &#123; <span class="comment">// lastWLen !== 0 表示已经遍历到末尾单词前一个空格</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="title function_">charAt</span>(i) !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            lastWLen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastWLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>思路（内置方法）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">reverse</span>()[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[arr.<span class="property">length</span>-<span class="number">1</span>].<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/">二进制求和</a></h3><ul><li>描述<ul><li>给你两个二进制字符串，返回它们的和（用二进制表示）。</li><li>输入为<strong>非空</strong>字符串且只包含数字<code>1</code>和<code>0</code>。</li></ul></li><li>思路（模拟）<ul><li>长度不同则补零</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">a</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">b</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addBinary = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> i1 = num1.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> i2 = num2.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i1 &gt;= <span class="number">0</span> || i2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 补零操作</span></span><br><span class="line">        <span class="keyword">const</span> x = i1 &gt;= <span class="number">0</span> ? num1[i1] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> y = i2 &gt;= <span class="number">0</span> ? num2[i2] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> sum = x + y + carry;</span><br><span class="line">        res += (sum % <span class="number">2</span>);</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        i1--;</span><br><span class="line">        i2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) res += carry;</span><br><span class="line">    <span class="comment">// res = res + ... 需要反转</span></span><br><span class="line">    <span class="comment">// 可以改成 res = ... + res</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></h3><ul><li>描述<ul><li>给你一个非负整数<code>x</code>，计算并返回<code>x</code>的 算术平方根 。</li><li>由于返回类型是整数，结果只保留<strong>整数</strong>部分 ，小数部分将被<strong>舍去</strong>。</li></ul></li><li>思路<ul><li>找出刚好小于或等于<code>x</code>的<code>i*i</code>。</li><li>穷举</li><li>二分查找<ul><li>查找范围为<code>[0,x]</code>的一个单调递增数组，找出第一个小于等于x的值。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mySqrt = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> leftNum = i*i;</span><br><span class="line">        <span class="keyword">let</span> rightNum = (i+<span class="number">1</span>)*(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftNum === x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( leftNum &lt; x &amp;&amp; rightNum &gt; x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySqrt = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i &gt; x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// x === 0 的情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = x;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="comment">// const mid = Math.floor((left + right)/2);</span></span><br><span class="line">        <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;  <span class="comment">// 移位运算相当于除以 2 取整</span></span><br><span class="line">        <span class="keyword">if</span>(mid * mid === x)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid * mid &lt; x)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出循环后，left 在 right的右边（紧邻）</span></span><br><span class="line">    <span class="comment">// left 指向比目标数大的最小值</span></span><br><span class="line">    <span class="comment">// 而 right 指向比目标值小的最大值</span></span><br><span class="line">    <span class="comment">// 即 left 及 left 之右都是比目标值大的</span></span><br><span class="line">    <span class="comment">// right 及 right 之左都是比目标值小的</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h3><ul><li>描述<ul><li>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</li><li>每次你可以爬<code>1</code>或<code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</li></ul></li><li>思路<ul><li>一般递归（超时）</li><li>带记录的递归（保存已计算过的阶）</li><li>动态规划</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">climbStairs</span>(n-<span class="number">1</span>) + <span class="title function_">climbStairs</span>(n-<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带记录的递归</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 创建 map 记录递归树结点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">climbStairsMemo</span>(n, map);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">climbStairsMemo</span> = (<span class="params">n, map</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(n)) &#123; <span class="comment">// 如果已经计算过到该阶的方法数量，直接返回即可</span></span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;  <span class="comment">// 到 2 阶有两种方法</span></span><br><span class="line">    map.<span class="title function_">set</span>(n, <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === <span class="number">1</span>) &#123; <span class="comment">// 到 1阶有一种方法</span></span><br><span class="line">    map.<span class="title function_">set</span>(n, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 递归调用，并记录到第 n 阶的方法种数  Fn = Fn-1 + Fn-2</span></span><br><span class="line">    map.<span class="title function_">set</span>(n, <span class="title function_">climbStairsMemo</span>(n - <span class="number">1</span>, map) + <span class="title function_">climbStairsMemo</span>(n - <span class="number">2</span>, map));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.<span class="title function_">get</span>(n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// let sum = s1 + s2;</span></span><br><span class="line">        <span class="comment">// s1 = s2;</span></span><br><span class="line">        <span class="comment">// s2 = sum;</span></span><br><span class="line">        s2 = s1 + s2;</span><br><span class="line">        s1 = s2 - s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打表</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    <span class="title function_">climbStairsDp</span>(dp,n);</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">climbStairsDp</span> = (<span class="params">dp,n</span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h3><ul><li>描述<ul><li>给定一个已排序的链表的头<code>head</code>， 删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。</li></ul></li><li>思路<ul><li>双指针（其实可以只用一个指针）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> q = head?.<span class="property">next</span>; <span class="comment">// 注意 head可能为空需要 ?.否则执行出错</span></span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="property">val</span> === q.<span class="property">val</span>)&#123;</span><br><span class="line">            p.<span class="property">next</span> = q.<span class="property">next</span>;</span><br><span class="line">            q = q.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">            q = q.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">while</span>(p?.<span class="property">next</span>)&#123; <span class="comment">// 若p为空等价于 提前判断 if(!head) return head; </span></span><br><span class="line">        <span class="keyword">if</span>(p.<span class="property">val</span> === p.<span class="property">next</span>.<span class="property">val</span>)&#123;</span><br><span class="line">            p.<span class="property">next</span> = p.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></h3><ul><li>描述<ul><li>给你两个按 非递减顺序 排列的整数数组<code>nums1</code>和<code>nums2</code>，另有两个整数<code>m</code>和<code>n</code>，分别表示<code>nums1</code>和<code>nums2</code>中的元素数目。</li><li>请你<strong>合并</strong><code>nums2</code>到<code>nums1</code>中，使合并后的数组同样按<strong>非递减顺序</strong>排列。</li><li>注意：最终，合并后数组不应由函数返回，而是存储在数组<code>nums1</code>中。为了应对这种情况，<code>nums1</code>的初始长度为<code>m + n</code>，其中前<code>m</code>个元素表示应合并的元素，后<code>n</code>个元素为<code>0</code>，应忽略。<code>nums2</code>的长度为<code>n</code>。</li></ul></li><li>思路<ul><li>双指针 + 辅助数组</li><li>先合并再排序</li><li><strong>逆向双指针</strong></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tempArr = [];</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; m &amp;&amp; q &lt; n )&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[p] &lt;= nums2[q])&#123;</span><br><span class="line">            tempArr.<span class="title function_">push</span>(nums1[p]);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tempArr.<span class="title function_">push</span>(nums2[q]);</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p === m )&#123;</span><br><span class="line">        tempArr.<span class="title function_">push</span>(...nums2.<span class="title function_">slice</span>(q));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tempArr.<span class="title function_">push</span>(...nums1.<span class="title function_">slice</span>(p,m));</span><br><span class="line">    &#125;</span><br><span class="line">    nums1.<span class="property">length</span> = <span class="number">0</span>;   <span class="comment">// 清空nums1</span></span><br><span class="line">    nums1.<span class="title function_">push</span>(...tempArr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    nums1.<span class="title function_">splice</span>(m, nums1.<span class="property">length</span> - m, ...nums2);</span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);  <span class="comment">// 注意sort()用法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> q = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> r = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &gt;= <span class="number">0</span> &amp;&amp; q &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[p] &gt; nums2[q])&#123;</span><br><span class="line">            nums1[r--] = nums1[p--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[r--] = nums2[q--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若nums1先遍历完，即p &lt; 0，说明nums2还有未遍历完，将nums2剩余数复制至nums1</span></span><br><span class="line">    <span class="comment">// 若nums2先遍历完，虽然nums1未遍历完但已经有序且在结果数组（nums1）中，不用调整</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            nums1[r--] = nums2[q--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 === -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 === -<span class="number">1</span>) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail--] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h3><ul><li>描述<ul><li>给定一个二叉树的根节点<code>root</code>，返回它的<strong>中序</strong>遍历。</li></ul></li><li>思路（递归）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="title function_">inorderTraversalCall</span>(root, arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">inorderTraversalCall</span> = (<span class="params">root, arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorderTraversalCall</span>(root.<span class="property">left</span>,arr);</span><br><span class="line">    arr.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">    <span class="title function_">inorderTraversalCall</span>(root.<span class="property">right</span>,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></h3><ul><li>描述<ul><li>给你两棵二叉树的根节点<code>p</code>和<code>q</code>，编写一个函数来检验这两棵树是否相同。</li><li>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</li></ul></li><li>思路<ul><li>DFS</li><li>BFS</li><li>骚操作</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="keyword">function</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.<span class="property">val</span> !== q.<span class="property">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isSameTree</span>(p.<span class="property">left</span>, q.<span class="property">left</span>) &amp;&amp; <span class="title function_">isSameTree</span>(p.<span class="property">right</span>, q.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 骚操作 判断两个 js 对象是否相等</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="keyword">function</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p) === <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(q)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h3><ul><li>描述<ul><li>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</li></ul></li><li>思路（双指针 + Set）<ul><li>一个指针遍历，另一个指针记录回溯位置。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> q = p + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">let</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(p &lt; s.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="title function_">has</span>(s[p]))&#123;</span><br><span class="line">            maxCount = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxCount, set.<span class="property">size</span>);</span><br><span class="line">            set.<span class="title function_">clear</span>();</span><br><span class="line">            p = q;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.<span class="title function_">add</span>(s[p]);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一步不能少，因为存在 1.整个字符串无重复 2.最尾端的无重复子串最长 的情况</span></span><br><span class="line">    <span class="comment">// 以上两种情况 set.has(s[p])为 false 因此不会进入 if 因此不会被记录需要在此进行记录</span></span><br><span class="line">    maxCount = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxCount, set.<span class="property">size</span>);  <span class="comment">// 当然也可将其放入循环尾部，并删除上面的赋值操作</span></span><br><span class="line">    <span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>思路（滑动窗口）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="comment">// 左指针用来收缩窗口</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 右指针用来扩张窗口</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 如果不重复，就不断扩张窗口，元素添加到set中</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; len &amp;&amp; !set.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">      set.<span class="title function_">add</span>(s[right]);</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明有元素重复了，先记录子串长度，然后收缩窗口</span></span><br><span class="line">    result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, right - left);</span><br><span class="line">    <span class="comment">// 收缩窗口</span></span><br><span class="line">    set.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h3><ul><li>描述<ul><li>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。]</li></ul></li><li>思路<ul><li>首先，找到源串中的所有回文串，然后，截取最长的即可。</li><li>如何找：<ul><li>找到源串中头尾相同的子串。</li><li>用判断回文串的方法（双指针）判断该子串和是否为回文串。</li><li>若是，则与之前找到的回文串比较长度，更长则更新<code>maxStr</code>和<code>maxLen</code>。</li><li>否则，换下一子串继续第二步。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="comment">// 设置两指针用来分别指向相同的两元素</span></span><br><span class="line">  <span class="keyword">let</span> p;</span><br><span class="line">  <span class="keyword">let</span> q;</span><br><span class="line">  <span class="keyword">let</span> maxStr = s[<span class="number">0</span>];  <span class="comment">// 记录最长回文串</span></span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">1</span>; <span class="comment">// 记录最长回文串长度</span></span><br><span class="line">  <span class="comment">// 遍历寻找两个相同元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; s.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="comment">// recp、recq 记录两个相同元素下标方便以后截取</span></span><br><span class="line">        <span class="keyword">let</span> recp = p = i;</span><br><span class="line">        <span class="keyword">let</span> recq = q = j;</span><br><span class="line">        <span class="keyword">let</span> tempLen = q - p + <span class="number">1</span>;  <span class="comment">// 暂时记录 p、q之间的串长度（可能不是回文串）</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; q) &#123; <span class="comment">// 判断是否为回文串</span></span><br><span class="line">          <span class="keyword">if</span> (s[++p] === s[--q]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempLen = <span class="number">0</span>;  <span class="comment">// 不是回文串则将长度置 0（maxLen一定 &gt; 0，因此此串（非回文串）不会被记录）</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; tempLen) &#123; <span class="comment">// maxLen &lt; tempLen 说明上一次while处理结果一定是回文串，且是比之前长的回文串</span></span><br><span class="line">          maxStr = s.<span class="title function_">slice</span>(recp, recq + <span class="number">1</span>);</span><br><span class="line">          maxLen = tempLen;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxStr;</span><br></pre></td></tr></table></figure><h3 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/">Z 字形变换</a></h3><ul><li>描述<ul><li>将一个给定字符串<code>s</code>根据给定的行数<code>numRows</code>，以从上往下、从左到右进行<code>Z</code>字形排列。</li></ul></li><li>思路<ul><li>模拟</li><li>数学规律</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">numRows</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convert = <span class="keyword">function</span> (<span class="params">s, numRows</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;   <span class="comment">// 注意一行时有点特殊（没有拐角）</span></span><br><span class="line">  <span class="keyword">let</span> resStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="number">1</span>;   <span class="comment">// 1表示向下，-1表示向上 </span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(numRows), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>());</span><br><span class="line">  <span class="keyword">let</span> curRow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curRow &gt; numRows - <span class="number">1</span>) &#123;</span><br><span class="line">      flag = -<span class="number">1</span>;</span><br><span class="line">      curRow -= <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curRow &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      curRow += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curRow &lt;= numRows - <span class="number">1</span> &amp;&amp; flag === <span class="number">1</span>) &#123;</span><br><span class="line">      arr[curRow++].<span class="title function_">push</span>(s[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curRow &gt;= <span class="number">0</span> &amp;&amp; flag === -<span class="number">1</span>) &#123;</span><br><span class="line">      arr[curRow--].<span class="title function_">push</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    resStr += item.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>改进（模拟）<ul><li>妙用<code>flag</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convert = <span class="keyword">function</span> (<span class="params">s, numRows</span>) &#123;</span><br><span class="line">  <span class="comment">// flag作为每一次扫描到顶（底）的标指（-1为顶 1为底）</span></span><br><span class="line">  <span class="comment">// 同时作为下标递增（减）的计算参数</span></span><br><span class="line">  <span class="keyword">let</span> flag = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> resStrArr = <span class="keyword">new</span> <span class="title class_">Array</span>(numRows).<span class="title function_">fill</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (numRows === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">    resStrArr[i] += c;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span> || i === numRows - <span class="number">1</span>) &#123;</span><br><span class="line">      flag = -flag;</span><br><span class="line">    &#125;</span><br><span class="line">    i += flag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resStrArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></h3><ul><li>描述<ul><li>给定一个长度为<code>n</code>的整数数组<code>height</code>。有<code>n</code>条垂线，第<code>i</code>条线的两个端点是<code>(i, 0)</code>和<code>(i, height[i])</code>。</li><li>找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。</li></ul></li><li>思路<ul><li>暴力搜索（超时）</li><li>双指针<ul><li>每次移动指向高度较小的指针，面积才有可能大于之前的。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.<span class="property">length</span> - <span class="number">1</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = i +<span class="number">1</span>; j &lt; height.<span class="property">length</span>; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(height[i] &gt; height[j])&#123;</span><br><span class="line">              maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(height[j]*(j-i), maxArea);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(height[i]*(j-i), maxArea);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">            maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, height[left]*(right-left));</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, height[right]*(right-left));</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字</a></h3><ul><li>描述<ul><li>给你一个整数，将其转为罗马数字。</li></ul></li><li>思路<ul><li>模拟（模拟）</li><li>根据罗马数字的唯一表示法，为了表示一个给定的整数<code>num</code>，我们寻找不超过<code>num</code>的最大符号值，将<code>num</code>减去该符号值，然后继续寻找不超过<code>num</code>的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至<code>num</code>为<code>0</code>。最后得到的字符串即为<code>num</code>的罗马数字表示。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="comment">// let romanOBJ =</span></span><br><span class="line">  <span class="comment">// &#123;1000: &#x27;M&#x27;, 900: &#x27;CM&#x27;, 500: &#x27;D&#x27;, 400: &#x27;CD&#x27;, 100: &#x27;C&#x27;,</span></span><br><span class="line">  <span class="comment">// 90: &#x27;XC&#x27;, 50: &#x27;L&#x27;, 40: &#x27;XL&#x27;, 10: &#x27;X&#x27;, 9: &#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125;;</span></span><br><span class="line">  <span class="comment">// js中一般对象属性（键）在不同环境下顺序不同，不一定是按照定义顺序输出（一般升序）</span></span><br><span class="line">  <span class="comment">// 且属性会自动转化为字符串，因此使用数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> romanArr = [[<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>], [<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>], [<span class="number">500</span>, <span class="string">&quot;D&quot;</span>], [<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>], [<span class="number">100</span>, <span class="string">&quot;C&quot;</span>], [<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>], [<span class="number">50</span>, <span class="string">&quot;L&quot;</span>], [<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>], [<span class="number">10</span>, <span class="string">&quot;X&quot;</span>], [<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>], [<span class="number">5</span>, <span class="string">&quot;V&quot;</span>], [<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>], [<span class="number">1</span>, <span class="string">&quot;I&quot;</span>]];</span><br><span class="line">  <span class="keyword">let</span> resStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [val,roman] <span class="keyword">of</span> romanArr)&#123;</span><br><span class="line">      <span class="keyword">while</span>(num &gt;= val)&#123;</span><br><span class="line">          resStr += roman;</span><br><span class="line">          num -= val;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></h3><ul><li>描述<ul><li>给你一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素<code>a</code>，<code>b</code>，<code>c</code> ，使得<code>a + b + c = 0</code> ？请你找出所有和为<code>0</code>且不重复的三元组。</li></ul></li><li>思路<ul><li>暴力搜索<ul><li>略</li></ul></li><li>排序 + 双指针<ul><li>将排好序的数组，依次以某一元素为基准（并去除重复），剩下的元素进行<code>two sum</code>操作（也要去重）。</li><li>有序的<code>tow sum</code>：相加之和小于目标值，左指针<code>left++</code>，相加之和大于于目标值右指针<code>right--</code>。</li><li>其实相当于三指针，只是指针<code>i</code>是依次从左向右移动而已。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">  <span class="comment">// 最小值大于 0 或者 最大值小于 0，说明没有无效答案</span></span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums[nums.<span class="property">length</span> - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前值大于 0，和右侧的值再怎么加也不会等于 0，所以直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前循环的值和上次循环的一样，就跳过，避免重复值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针(two sum)</span></span><br><span class="line">    <span class="keyword">let</span> l = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = nums[i] + nums[l] + nums[r];</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        l++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp === <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([nums[i], nums[l], nums[r]]);</span><br><span class="line">        <span class="comment">// 跳过重复值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></h3><ul><li>描述<ul><li>给你一个长度为<code>n</code>的整数数组<code>nums</code>和一个目标值<code>target</code>。请你从<code>nums</code>中选出三个整数，使它们的和与<code>target</code>最接近。</li><li>返回这三个数的和。</li></ul></li><li>思路<ul><li>排序 + 双指针<ul><li>三之和稍微变化</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Infinity</span>; <span class="comment">// 结果，且过程中保存上一次的最接近值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> left = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right]; <span class="comment">// 当前sum</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 有a+b+c=0则直接返回target</span></span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果上一次的最接近值与目标值之差的绝对值 ＞ 当前值与目标值之差的绝对值</span></span><br><span class="line">            <span class="comment">// 则更新最接近值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(res - target) &gt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(sum - target))&#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></h3><ul><li>描述<ul><li>给定一个仅包含数字<code>2-9</code>的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong>返回。</li><li>给出数字到字母的映射如下（与电话按键相同）。</li><li>注意<code>1</code>不对应任何字母。</li></ul></li><li>思路<ul><li>递推组合（广度优先-非标准）<ul><li>例如：输入<code>&quot;23456&quot;</code>，可先将<code>2</code>和<code>3</code>进行组合，然后保存这个中间结果<code>res</code>。</li><li>然后，再将<code>res</code>与<code>4</code>进行组合，再保存至<code>res</code>…</li><li>直到把最后一个<code>6</code>组合完毕，则<code>res</code>即最终结果。</li></ul></li><li>递归回溯（深度优先）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="keyword">function</span> (<span class="params">digits</span>) &#123;</span><br><span class="line">  <span class="comment">// 为空特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (digits.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> numMap = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;def&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line">  ])</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="string">&quot;&quot;</span>, digits);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">str, digit</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果字符串为空了，将拼接好的字符加入数组</span></span><br><span class="line">    <span class="keyword">if</span> (digit.<span class="property">length</span> === <span class="number">0</span>) res.<span class="title function_">push</span>(str);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 拿到字符串第一个字符，拿到其对应的数字</span></span><br><span class="line">      <span class="keyword">let</span> numstr = numMap.<span class="title function_">get</span>(digit[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">// 对可能性进行组合</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numstr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        str += numstr[i];</span><br><span class="line">        <span class="comment">// 递归组好的 str和下一段字符串</span></span><br><span class="line">        <span class="title function_">dfs</span>(str, digit.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        str = str.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">digits</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="keyword">function</span>(<span class="params">digits</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(digits === <span class="string">&quot;&quot;</span>)&#123;  <span class="comment">// 注意考虑为空情况 *****</span></span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arr =  [[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]];</span><br><span class="line">  <span class="comment">// 存储两组字符组第 n 次组合后的结果（初始值为第一个要参与组合的字符组-可看作第 0 次组合结果）</span></span><br><span class="line">  <span class="comment">// 此数组会递推参与组合，每一次保存当前一次组合产生的结果。</span></span><br><span class="line">  <span class="keyword">let</span> res = [...arr[+digits[<span class="number">0</span>] - <span class="number">2</span>]]; <span class="comment">// 第 0 个数字对应的符号组（可看作第 0 次组合结果）</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>; <span class="comment">// 数字下标</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; digits.<span class="property">length</span>)&#123; <span class="comment">// 当数字遍历完后退出循环</span></span><br><span class="line">      <span class="keyword">let</span> row = +digits[i] - <span class="number">2</span>; <span class="comment">// arr 中行号从0开始，而数字从2开始才有效，因此取出数字后 -2确定行号</span></span><br><span class="line">      <span class="keyword">let</span> n = res.<span class="property">length</span>;   <span class="comment">// 组合前 res 的长度（进入循环长度会随着 push 而增加）</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123; <span class="comment">// 上一次组合结果构成的数组与新字符组进行组合</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; arr[row].<span class="property">length</span>; k++)&#123;</span><br><span class="line">              <span class="keyword">let</span> combination = res[j] + arr[row][k];</span><br><span class="line">              res.<span class="title function_">push</span>(combination);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.<span class="title function_">splice</span>(<span class="number">0</span>,n);  <span class="comment">// 删除上一次组合的结果，留下最新组合结果</span></span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></h4><ul><li>描述<ul><li>给你一个由<code>n</code>个整数组成的数组<code>nums</code>，和一个目标值<code>target</code>。请你找出并返回满足下述全部条件且不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）</li></ul></li><li>思路（降维）<ul><li>将四数之和降为两数之和，套两层循环即可（三数之和套一层）</li><li><strong>注意</strong>：<ul><li>判断重复</li><li><code>target !== 0</code>时，<strong>不能使用</strong> <code>nums[0](nums[n-1]) &lt;(&gt;) target</code>直接返回。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123; <span class="comment">// i 后至少要有 3 位</span></span><br><span class="line">    <span class="keyword">while</span> (i - <span class="number">1</span> !== -<span class="number">1</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123; <span class="comment">// j 后至少要有 2 位</span></span><br><span class="line">      <span class="keyword">while</span> (j - <span class="number">1</span> !== i &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> l = j + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> r = n - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = nums[i] + nums[j] + nums[l] + nums[r];</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; target) &#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; target) &#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp === target) &#123;</span><br><span class="line">          res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">          l++;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l - <span class="number">1</span> !== j &amp;&amp; nums[l] === nums[l - <span class="number">1</span>]) &#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">1</span> !== n &amp;&amp; nums[r] === nums[r + <span class="number">1</span>]) &#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>优化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i - <span class="number">1</span> !== -<span class="number">1</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n -<span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j - <span class="number">1</span> !== i &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> l = j + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> r = n - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = nums[i] + nums[j] + nums[l] + nums[r];</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; target) &#123;</span><br><span class="line">          l++;</span><br><span class="line">          <span class="keyword">continue</span>; <span class="comment">// (*)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; target) &#123;</span><br><span class="line">          r--;</span><br><span class="line">          <span class="keyword">continue</span>; <span class="comment">// (*)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp === target) &#123;</span><br><span class="line">          res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">          l++;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l - <span class="number">1</span>]) &#123; <span class="comment">// (*)</span></span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] === nums[r + <span class="number">1</span>]) &#123; <span class="comment">// (*)</span></span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>代码随想录</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">4</span>) <span class="keyword">return</span> [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 去重i</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 去重j</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l = j + <span class="number">1</span>, r = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) &#123; l++; <span class="keyword">continue</span>&#125;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123; r--; <span class="keyword">continue</span>&#125;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></h3><ul><li>描述<ul><li>数字<code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</li></ul></li><li>思路<ul><li>首先，可以知道的是，在“拼凑”每一组有效括号的过程中，一定满足：<ul><li>左括号数小于等于括号的对数（(左括号 + 右括号)/2）</li><li>右括号小于等于左括号数（当然也小于等于括号对数）</li></ul></li><li>题目要求生成<code>n</code>对的合法括号序列组合，因此可以考虑使用<strong>深度优先搜索</strong>，将搜索顺序定义为枚举序列的每一位填什么，那么最终的答案一定是由n个左括号和n个右括号组成。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>;    <span class="comment">// 左括号已使用数</span></span><br><span class="line">  <span class="keyword">let</span> r = <span class="number">0</span>;    <span class="comment">// 右括号已使用数</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 每一次成功匹配的括号组（遍历到叶子结点）</span></span><br><span class="line">  <span class="keyword">let</span> res = []; <span class="comment">// 结果字符串数组</span></span><br><span class="line">  <span class="title function_">dfs</span>(n, l, r, str, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">n, l, r, str, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (l == n &amp;&amp; r == n) &#123; <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="comment">// 可以返回空，重点是将当前成功匹配的括号组字符串加入结果数组</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">push</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt; n) &#123;  <span class="comment">// 剪枝 已加入的左括号数小于括号总数的一半</span></span><br><span class="line">    <span class="title function_">dfs</span>(n, l + <span class="number">1</span>, r, str + <span class="string">&#x27;(&#x27;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; l) &#123;  <span class="comment">// 剪枝 已加入的右括号数小于左括号数（比左括号限制条件强）</span></span><br><span class="line">    <span class="title function_">dfs</span>(n, l, r + <span class="number">1</span>, str + <span class="string">&#x27;)&#x27;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h3><ul><li>描述<ul><li>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题。</li></ul></li><li><p>思路</p><ul><li>迭代</li><li>递归</li></ul></li><li><p>迭代</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prehead = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    prehead.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">let</span> t = prehead;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> q = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        t.<span class="property">next</span> = q;</span><br><span class="line">        p.<span class="property">next</span> = q.<span class="property">next</span>;</span><br><span class="line">        q.<span class="property">next</span> = p;</span><br><span class="line">        t = p;</span><br><span class="line">        p = p.<span class="property">next</span>;</span><br><span class="line">        q = p?.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prehead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prehead = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    prehead.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">let</span> t = prehead;</span><br><span class="line">    <span class="keyword">while</span>(t.<span class="property">next</span>!==<span class="literal">null</span> &amp;&amp; t.<span class="property">next</span>.<span class="property">next</span> !==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> p = t.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">const</span> q = t.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        t.<span class="property">next</span> = q;</span><br><span class="line">        p.<span class="property">next</span> = q.<span class="property">next</span>;</span><br><span class="line">        q.<span class="property">next</span> = p;</span><br><span class="line">        t = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prehead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>递归</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 初级算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 描述</span></span><br><span class="line"><span class="string">  * 给你一个有序数组`</span>nums<span class="string">`，请你**原地**删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新**长度**。</span></span><br><span class="line"><span class="string">  * 不要使用额外的数组空间，你必须在**原地**修改输入数组并在使用`</span><span class="title function_">O</span>(<span class="number">1</span>)<span class="string">`额外空间的条件下完成。</span></span><br><span class="line"><span class="string">* 思路</span></span><br><span class="line"><span class="string">  * 遍历有序数组，相等删除</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index, list</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i = index+<span class="number">1</span>; value === list[i]; )&#123;  <span class="comment">// 注意此处 i 无需自增，因为删除数组元素后，i 已指向“下一个元素”</span></span><br><span class="line">           nums.<span class="title function_">splice</span>(i,<span class="number">1</span>);   <span class="comment">// 从 i 开始删除 1 个元素（不能用 delete list[i]，会保留位置）     </span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> nums.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法<ul><li>思路<ul><li>由于给定的数组nums是有序的,因此对于任意$i&lt;j$，如果$nums[i]=nums[j]$,则对任意$i≤k≤j$必有$nums[i]=nums[k]=nums[j]$，即相等的元素在数组中的下标一定是连续的。利用数组有序的点,可以通过双指针的方法刪除重复元素。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针 （ slow 指向预备改变的位置）</span></span><br><span class="line">    <span class="keyword">let</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 如果 nums[fast] !== nums[fast - 1]</span></span><br><span class="line">        <span class="comment">// 说明 nums[fast] 和之前的元素都不同</span></span><br><span class="line">        <span class="keyword">if</span> (nums[fast] !== nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[slow]改变后 或 遇到相同元素后 fast 都得加 1</span></span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素。</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h3><ul><li>思路（贪心）<ul><li>股票买卖策略<ul><li>单独交易日：设今天价格$p_1$、明天价格$p_2$，则今天买入、明天卖出可赚取金额$p_2-p_1$(负值代表亏损）。</li><li>连续上涨交易日：<ul><li>设此上张交易日股票价格分別为$p_1,p_2,…,p_n$，则第一天买最后一天卖收益最大，即$p_n-p_1$。</li><li>等价于每天都买卖。</li></ul></li><li>连续下降交易日：则不买卖收益最大,即不会亏钱。</li></ul></li><li>故只需将相邻两天价格差为正的差价加起来，即为最大收益。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;prices[i+<span class="number">1</span>])&#123;</span><br><span class="line">            max += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">轮转数组</a></h3><ul><li>描述<ul><li>给你一个数组，将数组中的元素向右轮转<code>k</code>个位置，其中<code>k</code>是非负数。</li></ul></li><li>思路<ul><li>切片连接</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意此处 的 -k%nums.length </span></span><br><span class="line">    <span class="comment">// 当 k &gt; nums.length 时，需要取模</span></span><br><span class="line">    <span class="keyword">let</span> arr = nums.<span class="title function_">splice</span>(-k%nums.<span class="property">length</span>, nums.<span class="property">length</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.<span class="property">length</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        nums.<span class="title function_">unshift</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>改进版本</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    k = k % nums.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// arr.splice()返回被删除的数组</span></span><br><span class="line">    <span class="keyword">let</span> temp = nums.<span class="title function_">splice</span>(-k);</span><br><span class="line">    nums.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">0</span>, ...temp) <span class="comment">// ...ES6扩展运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/">存在重复元素</a></h3><ul><li><p>描述</p><ul><li>给你一个整数数组<code>nums</code>。如果任一值在数组中出现<strong>至少两次</strong>，返回<code>true</code>；如果数组中每个元素互不相同，返回<code>false</code>。</li></ul></li><li><p>思路（超时）</p><ul><li>遍历数组后删除对应元素</li><li>使用<code>includes()</code>判断是否任然存在该元素</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">  nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = item;</span><br><span class="line">    <span class="comment">// array.splice(index, 1);  </span></span><br><span class="line">    <span class="comment">// 不能使用splice删除，因为不会保留位置</span></span><br><span class="line">    <span class="comment">// 而index是根据原数组得来的，会导致删除的元素不对</span></span><br><span class="line">    <span class="keyword">delete</span> array[index];</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="title function_">includes</span>(temp)) &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>思路（排序）<ul><li>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>思路（哈希表）<ul><li>对于数组中每个元素，将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="title function_">has</span>(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.<span class="title function_">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></h3><ul><li>描述<ul><li>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</li><li>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</li></ul></li><li>思路（空间复杂度：$O(n)$）<ul><li>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</li><li>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</li><li>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</li></ul></li><li>思路（<strong>位运算</strong>）<ul><li>任何数和$0$做异或运算，结果仍然是原来的数，即$a⊕0=a$。</li><li>任何数和其自身做异或运算，结果是$0$，即$a⊕a=0$。</li><li>异或运算满足交换律和结合律</li><li>$a⊕b⊕a=b⊕(a⊕a)$</li><li>$b⊕(a⊕a)=b⊕0=b$</li><li><strong>数组中的全部元素的异或运算结果即为数组中只出现一次的数字</strong>。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 位运算</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev ^ curr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  nums.<span class="title function_">forEach</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 存在则 +1 不存在则 1</span></span><br><span class="line">    map[val] = map[val] + <span class="number">1</span> || <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">    <span class="keyword">if</span>(map[key] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">两个数组的交集 II</a></h3><ul><li>描述<ul><li>给你两个整数数组<code>nums1</code>和<code>nums2</code>，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</li></ul></li><li>思路<ul><li>分别以两个数组对的数组元素为键，出现次数为值，创建哈希表。然后遍历两个哈希表找出共同元素，插入<code>n</code>次入数组（<code>n</code>为较小值）。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// value：数组元素（作为键）；count：出现次数（作为值）；</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    nums1.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// map1[value] = map1.get((value)) + 1 || 1;  建议使用 set</span></span><br><span class="line">        map1.<span class="title function_">set</span>(value,map1.<span class="title function_">get</span>((value)) + <span class="number">1</span> || <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    nums2.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        map2.<span class="title function_">set</span>(value,map2.<span class="title function_">get</span>((value)) + <span class="number">1</span> || <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key1 <span class="keyword">of</span> map1.<span class="title function_">keys</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key2 <span class="keyword">of</span> map2.<span class="title function_">keys</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(key1===key2)&#123;</span><br><span class="line">                <span class="keyword">let</span> count1 = map1.<span class="title function_">get</span>(key1);</span><br><span class="line">                <span class="keyword">let</span> count2 = map2.<span class="title function_">get</span>(key2);</span><br><span class="line">                <span class="keyword">if</span>(count1 &gt;= count2)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;= count2; i++)&#123;</span><br><span class="line">                        arr.<span class="title function_">push</span>(key2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;= count1; i++)&#123;</span><br><span class="line">                        arr.<span class="title function_">push</span>(key1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li><li>思路（一个哈希表）<ul><li>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。</li><li>为了降低空间复杂度，<strong>首先遍历较短的数组</strong>并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line"><span class="comment">// 长短交换判定</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.<span class="property">length</span> &gt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">intersect</span>(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hashmap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="comment">// 将较短的nums1中的元素与个数存入hashmap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = hashmap.<span class="title function_">get</span>(num) || <span class="number">0</span>;</span><br><span class="line">        hashmap.<span class="title function_">set</span>(num, count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [], index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历nums2，遇到重复则count--并更新hashmap</span></span><br><span class="line"><span class="comment">// 遇到重复说明两个数组都有该元素</span></span><br><span class="line"><span class="comment">// cout==0说明先存进 hashmap 中的数组的对应某元素已经全部加入新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = hashmap.<span class="title function_">get</span>(num) || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[index++] = num;</span><br><span class="line">            count--;</span><br><span class="line"><span class="comment">// 更新 hashmap，以count状态作为判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                hashmap.<span class="title function_">set</span>(num, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashmap.<span class="title function_">delete</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>思路（排序+双指针）<ul><li>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li><li>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字<strong>不相等</strong>，则将指向较小数字的指针<strong>右移</strong>一位，如果两个数字<strong>相等</strong>，将该数字<strong>添加到答案</strong>，并将两个指针都<strong>右移</strong>一位。当至少有一个指针超出数组范围时，遍历结束。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line"><span class="comment">//将两个数组从小到大排序</span></span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    nums2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> key1 = <span class="number">0</span>, key2 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//在两个指针不达边界的前提下不断推进</span></span><br><span class="line">    <span class="keyword">while</span>(key1 &lt; nums1.<span class="property">length</span> &amp;&amp; key2 &lt; nums2.<span class="property">length</span>)&#123;</span><br><span class="line"><span class="comment">//判断nums1[key1]与nums2[key2]的大小，分出大于小于等于三种情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums1[key1] &lt; nums2[key2]) key1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[key1] &gt; nums2[key2]) key2++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res[index++] = nums1[key1];</span><br><span class="line">            key1++;</span><br><span class="line">            key2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode-cn.com/problems/plus-one/">加一</a></h3><ul><li>描述<ul><li>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</li><li>最高位数字存放在数组的首位，数组中每个元素只存储单个数字。</li><li>你可以假设除了整数<code>0</code>之外，这个整数不会以零开头。</li></ul></li><li>思路（js方法）<ul><li>数组 -&gt; 大整数 -&gt; +1 -&gt; 数组（-&gt;表示转换类型）</li><li>基于js是一门非常高级的语言，已经封装好了很多方法，直接调用方法完成，虽然方便但忽略了算法。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">digits</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> plusOne = <span class="keyword">function</span>(<span class="params">digits</span>) &#123;</span><br><span class="line">    <span class="comment">// 将数组转化成 字符串 =&gt; 大整数（否则可能会超出范围）</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="title class_">BigInt</span>(digits.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">// num = num.toString()</span></span><br><span class="line">    <span class="comment">// let arr = Array.from(num);</span></span><br><span class="line">    <span class="keyword">return</span>  num.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li><li>思路（找出最长的后缀<code>9</code>）<ul><li>如果<code>digits</code>的末尾没有<code>9</code>，例如<code>[1,2,3]</code>，那么我们直接将末尾的数加一，得到<code>[1,2,4]</code>并返回；</li><li>如果<code>digits</code>的末尾有若干个<code>9</code>，例如<code>[1,2,3,9,9]</code>，那么我们只需要找出从末尾开始的第一个不为<code>9</code>的元素，即<code>3</code>，将该元素加一，得到<code>[1,2,4,9,9]</code>。随后将末尾的<code>9</code>全部置零，得到<code>[1,2,4,0,0]</code>并返回。</li><li>如果<code>digits</code>的所有元素都是<code>9</code>，例如<code>[9,9,9,9,9]</code>，那么答案为<code>[1,0,0,0,0,0]</code>。我们只需要构造一个长度比<code>digits</code>多<code>1</code>的新数组，将首元素置为<code>1</code>，其余元素置为<code>0</code>即可。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="keyword">function</span>(<span class="params">digits</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = digits.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 找出第一个不为 9 的元素，将其加 1 并将后续所有元素置零</span></span><br><span class="line">    <span class="comment">// 包括了第一二种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] !== <span class="number">9</span>) &#123;</span><br><span class="line">            ++digits[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                digits[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// digits 中所有的元素均为 9（第三种情况）</span></span><br><span class="line">    <span class="keyword">const</span> ans = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></h3><ul><li>描述<ul><li>给定一个数组<code>nums</code>，编写一个函数将所有<code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</li><li>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</li></ul></li><li>思路<ul><li>考虑到js对数组封装的方法丰富，就不使用找零移动法了</li><li>将数组中为<code>0</code>的元素删除，并计数<code>count</code>，删除全部<code>0</code>后，在数组末尾插入<code>count</code>个<code>0</code>。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i]===<span class="number">0</span>)&#123;</span><br><span class="line">          nums.<span class="title function_">splice</span>(i,<span class="number">1</span>);</span><br><span class="line">          count++;</span><br><span class="line">          n--;  <span class="comment">// 删除元素后长度 n 应减 1</span></span><br><span class="line">          i--;  <span class="comment">// 删除元素后当前下标实际指向的是下一个元素应减 1</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(count)&#123;</span><br><span class="line">      nums.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">      count--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line">  nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value,index,arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(value === <span class="number">0</span>)&#123;</span><br><span class="line">          arr.<span class="title function_">splice</span>(index,<span class="number">1</span>);</span><br><span class="line">          <span class="comment">// forEach()中的 index 虽然在函数体中改变，但不会有效果</span></span><br><span class="line">          index--;</span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li>官方解法<ul><li>思路（双指针 类似冒泡排序）<ul><li>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</li><li>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</li><li>注意到以下性质：<ul><li>左指针左边均为非零数</li><li>右指针左边直到左指针处均为零。</li><li>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是写复杂了呀</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;  <span class="comment">// 找到第一个为 0 的元素</span></span><br><span class="line">      <span class="keyword">let</span> j = <span class="number">0</span>;  <span class="comment">// 写在 for循环外 因为for循环外 要用</span></span><br><span class="line">      <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] !== <span class="number">0</span>) &#123;  <span class="comment">// 如果 j 指向非 0 则交换</span></span><br><span class="line">          nums[i] = nums[j];</span><br><span class="line">          nums[j] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当 j 指向最后一个元素（此时数组已经任务）</span></span><br><span class="line">      <span class="comment">// 可以结束最外层循环</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt; n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个好点</span></span><br><span class="line"><span class="comment">// 两个指针都从左侧出发，左指针遇 0 等待，与下一个非零数交换</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意 这里必须使用 temp 变量而不能直接使用 0 赋值</span></span><br><span class="line">            <span class="comment">// 原因是：开始时 l r 指向同一个元素且可能不为 0</span></span><br><span class="line">            <span class="comment">// 注意与上面写的区别</span></span><br><span class="line">            <span class="keyword">let</span> temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">有效的数独</a></h3><ul><li>描述<ul><li>请你判断一个<code>9 x 9</code>的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<ul><li>数字<code>1-9</code>在每一行只能出现一次。</li><li>数字<code>1-9</code>在每一列只能出现一次。</li><li>数字<code>1-9</code>在每一个以粗实线分隔的<code>3x3</code>宫内只能出现一次。</li><li>空白格用’.’表示。</li></ul></li></ul></li><li>思路（三次遍历）<ul><li>利用哈希唯一性，按规则扫描表格内的数，插入哈希表，若已存则在返回<code>false</code>；若扫描完成未发现重复则返回<code>true</code>。</li><li>分别按行、列、<code>3 × 3</code>块扫描。</li><li>其中块扫描按块进行列扫面，即先扫描左边<code>3 × 9</code>组成的3个列块，然后向右依次扫描。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[][]</span>&#125; <span class="variable">board</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="keyword">function</span> (<span class="params">board</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> len = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">let</span> llen = <span class="number">3</span>; <span class="comment">// 每一个小块边长 3 </span></span><br><span class="line">  <span class="comment">// 判断行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="comment">// &quot;.&quot;代表空，不作为重复条件判定</span></span><br><span class="line">      <span class="keyword">if</span> (hash.<span class="title function_">has</span>(board[i][j]) &amp;&amp; board[i][j] !== <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash.<span class="title function_">set</span>(board[i][j], <span class="number">0</span>); <span class="comment">// 这里的value 0 没啥用</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash.<span class="title function_">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hash.<span class="title function_">has</span>(board[j][i]) &amp;&amp; board[j][i] !== <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash.<span class="title function_">set</span>(board[j][i], <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash.<span class="title function_">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断3*3</span></span><br><span class="line">  <span class="comment">// iStart、jStart分别代表行、列开始的下标</span></span><br><span class="line">  <span class="keyword">let</span> iStart = <span class="number">0</span>, jStart = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// jStart &lt; 9 扫描结束（已经扫到最右下角的块）</span></span><br><span class="line">  <span class="keyword">while</span> (jStart &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="comment">// 扫描每一 3 × 3块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = iStart; i &lt; llen + iStart; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = jStart; j &lt; llen + jStart; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="title function_">has</span>(board[i][j]) &amp;&amp; board[i][j] !== <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          hash.<span class="title function_">set</span>(board[i][j], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash.<span class="title function_">clear</span>(); <span class="comment">// 某一块扫描完成，清除哈希表</span></span><br><span class="line">    iStart += <span class="number">3</span>;  <span class="comment">// 修改iStart 至下一块 行开始位置</span></span><br><span class="line">    <span class="keyword">if</span> (iStart &gt;= <span class="number">9</span>) &#123;  <span class="comment">// iStart &gt;= 9 说明某一“块列”扫描完成</span></span><br><span class="line">      iStart = <span class="number">0</span>;     <span class="comment">// 重置 iStart 至下一列”块列“ 的行开始位置</span></span><br><span class="line">      jStart += <span class="number">3</span>;    <span class="comment">// 修改 jStart 至下一列“块列” 的列开始位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li><li>思路（一次遍历）<ul><li>创建二维数组<code>rows</code>和<code>columns</code>分别记录数独的每一行和每一列中的每个数字的出现次数，创建三维数组 <code>subbozes</code>记录数独的每一个小九官格中的每个数字的出现次数。</li><li>其中$rows[i][index]、\textit{columns}[j][\textit{index}]$</li><li>$columns[j][index]$和$subboxes[⌊\frac{i}{3}⌋][⌊\frac{j}{3}⌋][index]$</li><li>分别表示数独的第<code>i</code>行第<code>j</code>列的单元格所在的行、列和小九宫格中,数字<code>index+1</code>出现的次数,其中<code>0≤index&lt;9</code>,对应的数字<code>index+1</code>满足<code>1≤inde+1≤9</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="keyword">function</span>(<span class="params">board</span>) &#123;</span><br><span class="line">  <span class="comment">// arr.map()：对数组的每个元素都调用函数，并返回结果数组</span></span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">const</span> columns = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">const</span> subboxes = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>)));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">const</span> c = board[i][j];</span><br><span class="line">          <span class="keyword">if</span> (c !== <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">              <span class="keyword">const</span> index = c.<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;0&#x27;</span>.<span class="title function_">charCodeAt</span>() - <span class="number">1</span>;</span><br><span class="line">              rows[i][index]++;</span><br><span class="line">              columns[j][index]++;</span><br><span class="line">              <span class="comment">// i：0-2；j：0-2代表一个 3×3 单元格</span></span><br><span class="line">              subboxes[<span class="title class_">Math</span>.<span class="title function_">floor</span>(i / <span class="number">3</span>)][<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">3</span>)][index]++;</span><br><span class="line">              <span class="keyword">if</span> (rows[i][index] &gt; <span class="number">1</span> || columns[j][index] &gt; <span class="number">1</span> || subboxes[<span class="title class_">Math</span>.<span class="title function_">floor</span>(i / <span class="number">3</span>)][<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">3</span>)][index] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">旋转图像</a></h3><ul><li>描述<ul><li>给定一个<code>n×n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。</li><li>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</li></ul></li><li>思路<ul><li>找出旋转前后下标变化规律</li><li>关键等式：</li><li><code>matrixNew[col][n−row−1]=matrix[row][col]</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(len/<span class="number">2</span>); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>((len+<span class="number">1</span>)/<span class="number">2</span>); j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[len-j-<span class="number">1</span>][i];</span><br><span class="line">            matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>];</span><br><span class="line">            matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>];</span><br><span class="line">            matrix[j][len-i-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a></h3><ul><li>描述<ul><li>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</li><li>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</li></ul></li><li>思路<ul><li>调用内建方法<code>reverse()</code></li><li>双指针</li><li>解构语法</li><li>位运算</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        [s[left++],s[right--]] = [s[right],s[left]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></h3><ul><li>描述<ul><li>你一个<code>32</code>位的有符号整数<code>x</code>，返回将<code>x</code>中的数字部分反转后的结果。</li><li>如果反转后整数超过<code>32</code>位的有符号整数的范围<code>[−2^31, 2^31 − 1]</code> ，就返回<code>0</code>。</li><li><strong>假设环境不允许存储<code>64</code>位整数</strong>（有符号或无符号）。</li></ul></li><li>思路<ul><li>先将输入整数的位数计算出来，以便计算每一位应对应的权重（转化后在什么位上）。</li><li>通过整除、取余获取尾部数字，乘以转化后对应的位的权重，然后相加。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里将它转化成绝对值 </span></span><br><span class="line">  <span class="comment">// 因为 对于负数 floor()向下取整时：floor(-1.2) === 2 而非 1</span></span><br><span class="line">  <span class="keyword">let</span> temp = x = <span class="title class_">Math</span>.<span class="title function_">abs</span>(x);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    temp = <span class="title class_">Math</span>.<span class="title function_">floor</span>(temp / <span class="number">10</span>);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (count) &#123;</span><br><span class="line">    result += x % <span class="number">10</span> * <span class="number">10</span> ** (count - <span class="number">1</span>);</span><br><span class="line">    x = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">10</span>);</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result &lt; (-<span class="number">2</span>) ** <span class="number">31</span> || result &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag ? -result : result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> digit = x % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 向 0 取整</span></span><br><span class="line">        x = ~~(x / <span class="number">10</span>); <span class="comment">// ~~ 正数时是Math.floor()的替代品</span></span><br><span class="line">        rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        <span class="keyword">if</span> (rev &lt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(-<span class="number">2</span>, <span class="number">31</span>) || rev &gt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">字符串中的第一个唯一字符</a></h3><ul><li>描述<ul><li>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</li></ul></li><li>思路<ul><li>遍历字符串利用hashmap以字符为<code>key</code>、<code>&#123;index:null,count:null&#125;</code>为<code>value</code>，存储字符的下标<code>index</code>和出现次数<code>count</code>。</li><li>遍历哈希表找到第一个<code>count === 1</code>的映射，并返回其下标。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> char = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  char.<span class="title function_">forEach</span>(<span class="function">(<span class="params">c, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(c)) &#123;</span><br><span class="line">      map.<span class="title function_">get</span>(c).<span class="property">count</span>++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.<span class="title function_">set</span>(c, &#123; <span class="attr">index</span>: index, <span class="attr">count</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">count</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.<span class="property">index</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 字符串没有不重复的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能用 forEach()遍历，因为难以跳出整个循环</span></span><br><span class="line">  <span class="comment">// map.forEach((obj) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   if(obj.count === 1)&#123;</span></span><br><span class="line">  <span class="comment">//     result = obj.index;</span></span><br><span class="line">  <span class="comment">//     return false;  // 仅跳出本次循环 而非整个 forEach</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li><li>思路<ul><li>我们可以对字符串进行两次遍历。</li><li>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。</li><li>在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回<code>-1</code>。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="comment">//_.countBy方法创建一个由键组成的对象，这些键是通过运行iteratee的collection的每个元素的结果生成的。每个 key 的对应值是iteratee返回 key 的次数。</span></span><br><span class="line">    <span class="keyword">const</span> frequency = _.<span class="title function_">countBy</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [i, ch] <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(s).<span class="title function_">entries</span>()) &#123;  <span class="comment">// arr.entries()返回[key,value]</span></span><br><span class="line">        <span class="keyword">if</span> (frequency[ch] === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">有效的字母异位词</a></h3><ul><li>描述<ul><li>给定两个字符串<code>s</code>和<code>t</code>，编写一个函数来判断<code>t</code>是否是<code>s</code>的字母异位词。</li><li>注意：若<code>s</code>和<code>t</code>中每个字符出现的次数都相同，则称<code>s</code>和<code>t</code>互为字母异位词。</li></ul></li><li>思路<ul><li>首先判断字符串长度是否相等，不相等直接<code>return false</code>。</li><li>利用hashmap，扫描字符串字符存入map并记录出现次数。</li><li>扫描第二个字符串判断map中是否已经存在：<ul><li>若存在则次数减<code>1</code>，若次数减至<code>&lt; 0</code>则<code>return false</code>；</li><li>若不存在<code>return false</code>（不存在说明第二个串用了第一个没有使用的字符） 。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> !== t.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(item))&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(item, map.<span class="title function_">get</span>(item)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(item,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(item))&#123;</span><br><span class="line">             map.<span class="title function_">set</span>(item, map.<span class="title function_">get</span>(item)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="title function_">get</span>(item) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>官方解法</li><li>思路<ul><li>排序</li><li>判断字符串是否相等</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="property">length</span> == t.<span class="property">length</span> &amp;&amp; [...s].<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) === [...t].<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h3><ul><li>描述<ul><li>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</li><li>说明：本题中，我们将空字符串定义为有效的回文串。</li></ul></li><li>思路<ul><li>双指针</li><li>正则表达式（两年前学过忘记了，用得很笨拙）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="comment">// 为什么要转化成数组？</span></span><br><span class="line">  <span class="comment">// 因为js中字符串不可更改</span></span><br><span class="line">  <span class="comment">// 即 s[0]=s[0].toLowerCase()无效</span></span><br><span class="line">  <span class="keyword">let</span> strArr = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> r = strArr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 正则：数字和字母</span></span><br><span class="line">  <span class="keyword">let</span> re = <span class="regexp">/[0-9A-Za-z]/g</span>;  <span class="comment">// 等同于/\w/g</span></span><br><span class="line">  <span class="comment">// 正则：大写字母</span></span><br><span class="line">  <span class="keyword">let</span> reUp = <span class="regexp">/[A-Z]/g</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="comment">// 如果不是数字或字母 指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (!strArr[l].<span class="title function_">match</span>(re)) &#123;</span><br><span class="line">      l++;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 指针移动后得先再判断 l &lt; r?和再次判断是否为数字或字母</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!strArr[r].<span class="title function_">match</span>(re)) &#123;</span><br><span class="line">      r--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是大写字母 转换成小写</span></span><br><span class="line">    <span class="keyword">if</span> (strArr[l].<span class="title function_">match</span>(reUp)) &#123;</span><br><span class="line">      strArr[l] = strArr[l].<span class="title function_">toLowerCase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strArr[r].<span class="title function_">match</span>(reUp)) &#123;</span><br><span class="line">      strArr[r] = strArr[r].<span class="title function_">toLowerCase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strArr[l] === strArr[r]) &#123;</span><br><span class="line">      l++;</span><br><span class="line">      r--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其他解法</li><li>思路<ul><li>和我一样，但是正则比我用的好</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// s = s.replace(/[^\w]/g, &#x27;&#x27;).toLowerCase()</span></span><br><span class="line">    <span class="comment">// 题目要求只考虑字母和数字字符，所以上面的写法也没啥问题</span></span><br><span class="line">    s = s.<span class="title function_">replace</span>(<span class="regexp">/[^0-9a-zA-Z]/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">toLowerCase</span>()  <span class="comment">// 还没学js正则的api 上面我写的像坨xx</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right]) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></h3><ul><li>描述<ul><li>实现<code>strStr()</code>函数。</li><li>给你两个字符串<code>haystack</code>和<code>needle</code>，请你在<code>haystack</code>字符串中找出<code>needle</code>字符串出现的第一个位置（下标从<code>0</code>开始）。如果不存在，则返回<code>-1</code> 。</li><li>说明：<ul><li>当<code>needle</code>是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</li><li>对于本题而言，当<code>needle</code>是空字符串时我们应当返回<code>0</code>。这与C语言的<code>strstr()</code>以及Java的<code>indexOf()</code>定义相符。</li></ul></li></ul></li><li>思路（暴力搜索）<ul><li>双指针</li><li>分别指向源串和子串，比较、回溯（源串回溯至第一个匹配位置的下一位，模式串回溯至<code>0</code>）</li><li>模式串指针指向最后一位字符的下一位，则代表匹配成功。</li><li>源串指针指向最后一位字符的下一位，且此时模式串没有指向最后一位字符的下一位则匹配失败。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span> (<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hLen = haystack.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> nLen = needle.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (nLen &gt; hLen) &#123;  <span class="comment">// 模式串长度大于源串必定找不到</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needle === <span class="string">&quot;&quot;</span>) &#123;  <span class="comment">// 别忘记这个特殊模式串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (p &lt; hLen) &#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack[p] === needle[q]) &#123;  <span class="comment">// 字符匹配指针移动</span></span><br><span class="line">      p++;</span><br><span class="line">      q++;</span><br><span class="line">      <span class="keyword">if</span> (q &gt; nLen - <span class="number">1</span>) &#123; <span class="comment">// 模式串指针已经移动到“溢出”字符串？</span></span><br><span class="line">        <span class="keyword">return</span> p - nLen;  <span class="comment">// 代表匹配成功，返回源串下标（注意下标的计算）</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则回溯</span></span><br><span class="line">      p = p - q + <span class="number">1</span>;  <span class="comment">// p指针回溯（注意计算）</span></span><br><span class="line">      q = <span class="number">0</span>;  <span class="comment">// q指针回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其他思路<ul><li>KMP（略）</li><li>滑动窗口（略）</li></ul></li></ul><h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">删除链表中的节点</a></h3><ul><li>描述<ul><li>请编写一个函数，用于<strong>删除单链表中某个特定节点</strong>。在设计函数时需要注意，你无法访问链表的头节点<code>head</code>，只能<strong>直接访问</strong>要被删除的节点 。</li><li>题目数据保证需要删除的节点<strong>不是末尾节点</strong>。</li></ul></li><li>思路<ul><li>复制下一个结点的值 -&gt; 删除下一个节点。</li><li>(我觉得我又行了!）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    node.<span class="property">val</span> = node.<span class="property">next</span>.<span class="property">val</span>;</span><br><span class="line">    node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h3><ul><li>描述<ul><li>给你单链表的头节点<code>head</code>，请你反转链表，并返回反转后的链表。</li></ul></li><li>思路<ul><li>略</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> q = head;</span><br><span class="line">    <span class="keyword">let</span> r = head?.<span class="property">next</span>; <span class="comment">// head可能为空</span></span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        q.<span class="property">next</span> = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = r?.<span class="property">next</span>;  <span class="comment">// 遍历到最后时，尾部节点 r 可能为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种解法排除了可能为空而无法调用.next而报错的情况</span></span><br><span class="line"><span class="comment">// var reverseList = function(head) &#123;</span></span><br><span class="line"><span class="comment">//     let prev = null;</span></span><br><span class="line"><span class="comment">//     let curr = head;</span></span><br><span class="line"><span class="comment">//     while (curr) &#123;</span></span><br><span class="line"><span class="comment">//         const next = curr.next;</span></span><br><span class="line"><span class="comment">//         curr.next = prev;</span></span><br><span class="line"><span class="comment">//         prev = curr;</span></span><br><span class="line"><span class="comment">//         curr = next;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return prev;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h3><ul><li>描述<ul><li>给你一个链表，删除链表的倒数第<code>n</code>个结点，并且返回链表的头结点。</li></ul></li><li>思路<ul><li>计算链表长度</li><li>首先从头节点开始对链表进行一次遍历，得到链表的长度<code>L</code>。随后我们再从头节点开始对链表进行一次遍历，当遍历到第<code>L-n+1</code>个节点时，它就是我们需要删除的节点。</li><li>注意<ul><li>没有头结点的链表注意表头元素的删除方法需要单独编写</li><li>若使用复制删除法，则尾部结点的删除方法也需要单独编写</li></ul></li><li>其他<ul><li>双指针<ul><li>由于我们需要找到倒数第<code>n</code>个节点，因此我们可以使用两个指针<code>first</code>和<code>second</code>同时对链表进行遍历，并且<code>first</code>比<code>second</code>超前<code>n</code>个节点。当<code>first</code>遍历到链表的末尾时，<code>second</code>就恰好处于倒数第<code>n</code>个节点。</li></ul></li><li>栈</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sumCount = <span class="number">0</span>;  <span class="comment">// 总结点数 链表长度</span></span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    sumCount++;</span><br><span class="line">    p = p.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> index = sumCount - n + <span class="number">1</span>;  <span class="comment">// 删除第index个结点（从1开始）</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">1</span>;  <span class="comment">// 当前遍历到第 count 个结点</span></span><br><span class="line">  p = head;</span><br><span class="line">  <span class="keyword">if</span> (index === <span class="number">1</span>) &#123;    <span class="comment">// 由于没有头结点，删除首节点时需要单独操作</span></span><br><span class="line">    <span class="comment">// 直接让head指向下一个结点</span></span><br><span class="line">    head = p.<span class="property">next</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === sumCount) &#123;   <span class="comment">// 删除尾结点需要单独操作</span></span><br><span class="line">    <span class="comment">// 当count===index 使 p 指向index -1，被删除的结点前一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">      p = p.<span class="property">next</span>;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当count===index 使 p 指向index，即，将被删除的结点</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; index) &#123;  <span class="comment">// 除以上情况外，进行常规删除操作</span></span><br><span class="line">      p = p.<span class="property">next</span>;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除操作（赋值替换）</span></span><br><span class="line">    p.<span class="property">val</span> = p.<span class="property">next</span>.<span class="property">val</span>;</span><br><span class="line">    p.<span class="property">next</span> = p.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h3><ul><li>描述<ul><li>将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</li></ul></li><li>思路<ul><li>迭代</li><li>递归</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">list1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">list2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = list1;</span><br><span class="line">    <span class="keyword">let</span> q = list2;</span><br><span class="line">    <span class="keyword">let</span> r = head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="literal">undefined</span>,<span class="literal">undefined</span>);</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)&#123;    <span class="comment">// 如果任意链表遍历至完成（指向null）跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(p.<span class="property">val</span> &lt; q.<span class="property">val</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="title class_">ListNode</span>(p.<span class="property">val</span>,<span class="literal">null</span>);</span><br><span class="line">            r.<span class="property">next</span> = temp;</span><br><span class="line">            r = r.<span class="property">next</span>;</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="title class_">ListNode</span>(q.<span class="property">val</span>,<span class="literal">null</span>);</span><br><span class="line">            r.<span class="property">next</span> = temp;</span><br><span class="line">            r = r.<span class="property">next</span>;</span><br><span class="line">            q = q.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若p(q)空，则将q(p)直接接入新链表即可</span></span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        r.<span class="property">next</span> = q;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">        r.<span class="property">next</span> = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">        l1.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1.<span class="property">next</span>, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1, l2.<span class="property">next</span>);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></h3><ul><li>描述<ul><li>给你一个单链表的头节点<code>head</code>，请你判断该链表是否为回文链表。如果是，返回<code>true</code>；否则，返回<code>false</code>。</li></ul></li><li>思路<ul><li>将值复制到数组中后用双指针法</li><li>递归</li><li>快慢指针</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vals = [];</span><br><span class="line">    <span class="keyword">while</span> (head !== <span class="literal">null</span>) &#123;</span><br><span class="line">        vals.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = vals.<span class="property">length</span> - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals[i] !== vals[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></h3><ul><li>描述<ul><li>给你一个链表的头节点<code>head</code>，判断链表中是否有环。</li></ul></li><li>思路<ul><li>利用数据结构集合（或哈希表）的唯一性，也可以用数组的<code>includes()</code>方法<ul><li>遍历链表加入集合，重复则<code>true</code>，反之<code>true</code>。</li></ul></li><li>快慢指针<ul><li>定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置<code>head</code>，而快指针在位置<code>head.next</code>。</li><li>这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="title function_">has</span>(p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.<span class="title function_">add</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">let</span> fast = head.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">    <span class="keyword">if</span>(slow === fast) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow = slow?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">    fast = fast?.<span class="property">next</span>?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;最近在学习&lt;code&gt;JavaScript&lt;/code&gt;，刷题也用顺便巩固，两全其美。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;罗马数字转整数&quot;&gt;&lt;a href=&quot;#罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;罗马数字转整数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-integer/&quot;&gt;罗马数字转整数&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;思路&lt;ul&gt;
&lt;li&gt;通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://tianyuzhou.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>我的图库</title>
    <link href="http://tianyuzhou.github.io/2022/01/03/%E7%9B%B8%E5%86%8C/"/>
    <id>http://tianyuzhou.github.io/2022/01/03/%E7%9B%B8%E5%86%8C/</id>
    <published>2022-01-03T14:30:00.000Z</published>
    <updated>2022-01-03T15:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="用指尖记录生活"><a href="#用指尖记录生活" class="headerlink" title="用指尖记录生活"></a>用指尖记录生活</h3><h2 id="神木垒"><a href="#神木垒" class="headerlink" title="神木垒"></a>神木垒</h2><ul><li>我慢慢的听，雪落下的声音。</li></ul><div class="justified-gallery"><img src="https://pic.zty.plus/2021/12/25DSC05074.jpg~to_1920x1280" alt="雪山" /><img src="https://pic.zty.plus/2021/12/25DSC05088.jpg~to_1920x1280" alt="雪路" /><img src="https://pic.zty.plus/2021/12/25DSC05188.jpg~to_1920x1280" alt="雪人" /><img src="https://pic.zty.plus/2021/12/25DSC05191.jpg~to_1920x1280" alt="雪林" /><img src="https://pic.zty.plus/2021/12/25DSC05248.jpg~to_1920x1280" alt="雪林" /><img src="https://pic.zty.plus/2021/12/25DSC05262%282%29.jpg~to_1920x1280" alt="阳光" /><img src="https://pic.zty.plus/2021/12/25DSC05051%281%29.jpg~to_1920x1280" alt="湖泊" /></div><span id="more"></span><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ul><li>请走慢一点，等一等你的灵魂。</li></ul><div class="justified-gallery"><img src="https://pic.zty.plus/1614418221606.jpg" alt="餐车·蓬" /><img src="https://pic.zty.plus/1614418221595.jpg" alt="餐车" /><img src="https://pic.zty.plus/1614418221589.jpg" alt="杂枝" /><img src="https://pic.zty.plus/1614418221585.jpg" alt="船" /><img src="https://pic.zty.plus/1614421341276.jpg" alt="荒" /><img src="https://pic.zty.plus/1614421359358~1.jpg" alt="照片" /><img src="https://pic.zty.plus/1614421778381.jpg" alt="桥" /><img src="https://pic.zty.plus/1614421778407.jpg" alt="繁·紫" /><img src="https://pic.zty.plus/1614421778401.jpg" alt="银杏" /><img src="https://pic.zty.plus/1614421778390.jpg" alt="海鸥" /><img src="https://pic.zty.plus/1614421778412.jpg" alt="桃花" /><img src="https://pic.zty.plus/1614421778386.jpg" alt="白·蓝" /></div><h2 id="恬静"><a href="#恬静" class="headerlink" title="恬静"></a>恬静</h2><ul><li>在春夏秋冬的里寻找属于你的恬静。</li></ul><div class="justified-gallery"><img src="https://pic.zty.plus/DSC01928~1.jpg" alt="桃花" /><img src="https://pic.zty.plus/DSC01914~1.jpg" alt="广播" /><img src="https://pic.zty.plus/DSC018840~1.jpg" alt="油菜" /><img src="https://pic.zty.plus/DSC02003~1.jpg" alt="KFC" /><img src="https://pic.zty.plus/DSC01990~1.jpg" alt="土楼" /><img src="https://pic.zty.plus/DSC02010~1.jpg" alt="巷子" /><img src="https://pic.zty.plus/DSC02834~1.jpg" alt="泼水" /><img src="https://pic.zty.plus/1614418439693.jpg" alt="红酒" /></div><h2 id="昆明"><a href="#昆明" class="headerlink" title="昆明"></a>昆明</h2><ul><li>浅蓝色的天空，浅蓝色的滇池水。</li></ul><div class="justified-gallery"><img src="https://pic.zty.plus/DSC01749.jpg" alt="滇池·路" /><img src="https://pic.zty.plus/DSC01761.jpg" alt="滇池·树" /><img src="https://pic.zty.plus/DSC01751.jpg" alt="滇池·海鸥" /><img src="https://pic.zty.plus/DSC01770.jpg" alt="滇池·水" /></div><h2 id="重庆"><a href="#重庆" class="headerlink" title="重庆"></a>重庆</h2><ul><li>热闹、喧嚣，绚烂的灯火。</li></ul><div class="justified-gallery"><img src="https://pic.zty.plus/DSC09856000.jpg" alt="千厮门大桥" /><img src="https://pic.zty.plus/DSC00004.jpg" alt="千厮门大桥·顶" /><img src="https://pic.zty.plus/DSC09952.jpg" alt="解放碑" /><img src="https://pic.zty.plus/DSC09946.jpg" alt="解放碑广场" /><img src="https://pic.zty.plus/DSC09907.jpg" alt="洪崖洞" /><img src="https://pic.zty.plus/DSC09798.jpg" alt="窗外雨滴" /><img src="https://pic.zty.plus/DSC00009.jpg" alt="长江索道" /></div><h2 id="峨眉"><a href="#峨眉" class="headerlink" title="峨眉"></a>峨眉</h2><ul><li>已识乾坤大，尤怜草木青。</li></ul><div class="justified-gallery"><img src="https://pic.zty.plus/_DSC3195.jpg" alt="峨眉·缆车" /><img src="https://pic.zty.plus/_DSC3141.jpg" alt="峨眉·银殿" /><img src="https://pic.zty.plus/_DSC3125.jpg" alt="大雄宝殿" /><img src="https://pic.zty.plus/_DSC3043.jpg" alt="峨眉·殿" /><img src="https://pic.zty.plus/_DSC2955.jpg" alt="峨眉·猴" /><img src="https://pic.zty.plus/_DSC3019.jpg" alt="峨眉·山" /><img src="https://pic.zty.plus/_DSC2886.jpg" alt="峨眉·水" /><img src="https://pic.zty.plus/_DSC2923.jpg" alt="峨眉·叶" /><img src="https://pic.zty.plus/_DSC3024.jpg" alt="峨眉·金顶" /></div>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;用指尖记录生活&quot;&gt;&lt;a href=&quot;#用指尖记录生活&quot; class=&quot;headerlink&quot; title=&quot;用指尖记录生活&quot;&gt;&lt;/a&gt;用指尖记录生活&lt;/h3&gt;&lt;h2 id=&quot;神木垒&quot;&gt;&lt;a href=&quot;#神木垒&quot; class=&quot;headerlink&quot; title=&quot;神木垒&quot;&gt;&lt;/a&gt;神木垒&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我慢慢的听，雪落下的声音。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;justified-gallery&quot;&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05074.jpg~to_1920x1280&quot; alt=&quot;雪山&quot; /&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05088.jpg~to_1920x1280&quot; alt=&quot;雪路&quot; /&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05188.jpg~to_1920x1280&quot; alt=&quot;雪人&quot; /&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05191.jpg~to_1920x1280&quot; alt=&quot;雪林&quot; /&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05248.jpg~to_1920x1280&quot; alt=&quot;雪林&quot; /&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05262%282%29.jpg~to_1920x1280&quot; alt=&quot;阳光&quot; /&gt;
&lt;img src=&quot;https://pic.zty.plus/2021/12/25DSC05051%281%29.jpg~to_1920x1280&quot; alt=&quot;湖泊&quot; /&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="摄与影" scheme="http://tianyuzhou.github.io/categories/%E6%91%84%E4%B8%8E%E5%BD%B1/"/>
    
    
    <category term="图库" scheme="http://tianyuzhou.github.io/tags/%E5%9B%BE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库-概念</title>
    <link href="http://tianyuzhou.github.io/2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5/"/>
    <id>http://tianyuzhou.github.io/2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5/</id>
    <published>2021-01-10T03:06:47.000Z</published>
    <updated>2021-02-17T13:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>信息与数据的概念。数据与信息的区别与联系。<ul><li><strong>信息</strong>：信息是现实世界各种事物通过人脑抽象后形成的概念。</li><li><strong>数据</strong>：数据是信息的一种<strong>符号化表示方法</strong>。</li><li><strong>联系</strong>：信息的<strong>载体</strong>是数据；数据的<strong>内涵</strong>是信息。<span id="more"></span></li></ul></li><li>数据管理技术发展的三个阶段，三者之间最最最主要的区别是什么。<ul><li><strong>人工管理阶段</strong>、<strong>文件管理阶段</strong>、<strong>数据库管理阶段</strong>。</li><li><strong>最主要的区别</strong>：数据的共享性和独立性程度。</li></ul></li><li>数据库系统的组成（提示：有至少5个部分）及各自的作用。<ul><li><strong>数据库 BD</strong>：数据的汇集，数据以一定组织形式存储在存储介质上。</li><li><strong>数据库管理系统 DBMS</strong>：管理数据库的专用软件。</li><li><strong>数据库管理员 DMA</strong>：负责数据库的规划、建立、维护等工作。</li><li><strong>应用系统</strong>：以数据库为基础的各种应用程序。</li><li><strong>用户</strong>：通过应用程序或系统的用户接口使用数据库。</li></ul></li><li>数据模型的三要素及各自的作用。<ul><li><strong>数据结构</strong>：数的静态特征，定义如何组织存储数据。</li><li><strong>数据操作</strong>：数据的动态特征，操作及操作规则的集合。</li><li><strong>完整性约束</strong>：数据必须具备的条件，保证数据的正确、有效、相容。</li></ul></li><li>数据库管理系统的主要功能有哪一些。<ul><li><strong>数据定义、数据操作、运行管理、组织维护、其他</strong>（通信、数据转换）。</li><li><img src="https://pic.zty.plus/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD.png" alt="数据库管理系统"></li></ul></li><li>三级模式/二级映像的组成及其每一组成的作用。这种结构的意义是什么。<ul><li><strong>外模式</strong>：用户与数据库系统的接口，数据库用户看得见和使用的<strong>部分数据</strong>的描述，通常是模式的子集。</li><li><strong>模式</strong>：又称逻辑模式或结构模式，对数据库<strong>全体数据</strong>的逻辑结构以及安全性、完整性的描述。（所有用户的公有逻辑数据视图）</li><li><strong>内模式</strong>：又称存储模式，是对数据库<strong>物理存储结构</strong>的描述。</li><li><strong>外（子）模式/模式映像</strong>：在外模式中定义的某一个外模式和模式之间的对应关系。当模式发生改变时，DBA 可以对此映像作出相应的改变，从而可以使外模式保持不变，这就是数据的<strong>逻辑独立性</strong>。</li><li><strong>模式/内模式映像</strong>：在模式中定义的数据的全局逻辑结构与其存储结构之间的对应关系。当存储结构改变时，DBA 只需对该映像作出相应的调整，从而可以使模式保持不变，这就是数据的<strong>物理独立性</strong>。</li><li><strong>意义</strong>：是数据库系统达到了高度的<strong>数据独立性</strong>。</li></ul></li><li>数据独立性的概念与意义。有哪两级独立性。<ul><li>数据的独立性是指<strong>物理独立性</strong>和<strong>逻辑独立性</strong>。</li><li><strong>逻辑独立性</strong>：当数据的总体逻辑改变时，数据的局部逻辑结构不变。</li><li><strong>物理独立性</strong>：当存储结构改变时，数据的逻辑结构不变。</li><li><strong>意义</strong>：独立性越高，共享越方便、数据使用和程序的编写越灵活。</li></ul></li><li><p>写出以下数据库专有名词的英文全称和中文。</p><ul><li>数据库(DB)、数据库管理系统(DBMS)、数据库管理员(DBA)</li><li>数据库定义语言(DDL)、数据库操作（纵）语言(DML)</li><li>概念数据模型(CDM)、逻辑概念模型(LDM)、物理概念模型(PDM)</li></ul></li><li><p>关系应该具有哪6个性质？ 写出每一个性质的意义。</p><ul><li>关系中任意两个<strong>元组不能完全相同</strong>，每一个元组都是唯一的。</li><li><strong>元组的顺序无关性</strong>，任意元组的次序可以任意交换。</li><li><strong>列是同质的</strong>，即同一列中的属性值必须是同一种数据类型，出自同一个域。</li><li>一个关系中的<strong>属性名必须互不相同</strong>，但不同的属性可以出自同一个域。</li><li><strong>属性的顺序无关性</strong>，一个关系中的属性顺序可以任意交换，对关系没有影响。</li><li>所有<strong>属性值都必须取原子值</strong>。</li></ul></li><li>关系模型有几种完整性约束？ 定义或作用分别是什么？<ul><li><strong>实体完整性</strong>：主键取值唯一，且主键属性组不能部分或全部为空。<ul><li><strong>作用</strong>：唯一地标识所有的实体。</li></ul></li><li><strong>参照完整性</strong>：对外键的限定，取空值或对应主键相等的值。<ul><li><strong>作用</strong>：不允许引用不存在的实体。</li></ul></li><li><strong>用户定义完整性</strong>：用户根据实际需求，对属性或元组定义的规则或条件。<ul><li><strong>作用</strong>：根据实际数据给出合理的约束。</li></ul></li></ul></li><li>SQL的中英文全称是什么。<ul><li><strong>Structured Query Language</strong></li></ul></li><li>SQL包含哪四方面的功能？ 其英文缩写分别是什么？<ul><li>数据查询(DQL)：<code>select</code></li><li>数据定义(DDL)：<code>create</code>、<code>drop</code>、<code>alter</code></li><li>数据操纵(DML)：<code>insert</code>、<code>update</code>、<code>delete</code></li><li>数据控制(DCL)：<code>grant</code>、<code>revoke</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;信息与数据的概念。数据与信息的区别与联系。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;信息&lt;/strong&gt;：信息是现实世界各种事物通过人脑抽象后形成的概念。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;：数据是信息的一种&lt;strong&gt;符号化表示方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;联系&lt;/strong&gt;：信息的&lt;strong&gt;载体&lt;/strong&gt;是数据；数据的&lt;strong&gt;内涵&lt;/strong&gt;是信息。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="http://tianyuzhou.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库语句</title>
    <link href="http://tianyuzhou.github.io/2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/"/>
    <id>http://tianyuzhou.github.io/2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-01-03T12:45:46.000Z</published>
    <updated>2021-02-17T13:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="SQL-命令复习"><a href="#SQL-命令复习" class="headerlink" title="SQL 命令复习"></a>SQL 命令复习</h3><h4 id="数据表创建"><a href="#数据表创建" class="headerlink" title="数据表创建"></a>数据表创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 通讯录(</span><br><span class="line">  姓名 <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">  性别 <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  年龄 <span class="type">int</span>,</span><br><span class="line">  电话 <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">  地址 <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="视图创建"><a href="#视图创建" class="headerlink" title="视图创建"></a>视图创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> cs_info_view</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> 系别<span class="operator">=</span><span class="string">&#x27;计算机&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> s_info_view(学号,姓名,性别,系别)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sno,sn,sex,dep <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> s_info_view</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">as</span> 学号,sn <span class="keyword">as</span> 姓名,sex <span class="keyword">as</span> 性别,dep <span class="keyword">as</span> 系别 <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 创建表时创建索引</span><br><span class="line"></span><br><span class="line"># 创建 S 表并以 sname 字段建立普通索引 </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S(</span><br><span class="line">  sno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  sname <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  age <span class="type">int</span>,</span><br><span class="line">  sex <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  dept <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  index (sname)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 创建 SC 表，并以 sno 和 cno 两字段组合建立名为 uk_sno_cno 多列唯一索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">  sno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  cno <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">  score <span class="type">decimal</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">unique</span> index uk_sno_cno(sno,cno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 在已存在的表上创建索引</span><br><span class="line"></span><br><span class="line"># 降序普通索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_sno <span class="keyword">on</span> SC(sno <span class="keyword">desc</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SC <span class="keyword">add</span> index idx_sno (sno <span class="keyword">desc</span>);</span><br><span class="line"></span><br><span class="line"># 唯一索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index uk_sno <span class="keyword">on</span> S(sno);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">add</span> <span class="keyword">unique</span> index idx_sno (sno);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="授权-回收权限命令"><a href="#授权-回收权限命令" class="headerlink" title="授权/回收权限命令"></a>授权/回收权限命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 把创建表权限授权给用户 user1<span class="operator">/</span>回收</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> user1;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">from</span> user1;</span><br><span class="line"></span><br><span class="line"># 把查询 <span class="keyword">order</span> 表的权限授权给用户 user1<span class="operator">/</span>回收 </span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">order</span> <span class="keyword">to</span> user1 [<span class="keyword">with</span> <span class="keyword">grant</span> option];</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">order</span> <span class="keyword">from</span> user1;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">with</span> <span class="keyword">grant</span> option 表示允许被授权用户将制定的系统权限再授予其他用户</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本的查询命令"><a href="#基本的查询命令" class="headerlink" title="基本的查询命令"></a>基本的查询命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course;</span><br><span class="line"><span class="keyword">select</span> sno,sname,sage <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> cno <span class="keyword">as</span> 课程名 <span class="keyword">from</span> course;</span><br><span class="line"><span class="keyword">select</span> sname <span class="keyword">as</span> 姓名,<span class="number">2020</span><span class="operator">-</span>sage <span class="keyword">as</span> 出生年份 <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 精确匹配</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc <span class="keyword">where</span> grade <span class="operator">&gt;</span> <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"># 多重条件</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> (cno <span class="operator">=</span> <span class="string">&#x27;kc001&#x27;</span> <span class="keyword">or</span> cno <span class="operator">=</span><span class="string">&#x27;kc002&#x27;</span>) <span class="keyword">and</span> grade <span class="operator">&gt;</span> <span class="operator">=</span> <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"># 确定范围</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">1500</span>;</span><br><span class="line"># (等价于 sal<span class="operator">&gt;</span> <span class="operator">=</span><span class="number">1000</span> <span class="keyword">and</span> sal <span class="operator">&lt;</span> <span class="operator">=</span><span class="number">1500</span><span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"># 确定集合</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> cno <span class="keyword">in</span> (<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>); # (等价于 cno<span class="operator">=</span><span class="string">&#x27;c1&#x27;</span> <span class="keyword">or</span> cno<span class="operator">=</span><span class="string">&#x27;c2&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> cno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>); # (等价于 cno<span class="operator">!</span> <span class="operator">=</span><span class="string">&#x27;c1&#x27;</span> <span class="keyword">and</span> cno<span class="operator">!</span> <span class="operator">=</span><span class="string">&#x27;c2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 部分匹配查询（模糊查询）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> cname [<span class="keyword">not</span>] <span class="keyword">like</span> <span class="string">&#x27;%数%&#x27;</span>;</span><br><span class="line"># “<span class="operator">%</span>” 匹配零个及多个任意字符；“_” 匹配一个任意字符</span><br><span class="line"></span><br><span class="line"># 空值查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> cpno <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"># 统计查询</span><br><span class="line"># <span class="built_in">count</span>() 按列计算个数</span><br><span class="line"># <span class="built_in">sum</span>()、<span class="built_in">avg</span>()、<span class="built_in">max</span>()、<span class="built_in">min</span>()</span><br><span class="line"># <span class="built_in">count</span>(<span class="operator">*</span>) 用来统计元组个数，不消除重复行，不允许使用 <span class="keyword">distinct</span> 关键字</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> dept <span class="operator">=</span> <span class="string">&#x27;计算机&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 一般连接</span><br><span class="line"><span class="keyword">select</span> teacher.tno,tn,cno</span><br><span class="line"><span class="keyword">from</span> teacher,tc</span><br><span class="line"><span class="keyword">where</span> (teacher.tno<span class="operator">=</span>tc.tno) <span class="keyword">and</span> (tn<span class="operator">=</span><span class="string">&#x27;刘伟&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 自身连接</span><br><span class="line"><span class="keyword">select</span> cx.cno [<span class="keyword">as</span>] 课程号,cy.cname [<span class="keyword">as</span>] 课程名,</span><br><span class="line">       cx.cno [<span class="keyword">as</span>] 先选课程号,cy.cname [<span class="keyword">as</span>] 先选课程名</span><br><span class="line"><span class="keyword">from</span> course [<span class="keyword">as</span>] cx,</span><br><span class="line">     course [<span class="keyword">as</span>] cy</span><br><span class="line"><span class="keyword">where</span> cx.cpno <span class="operator">=</span> cy.cno;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">JOIN</span>连接</span><br><span class="line"></span><br><span class="line"># 交叉连接 （笛卡尔积）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">cross</span> <span class="keyword">join</span> course;</span><br><span class="line"></span><br><span class="line"># 内连接</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> student [<span class="keyword">inner</span>] <span class="keyword">join</span> sc <span class="keyword">on</span> student.sno <span class="operator">=</span> sc.sno</span><br><span class="line"><span class="keyword">where</span> sage <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 外连接</span><br><span class="line"></span><br><span class="line"># <span class="keyword">left</span> (<span class="keyword">right</span>、<span class="keyword">full</span>) [<span class="keyword">outer</span>] <span class="keyword">join</span> 结果包含第一（二）个表中所有行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> sc</span><br><span class="line"><span class="keyword">on</span> student.sno <span class="operator">=</span> sc.sno;</span><br></pre></td></tr></table></figure><h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 普通子查询</span><br><span class="line"></span><br><span class="line"># 先执行子查询 返回单一值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> prof <span class="operator">=</span> (<span class="keyword">select</span> prof</span><br><span class="line">              <span class="keyword">from</span> teacher</span><br><span class="line">              <span class="keyword">where</span> tn<span class="operator">=</span><span class="string">&#x27;刘伟&#x27;</span>)；</span><br><span class="line"></span><br><span class="line"># 先执行子查询 返回一组值</span><br><span class="line"># 使用 <span class="keyword">any</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> tno <span class="operator">=</span> <span class="keyword">any</span></span><br><span class="line">         (<span class="keyword">select</span> tno</span><br><span class="line">          <span class="keyword">from</span> tc</span><br><span class="line">          <span class="keyword">where</span> cno<span class="operator">=</span><span class="string">&#x27;c5&#x27;</span>);</span><br><span class="line"># 使用 <span class="keyword">in</span> 代替 <span class="operator">=</span><span class="keyword">any</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> tno <span class="keyword">in</span> </span><br><span class="line">      (<span class="keyword">select</span> tno</span><br><span class="line">       <span class="keyword">from</span> tc</span><br><span class="line">       <span class="keyword">where</span> cno<span class="operator">=</span><span class="string">&#x27;c5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">&gt;</span> <span class="keyword">all</span></span><br><span class="line">          (<span class="keyword">select</span> sal</span><br><span class="line">           <span class="keyword">from</span> teacher</span><br><span class="line">           <span class="keyword">where</span> dept<span class="operator">=</span><span class="string">&#x27;计算机&#x27;</span>)</span><br><span class="line">          <span class="keyword">and</span> dept <span class="operator">!</span> <span class="operator">=</span> <span class="string">&#x27;计算机&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">exists</span></span><br><span class="line"># 属于相关子查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> [<span class="keyword">not</span>] <span class="keyword">exists</span></span><br><span class="line">      (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">       <span class="keyword">from</span> tc</span><br><span class="line">       <span class="keyword">where</span> tno <span class="operator">=</span> teacher.tno</span><br><span class="line">       <span class="keyword">and</span> cnon <span class="operator">=</span> <span class="string">&#x27;c5&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 先执行外部查询</span><br><span class="line"># 执行次数由父查询表的行数决定</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> tn</span><br><span class="line"><span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> <span class="string">&#x27;c5&#x27;</span><span class="operator">!</span> <span class="operator">=</span> <span class="keyword">all</span></span><br><span class="line">        (<span class="keyword">select</span> cno</span><br><span class="line">         <span class="keyword">from</span> tc</span><br><span class="line">         <span class="keyword">where</span> tno<span class="operator">=</span>teacher.tno);</span><br></pre></td></tr></table></figure><h4 id="派生子查询"><a href="#派生子查询" class="headerlink" title="派生子查询"></a>派生子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 嵌入到 <span class="keyword">from</span> 子句中</span><br><span class="line"># 子查询为父查询提供派生表（临时表）</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student,(<span class="keyword">select</span> <span class="built_in">avg</span>(sage) <span class="keyword">as</span> 信息系平均年龄</span><br><span class="line">              <span class="keyword">from</span> student</span><br><span class="line">              <span class="keyword">where</span> sdept<span class="operator">=</span><span class="string">&#x27;信息&#x27;</span>) <span class="keyword">as</span> info</span><br><span class="line"><span class="keyword">where</span> sage <span class="operator">&gt;</span> info.信息系平均年龄;</span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 按系别分组</span><br><span class="line"><span class="keyword">select</span> sdept <span class="keyword">as</span> 系名,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 人数</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sdept;</span><br><span class="line"></span><br><span class="line"># 学了四门以上课程的学号和课程数</span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">as</span> 学号,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 课程数</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 排序 (<span class="keyword">order</span> <span class="keyword">by</span>)</span><br><span class="line"># <span class="keyword">desc</span> 降序；<span class="keyword">asc</span> 升序</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sdept<span class="operator">=</span><span class="string">&#x27;计算机&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sage <span class="keyword">desc</span>；</span><br></pre></td></tr></table></figure><h4 id="限量查询"><a href="#限量查询" class="headerlink" title="限量查询"></a>限量查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># limit n 等价于 limit <span class="number">0</span>,n</span><br><span class="line"># limit <span class="number">5</span>,<span class="number">10</span> 从标号为 <span class="number">5</span> 的行开始，取 <span class="number">10</span> 行， <span class="number">6</span> <span class="operator">-</span> <span class="number">15</span> 行</span><br></pre></td></tr></table></figure><h4 id="增、删、改"><a href="#增、删、改" class="headerlink" title="增、删、改"></a>增、删、改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 增</span><br><span class="line"></span><br><span class="line"># 每列都要插入，且顺序一致</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;S7&#x27;</span>,<span class="string">&#x27;周杰伦&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;古典音乐&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 其他列有默认值的填默认值，否则 <span class="keyword">NULL</span>，若有非空值限制则报错</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc(sno,cno)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;S7&#x27;</span>,<span class="string">&#x27;c1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 改</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> dept <span class="operator">=</span><span class="string">&#x27;信息&#x27;</span></span><br><span class="line"><span class="keyword">where</span> tno <span class="operator">=</span> <span class="string">&#x27;刘伟&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 删</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> tn <span class="operator">=</span> <span class="string">&#x27;刘伟&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;SQL-命令复习&quot;&gt;&lt;a href=&quot;#SQL-命令复习&quot; class=&quot;headerlink&quot; title=&quot;SQL 命令复习&quot;&gt;&lt;/a&gt;SQL 命令复习&lt;/h3&gt;&lt;h4 id=&quot;数据表创建&quot;&gt;&lt;a href=&quot;#数据表创建&quot; class=&quot;headerlink&quot; title=&quot;数据表创建&quot;&gt;&lt;/a&gt;数据表创建&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; 通讯录(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  姓名 &lt;span class=&quot;type&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  性别 &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  年龄 &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  电话 &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  地址 &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="http://tianyuzhou.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://tianyuzhou.github.io/2020/12/31/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://tianyuzhou.github.io/2020/12/31/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2020-12-31T00:22:36.000Z</published>
    <updated>2021-02-17T13:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而<strong>不是指具体的传输媒体</strong>。</li><li>物理层的作用是要尽可能地<strong>屏蔽</strong>掉不同传输媒体和通信手段的差异。</li><li>用于物理层的协议也常称为物理层<strong>规程</strong>。<span id="more"></span></li><li>物理层的主要任务<ul><li><strong>机械特性</strong> ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</li><li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</li><li><strong>过程特性</strong> ：指明对于不同功能的各种可能事件的出现顺序。</li></ul></li></ul><h3 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h3><ul><li>一个数据通信系统包括三大部分：源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。</li><li>常用术语<ul><li><strong>数据</strong> (data) —— 运送消息的实体。</li><li><strong>信号</strong> (signal) —— 数据的电气的或电磁的表现。</li><li><strong>模拟信号</strong> (analogous signal) —— 代表消息的参数的取值是连续的。</li><li><strong>数字信号</strong> (digital signal) —— 代表消息的参数的取值是离散的。</li><li><strong>码元</strong> (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的<strong>基本波形</strong>。</li></ul></li><li>有关信道的几个基本概念<ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信</strong>（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信</strong>（全双工通信）——通信的双方可以同时发送和接收信息。</li><li><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li><li>基带信号往往包含有较多的<strong>低频成分</strong>，甚至有<strong>直流成分</strong>，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong> (modulation)。</li><li>两大类调制：<ul><li><strong>基带调制</strong>：仅对基带信号的<strong>波形进行变换</strong>，使它能够与信道特性相适应。<strong>变换后的信号仍然是基带信号</strong>。把这种过程称为<strong>编码</strong> (coding)。</li><li><strong>带通调制</strong>：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并<strong>转换为模拟信号</strong>，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</li><li><strong>带通信号</strong> ：经过<strong>载波调制</strong>后的信号。</li></ul></li><li>常用编码方式：<ul><li>不归零制：正<strong>电平</strong>代表 1，负电平代表 0。</li><li>归零制：正<strong>脉冲</strong>代表 1，负脉冲代表 0。</li><li>曼彻斯特编码：位<strong>周期中心的</strong>向上<strong>跳变</strong>代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位<strong>开始边界</strong>有<strong>跳变</strong>代表 0，而位开始边界没有跳变代表 1。</li><li><img src="https://pic.zty.plus/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E7%BC%96%E7%A0%81.png" alt="数字信号编码"></li><li>从信号波形中可以看出，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。</li><li>从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力），而<strong>曼彻斯特编码和差分曼彻斯特编码具有自同步能力</strong>。</li></ul></li><li>基本的带通调制方法<ul><li>调幅(AM)：载波的振幅随基带数字信号而变化。</li><li>调频(FM)：载波的频率随基带数字信号而变化。</li><li>调相(PM) ：载波的初始相位随基带数字信号而变化</li><li><img src="https://pic.zty.plus/%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="带通调制"></li></ul></li></ul></li></ul><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><ul><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li><li>限制码元在信道上的传输速率的因素有以下两个：<ul><li><strong>信道能够通过的频率范围</strong><ul><li>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。</li><li>在任何信道中，<strong>码元传输的速率是有上限的</strong>，否则就会出现<strong>码间串扰</strong>（码元之间的界限模糊不清）的问题，使接收端对码元的判决（即识别）成为不可能。</li><li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><strong>信噪比</strong><ul><li>信噪比就是信号的平均功率和噪声的平均功率之比。</li><li>常记为 S/N，并用分贝 (dB) 作为度量单位。即：$信噪比(dB) = 10log_{10}(S/N) (dB)$</li><li>香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）。</li><li>信道的极限信息传输速率 C 可表达为：$W\log(1+S/N) (bit/s)$</li></ul></li><li>其中：<ul><li>W 为信道的带宽（以 Hz 为单位）；</li><li>S 为信道内所传信号的平均功率；</li><li>N 为信道内部的高斯噪声功率。  </li></ul></li><li><strong>香农公式表明</strong>：<ul><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li><li><strong>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输</strong>。</li><li>若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</li></ul></li><li>注意：<ul><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。</li><li>这就是：<strong>用编码的方法让每一个码元携带更多比特的信息量</strong>。</li></ul></li></ul></li></ul><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><ul><li>传输媒体可分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</li><li>在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。</li><li>非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。</li><li>引导型传输媒体：双绞线（屏蔽双绞线 STP 、无屏蔽双绞线 UTP ）、同轴电缆（50Ω同轴电缆，70Ω同轴电缆）、光缆（多模光纤，单模光纤）。</li><li>光纤优点：通信容量非常大、传输损耗小、中继距离长、抗雷电和电磁干扰性能好、无串音干扰，保密性好、体积小，重量轻。</li><li>非导引型传输媒体：</li><li><strong>短波通信</strong>（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</li><li><strong>微波</strong>在空间主要是直线传播。<ul><li>传统微波通信有两种方式：<ul><li>地面微波接力通信</li><li>卫星通信  </li></ul></li></ul></li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul><li><strong>复用</strong> (multiplexing) 是通信技术中的基本概念。<br>它允许用户使用一个<strong>共享</strong>信道进行通信，降低成本，提高利用率。</li><li><strong>频分复用 FDM</strong>：<ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用的所有用户在<em>同样的时间</em>占用<em>不同的带宽资源</em></strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul></li><li><strong>时分复用TDM</strong><ul><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。</li><li>TDM 信号也称为等时(isochronous)信号。</li><li><strong>时分复用的所有用户是在<em>不同的时间</em>占用<em>同样的频带宽度</em></strong>。</li></ul></li><li><strong>统计时分复用 STDM</strong><ul><li>STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</li></ul></li><li><strong>波分复用 WDM</strong><ul><li>波分复用就是<strong>光的频分复用</strong>。使用一根光纤来同时传输多个光载波信号。</li></ul></li><li><strong>码分复用 CDM</strong><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>每个站分配的码片序列不仅<strong>必须各不相同</strong>，并且还必须<strong>互相正交</strong>(orthogonal)。</li><li>在实用的系统中是使用<strong>伪随机码序列</strong>。</li><li><img src="https://pic.zty.plus/CDMA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="CDMA工作原理"></li></ul></li></ul><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><ul><li>用户要连接到互联网，必须先连接到某个 ISP，美国联邦通信委员会 FCC 认为只要双向速率之和超过 200 kbit/s 就是宽带。</li><li>从宽带接入的媒体来看，可以划分为两大类：有线宽带接入、无线宽带接入。</li><li><strong>ADSL 技术</strong>：非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术就是用<strong>数字技术对现有的模拟电话用户线进行改造</strong>，使它能够承载宽带业务。标准模拟电话信号的频带被限制在 300~3400 Hz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。<ul><li>ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</li><li>ADSL 的传输距离  ADSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。</li><li>ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</li></ul></li><li><strong>FTTx 技术</strong>：FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。（光纤到户 FTTH (Fiber To The Home)、光纤到大楼 FTTB (Fiber To The Building)、光纤到路边 FTTC (Fiber To The Curb)）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;物理层的基本概念&quot;&gt;&lt;a href=&quot;#物理层的基本概念&quot; class=&quot;headerlink&quot; title=&quot;物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;物理层考虑的是怎样才能在连接各种计算机的传输媒体上&lt;strong&gt;传输数据比特流&lt;/strong&gt;，而&lt;strong&gt;不是指具体的传输媒体&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;物理层的作用是要尽可能地&lt;strong&gt;屏蔽&lt;/strong&gt;掉不同传输媒体和通信手段的差异。&lt;/li&gt;
&lt;li&gt;用于物理层的协议也常称为物理层&lt;strong&gt;规程&lt;/strong&gt;。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-概述</title>
    <link href="http://tianyuzhou.github.io/2020/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0/"/>
    <id>http://tianyuzhou.github.io/2020/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-12-26T11:59:53.000Z</published>
    <updated>2021-02-17T13:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>三大类网络<ul><li>电信网络：提供电话、电报及传真等服务。</li><li>有线电视网路：向用户传送各种电视节目。</li><li>计算机网络：使用户能在计算机之间传送数据文件。<span id="more"></span></li></ul></li></ul><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><ul><li>互联网的两个重要基本特点<ul><li>连通性 (connectivity)<ul><li>使上网用户之间都可以交换信息（数据，以及各种音频视频） ，好像这些用户的计算机都可以彼此直接连通一样。</li></ul></li><li>共享 (Sharing)<ul><li>指资源共享。</li></ul></li></ul></li><li>互联网的组成<ul><li><strong>边缘部分</strong>：<ul><li>由所有连接在互联网上的<strong>主机</strong>组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li></ul></li><li><strong>核心部分</strong>：<ul><li>由大量<strong>网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</li><li>网络中的核心部分要向网络边缘中的大量主机<strong>提供连通性</strong>，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</li><li>在网络核心部分起特殊作用的是<strong>路由器</strong> (router)。</li><li>路由器是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</li></ul></li><li>电路交换的特点<ul><li>电路交换必定是<strong>面向连接</strong>的。</li><li>电路交换分为三个阶段：<ul><li>建立连接、通信、释放连接</li></ul></li><li>电路交换缺点<ul><li>通信线路的利用率很低</li></ul></li></ul></li><li>分组交换的主要特点<ul><li>分组交换则采用<strong>存储转发</strong>技术。</li><li>在发送端，先把较长的报文<strong>划分成较短的</strong>、<strong>固定长度的数据段</strong>。</li><li>分组交换的优点：<ul><li>高效：在分组传输的过程中<strong>动态分配</strong>传输带宽，对通信链路是逐段占用。</li><li>灵活：为每一个分组<strong>独立地选择</strong>最合适的转发路由。</li><li>迅速：以分组作为传送单位，<strong>可以不先建立连接</strong>就能向其他主机发送分组。</li><li>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</li></ul></li><li>分组交换带来的问题<ul><li>分组在各结点存储转发时需要<strong>排队</strong>，这就会造成一定的<strong>时延</strong>。</li><li>分组必须携带的<strong>首部</strong>（里面有必不可少的控制信息）也造成了一定的<strong>开销</strong>。</li></ul></li></ul></li><li>三种交换的比较<ul><li>若要连续传送大量的数据，且其<strong>传送时间远大于连接建立时间</strong>，则电路交换的传输速率较快。</li><li>报文交换和分组交换不需要预先分配传输带宽，在<strong>传送突发数据</strong>时可提高整个网络的信道利用率。</li><li>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</li><li><img src="https://pic.zty.plus/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2ppt.jpeg" alt="三种交换"></li></ul></li></ul></li></ul><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><ul><li>按照网络的作用范围进行分类<ul><li><strong>广域网 WAN</strong> (Wide Area Network)：作用范围通常为几十到几千公里。</li><li><strong>城域网 MAN</strong> (Metropolitan Area Network)：作用距离约为 5 ~ 50 公里。</li><li><strong>局域网 LAN</strong> (Local Area Network) ：局限在较小的范围（如 1 公里左右）。</li><li><strong>个人区域网 PAN</strong> (Personal Area Network) ：范围很小，大约在 10 米左右。</li></ul></li><li>按照网络的使用者进行分类<ul><li>公用网 (public network)<ul><li>按规定交纳费用的人都可以使用的网络。因此也可称为公众网。</li></ul></li><li>专用网 (private network)<ul><li>为特殊业务工作的需要而建造的网络。</li></ul></li></ul></li></ul><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ul><li>速率<ul><li>速率是计算机网络中<strong>最重要</strong>的一个性能指标，指的是<strong>数据的传送速率</strong>，它也称为<strong>数据率</strong> (data rate)或<strong>比特率</strong> (bit rate)。</li><li>速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s 等。例如 $4×10^{10} bit/s$ 的数据率就记为 40 Gbit/s。</li><li><strong>速率往往是指额定速率或标称速率，非实际运行速率</strong>。</li></ul></li><li>带宽<ul><li>两种不同意义：<ul><li>“带宽”(bandwidth) 本来是指信号具有的<strong>频带宽度</strong>，其单位是赫（或千赫、兆赫、吉赫等）。</li><li>在计算机网络中，带宽用来表示网络中某<strong>通道传送数据的能力</strong>。表示在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”。<strong>单位是 bit/s</strong> ，即 “比特每秒”。</li><li>在“带宽”的上述两种表述中，前者为<strong>频域</strong>称谓，而后者为<strong>时域</strong>称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</li><li><img src="https://pic.zty.plus/%E5%B8%A6%E5%AE%BD.png" alt="带宽"></li></ul></li></ul></li><li>吞吐量<ul><li>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。</li></ul></li><li>时延 (delay 或 latency)<ul><li>发送时延<ul><li>也称为<strong>传输时延</strong>。</li><li>发送数据时，数据帧从结点<strong>进入到传输媒体所需要的时间</strong>。</li><li>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</li><li>$发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}$</li></ul></li><li>传播时延<ul><li>电磁波在信道中需要传播一定的距离而花费的时间。</li><li>$传播时延=\frac{信道长度(米)}{发送速率(米/秒)}$</li></ul></li><li>处理时延<ul><li>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li></ul></li><li>排队时延<ul><li>分组在路由器输入输出队列中排队等待处理所经历的时延。</li></ul></li><li><strong>注意</strong>：<ul><li>对于高速网络链路，我们提高的仅仅是数据的<strong>发送速率</strong>而<strong>不是比特在链路上的传播速率</strong>。</li><li>提高链路带宽减小了数据的发送时延。</li><li>“在高速链路（或高带宽链路）上，比特会传送得更快些”。<strong>是错的</strong>！</li></ul></li></ul></li><li>时延带宽积<ul><li>链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>。</li><li>$时延带宽积 = 传播时延×带宽$</li></ul></li><li>往返时间 RTT<ul><li>往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</li></ul></li><li>利用率<ul><li>分为<strong>信道利用率</strong>和<strong>网络利用率</strong>。</li><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ul></li><li>计算机网络的非性能特征<ul><li>费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护。</li></ul></li></ul><h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><ul><li>分层的优点与缺点<ul><li>优点<ul><li>各层之间是独立的、灵活性好、结构上可分割开、易于实现和维护、能促进标准化工作。</li></ul></li><li>缺点<ul><li>降低效率、有些功能会在不同的层次中重复出现，因而产生了额外开销。</li></ul></li></ul></li><li><img src="https://pic.zty.plus/%E4%B8%89%E7%A7%8D%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="三种体系结构"></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;三大类网络&lt;ul&gt;
&lt;li&gt;电信网络：提供电话、电报及传真等服务。&lt;/li&gt;
&lt;li&gt;有线电视网路：向用户传送各种电视节目。&lt;/li&gt;
&lt;li&gt;计算机网络：使用户能在计算机之间传送数据文件。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘习题</title>
    <link href="http://tianyuzhou.github.io/2020/12/24/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%A0%E9%A2%98/"/>
    <id>http://tianyuzhou.github.io/2020/12/24/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%A0%E9%A2%98/</id>
    <published>2020-12-24T06:07:43.000Z</published>
    <updated>2021-02-17T13:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h3><ul><li>数据仓库就是一个<strong>面向主题的</strong>、集成的、<strong>相对稳定的</strong>、反映历史变化的数据集合。</li><li>数据处理通常分成两大类：联机事务处理(OLTP)和<strong>联机分析处理(OLAP)</strong>。</li><li>调和数据是存储在<strong>企业级数据仓库</strong>(EDW)和操作型数据存储中的数据。<span id="more"></span></li><li>使用星型模式可以从一定程度上<strong>提高</strong>查询效率。因为星型模式中数据的组织已经经过<strong>预处理</strong>，主要数据都在庞大的<strong>事实表</strong>中。</li><li>数据仓库中存在不同综合级别的数据。一般把数据分成四个级别：<strong>早期细节级</strong>、当前细节级、<strong>轻度综合级</strong>和高度综合级。</li><li>关联规则的经典算法包括<strong>Apriori</strong>和<strong>FP-growth</strong>，其中<strong>FP-growth</strong>的效率更高。</li><li>分类的过程包含<strong>获取数据</strong>、<strong>预处理</strong>、<strong>分类器设计</strong>和<strong>分类决策</strong>。</li><li>分类器设计阶段包括三个过程：<strong>划分数据集</strong>、<strong>分类器构造</strong>和<strong>分类器测试</strong>。</li><li>分类问题中常用的评价准则有<strong>精确度</strong>、<strong>查全率和查准率</strong>、<strong>F-measure</strong>和<strong>几何均值</strong>。</li><li>支持向量机中常用的核函数有<strong>多项式核函数</strong>、<strong>径向核函数</strong>和<strong>S型核函数</strong>。</li><li>聚类分析包括<strong>连续型</strong>、<strong>二值离散型</strong>、<strong>多值离散型</strong>和<strong>混合类型</strong>四种类型描述属性的相似度计算方法。</li><li>连续型属性的数据样本之间的距离有<strong>欧氏距离</strong>、<strong>曼哈顿距离</strong>和<strong>明考斯基距离</strong>。</li><li>划分聚类方法对数据集进行聚类时包括三个要点：<strong>选定某种距离作为数据样本间的相似性度量</strong>、<strong>选择评价聚类性能的准则函数</strong>和<strong>选择某个初始类，之后用迭代的方法得到聚类结果，使得评价聚类的准则函数取得最优值</strong>。</li><li>层次聚类方法包括：<strong>凝聚型层次聚类</strong>和<strong>分解型层次聚类</strong>两种层次聚类方法。</li></ul><h3 id="简述题"><a href="#简述题" class="headerlink" title="简述题"></a>简述题</h3><ul><li><strong>请简述数据挖掘中关联规则Apriori算法的思想</strong>。<ul><li>Apriori算法多次扫描交易记录集，目的是产生长度不同的频繁集。首先产生1-频繁集$L_1$，在此基础上经过连接、修剪产生2-频繁集$L_2$，直到无法产生新的频繁集则算法终止。</li><li>这里在第 k 次循环中，也就是产生k-频繁集$L<em>k$的过程中，首先产生k-候选频繁集的集合$C_k$，简称候选集。$C_k$中的每一项集是对两个只有一个项不同的属于$L</em>{k-1}$的频繁集连接产生。$C_k$进行修剪，产生对应的$L_k$。</li></ul></li><li><strong>请比较PCA（主成分分析）和LDA（线性判别分析）的区别</strong>。<ul><li>PCA为非监督降维，LDA为有监督降维</li><li>PCA希望投影后的数据方差尽可能的大（最大可分性），因为其假设方差越多，则所包含的信息越多；而LDA则希望投影后相同类别的组内方差小，而组间方差大。LDA能合理运用标签信息，使得投影后的维度具有判别性，不同类别的数据尽可能的分开。 //</li></ul></li><li><strong>请分析特征选择和特征提取有何区别</strong>？<ul><li>这两者达到的效果是一样的，就是试图去减少特征数据集中的属性(或者称为特征)的数目，但是两者所采用的方式方法却不同。</li><li><strong>特征提取</strong>的方法主要是通过属性间的关系，如组合不同的属性得到新的属性，这样就改变了原来的特征空间。</li><li><strong>特征选择</strong>的方法是从原始特征数据集中选择出子集，是一种包含的关系，没有更改原始的特征空间。</li></ul></li><li><strong>聚类和分类有什么区别和联系</strong>？<ul><li>区别<ul><li>数据分类方法是在已知类标号的训练集基础上进行分类器设计工作的，所以分类方法又称为监督学习方法。</li><li>聚类分析方法使用的数据样本没有类标号，聚类分析又称为非监督学习方法。聚类分析是研究如何在没有训练的条件下把样本划分为若干类，聚类之后的数据集可以直接用来进行科学分析，也可以作为其他方法的训练集。</li></ul></li><li>联系<ul><li>宏观上，看起来都是把“杂乱的数据”进行划分成各种类。</li></ul></li></ul></li><li><strong>TF-IDF算法是什么</strong>？<strong>有什么实际意义</strong>？<ul><li>TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</li><li>字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</li><li>它经常被用作搜索信息检索，文本挖掘和用户建模的加权因子。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。</li></ul></li><li><strong>数据挖掘与统计的区别和联系</strong>？<ul><li>统计学主要利用概率论建立数学模型，是研究随机现象的常用数学工具之一。</li><li>数据挖掘分析大量数据，发现其中的内在联系和知识，并以模型或规则表达这些知识。</li><li>虽然两者采用的某些分析方法（如回归分析）是相同的，但是数据挖掘和统计学是有本质区别的：<ul><li>一个主要差别在于处理对象（数据集）的尺度和性质。数据挖掘经常会面对尺度为GB甚至TB数量级的数据库，而用传统的统计方法很难处理这么大尺度的数据集。传统的统计处理往往是针对特定的问题采集数据（甚至通过试验设计加以优化）和分析数据来解决特定问题；而数据挖掘却往往是数据分析的次级过程，其所用的数据原本可能并非为当前研究而专门采集的，因而其适用性和针对性可能都不强，在数据挖掘的过程中，需要对异常数据及冲突字段等进行预处理，尽可能提高数据的质量，然后才对经过预处理的数据进行数据挖掘。</li><li>另一个差别在于面对结构复杂的海量数据，数据挖掘往往需要采用各种相应的数学模型和应用传统统计学以外的数学工具，才能建立最适合描述对象的模型或规则。</li><li>总之，统计学在生物医学研究中常采用假设检验（或称显著性检验）方法，其侧重<strong>假设驱动</strong>（hypothesis-driven）,即提出假设并加以检验；而数据挖掘则不具备这样的功能，其主要是<strong>数据驱动</strong>（data-driven），即从数据中发现规律并得到知识。</li></ul></li></ul></li><li><strong>什么是关联规则</strong>？<strong>关联规则的应用有哪些</strong>？<ul><li>关联规则挖掘最初由R.Agrawal等人提出，用来发现超级市场中用户购买的商品之间的隐含关联关系，并用规则的形式表示出来，称为关联规则(Association Rule)。</li><li>关联规则除了可以发现<strong>超市购物中隐含的关联关系</strong>之外，还可以应用于其他很多领域。关联规则的应用还包括<strong>文本挖掘、商品广告邮寄分析、网络故障分析等</strong>。</li></ul></li><li><strong>什么是分类</strong>？<strong>分类的应用领域有哪些</strong>？<ul><li>分类是指把数据样本映射到一个事先定义的类中的学习过程，即给定一组输入的属性向量及其对应的类，用基于归纳的学习算法得出分类。</li><li>分类问题在商业、银行业、医疗诊断、生物学、文本挖掘、因特网筛选等领域都有广泛应用。</li><li>例如，在银行业中，分类方法可以辅助工作人员将正常信用卡用户和欺诈信用卡用户进行分类，从而采取有效措施减小银行的损失；在医疗诊断中，分类方法可以帮助医疗人员将正常细胞和癌变细胞进行分类，从而及时制定救治方案，挽救病人的生命；在因特网筛选中，分类方法可以协助网络工作人员将正常邮件和垃圾邮件进行分类，从而制定有效的垃圾邮件过滤机制，防止垃圾邮件干扰人们的正常生活。</li></ul></li><li><strong>什么是聚类分析</strong>？<strong>聚类分析的应用领域有哪些</strong>？<ul><li>聚类分析是将物理的或者抽象的数据集合划分为多个类别的过程，聚类之后的每个类别中任意两个数据样本之间具有较高的相似度，而不同类别的数据样本之间具有较低的相似度。</li><li>聚类分析在科学数据分析、商业、生物学、医疗诊断、文本挖掘、Web数据挖掘等领域都有广泛应用。</li><li>在科学数据分析中，比如对于卫星遥感照片，聚类可以将相似的区域归类，有助于研究人员根据具体情况做进一步分析；在商业领域，聚类可以帮助市场分析人员对客户的基本数据进行分析，发现购买模式不同的客户群，从而协助市场调整销售计划；在生物学方面，聚类可以帮助研究人员按照基因的相似度对动物和植物的种群进行划分，从而获得对种群中固有结构的认识；在医疗诊断中，聚类可以对细胞进行归类，有助于医疗人员发现异常细胞的聚类，从而对病人及时采取措施；在文本挖掘和Web数据挖掘领域中，聚类可以将网站数据按照读者的兴趣度进行划分，从而有助于网站内容的改进。</li></ul></li></ul><h4 id="书上的题"><a href="#书上的题" class="headerlink" title="书上的题"></a>书上的题</h4><ul><li><strong>简述你对数据仓库未来发展趋势的看法</strong>。<ul><li>数据仓库技术的发展包括数据抽取、存储管理、数据表现和方法论等方面。在数据抽取方面，未来的技术发展将集中在系统集成化方面。它将互连、转换、复制、调度、监控纳入标准化的统一管理，以适应数据仓库本身或数据源可能的变化，使系统更便于管理和维护。在数据管理方面，未来的发展将使数据库厂商明确推出数据仓库引擎，作为数据仓库服务器产品与数据库服务器并驾齐驱。在这一方面，带有决策支持扩展的并行关系数据库将最具发展潜力。在数据表现方面，数理统计的算法和功能将普遍集成到联机分析产品中，并与Internet/Web技术紧密结合。按行业应用特征细化的数据仓库用户前端软件将成为产品作为数据仓库解决方案的一部分。数据仓库实现过程的方法论将更加普及，将成为数据库设计的一个明确分支，成为管理信息系统设计的必备。</li></ul></li><li><strong>请列出3种数据仓库产品，并说明其优缺点</strong>。<ul><li><strong>Essbase</strong>（MOLAP产品），采用以服务器为中心的分布式体系结构的OLAP服务器。<ul><li>优点是提供丰富的API，具有几百个计算公式，支持多种计算，用户可以自己构建复杂的查询；可以充分定制开发，有30多个前端工具可供选择，支持多种财务标准，能与其他数据源集成。</li><li>缺点是开发难度较大，部署也不容易。</li></ul></li><li><strong>NCR Teradata</strong> 是高端数据仓库市场最有力的竞争者，主要运行在UNIX操作系统平台上。<ul><li>优点是产品性能很好。</li><li>缺点是产品价格相对较高，中小企业用户难以接受，其联机多维分析相对较弱。</li></ul></li><li><strong>SAS系统</strong>是SAS公司提供的数据仓库解决方案包括30多个专用模块。<ul><li>优点是功能强大、性能高、特长突出。</li><li>缺点是系统比较复杂。</li></ul></li></ul></li><li><strong>什么是数据仓库的数据ETL过程</strong>？<ul><li>数据的ETL过程就是调和数据的过程。</li><li>数据ETL是用来实现异构数据源的数据集成，即完成数据的抓取/抽取、清洗、转换、加载与索引等数据调和工作。</li><li>简单地说，数据是从企业内外部的各业务处理系统（操作型数据）流向企业级数据仓库（EDW）或操作型数据存储区(ODS)，在这个过程中，要根据企业（或其他组织）的数据模型和元数据库对数据进行调和处理，形成一个中间数据层，然后再根据分析需求，从调和数据层（EDW、ODS）将数据引入导出数据层，如形成满足各类分析需求的数据集市。</li></ul></li><li><strong>什么是星型模式</strong>？<strong>它的特征是什么</strong>？<ul><li>星型模式是最流行的数据仓库导出数据层的设计结构。</li><li>它的特征是：<ul><li>在星模式中，事实表居中，多个维表呈辐射状分布于其四周，并与事实表连接。</li><li>位于星形中心的实体是事实表，是用户最关心的基本实体和查询活动的中心，为数据仓库的查询活动提供定量数据。</li><li>位于星模式四周的实体是维度实体，其作用是限制和过滤用户的查询结果，缩小访问范围。</li><li>每个维表都有自己的属性，维表和事实表通过关键字相关联。</li></ul></li></ul></li><li><strong>什么是信息包图法</strong>？<strong>它为什么适用于数据仓库的概念模型的设计</strong>？<ul><li>信息包图法，也叫用户信息需求表，就是在一张平面表格上描述元素的多维性，其中的每一个维度用平面表格的一列表示，通常的维度如时间、地点、产品和顾客等。</li><li>而细化本列的对象就是类别，例如时间维度的类别可以细化到年、月、日，甚至小时；平面表格的最后一行（代表超立方体中的单元格）即为指标度量值，例如，某年在某销售点的某类产品的实际销售额。创建信息包图时需要确定最高层和最低层的信息需求，以便最终设计出包含各个层次需要的数据仓库。</li><li>总之，<strong>信息包图法是一种自上而下的数据建模方法</strong>，即从用户的观点开始设计（用户的观点是通过与用户交流得到的），站在管理者的角度把焦点集中在企业的一个或几个主题上，着重分析主题所涉及数据的多维特性，这种自上而下的方法几乎考虑了所有的信息源，以及这些信息源影响业务活动的方式。</li></ul></li><li><strong>什么是关联规则</strong>？<strong>关联规则的应用有哪些</strong>？<ul><li>关联规则挖掘最初由R.Agrawal等人提出，用来发现超级市场中用户购买的商品之间的隐含关联关系，并用规则的形式表示出来，称为关联规则(Association Rule)。</li><li>关联规则除了可以发现<strong>超市购物中隐含的关联关系</strong>之外，还可以应用于其他很多领域。关联规则的应用还包括<strong>文本挖掘、商品广告邮寄分析、网络故障分析等</strong>。</li></ul></li><li><strong>关联规则的分类有哪些</strong>？<strong>关联规则挖掘的步骤包括什么</strong>？<ul><li><strong>关联规则的分类</strong>：<ul><li>基于规则中涉及到的数据的<strong>维数</strong>，关联规则可以分为单维的和多维的。</li><li>基于规则中数据的<strong>抽象层次</strong>，可以分为单层关联规则和多层关联规则。</li><li>基于规则中处理的<strong>变量的类型</strong>不同，关联规则可以分为布尔型和数值型。</li></ul></li><li><strong>关联规则挖掘的步骤</strong>：<ul><li>找出交易数据库中所有大于或等于用户指定的最小支持度的频繁项集；</li><li>利用频繁项集生成所需要的关联规则，根据用户设定的最小可信度进行取舍，产生强关联规则。</li></ul></li></ul></li><li><strong>Apriori 算法的计算题</strong>：P107</li><li><strong>什么是分类</strong>？<strong>分类的应用领域有哪些</strong>？<ul><li>分类是指把数据样本映射到一个事先定义的类中的学习过程，即给定一组输入的属性向量及其对应的类，用基于归纳的学习算法得出分类。</li><li>分类问题在商业、银行业、医疗诊断、生物学、文本挖掘、因特网筛选等领域都有广泛应用。</li><li>例如，在银行业中，分类方法可以辅助工作人员将正常信用卡用户和欺诈信用卡用户进行分类，从而采取有效措施减小银行的损失；在医疗诊断中，分类方法可以帮助医疗人员将正常细胞和癌变细胞进行分类，从而及时制定救治方案，挽救病人的生命；在因特网筛选中，分类方法可以协助网络工作人员将正常邮件和垃圾邮件进行分类，从而制定有效的垃圾邮件过滤机制，防止垃圾邮件干扰人们的正常生活。</li></ul></li><li><strong>什么是聚类分析</strong>？<strong>聚类分析的应用领域有哪些</strong>？<ul><li>聚类分析是将物理的或者抽象的数据集合划分为多个类别的过程，聚类之后的每个类别中任意两个数据样本之间具有较高的相似度，而不同类别的数据样本之间具有较低的相似度。</li><li>聚类分析在科学数据分析、商业、生物学、医疗诊断、文本挖掘、Web数据挖掘等领域都有广泛应用。</li><li>在科学数据分析中，比如对于卫星遥感照片，聚类可以将相似的区域归类，有助于研究人员根据具体情况做进一步分析；在商业领域，聚类可以帮助市场分析人员对客户的基本数据进行分析，发现购买模式不同的客户群，从而协助市场调整销售计划；在生物学方面，聚类可以帮助研究人员按照基因的相似度对动物和植物的种群进行划分，从而获得对种群中固有结构的认识；在医疗诊断中，聚类可以对细胞进行归类，有助于医疗人员发现异常细胞的聚类，从而对病人及时采取措施；在文本挖掘和Web数据挖掘领域中，聚类可以将网站数据按照读者的兴趣度进行划分，从而有助于网站内容的改进。</li></ul></li><li><strong>请描述K-means聚类算法的操作步骤</strong>：P139</li><li><strong>贝叶斯网络的三个主要议题是什么</strong>？<ul><li>预测<ul><li>贝叶斯网络的预测是指从起因推测一个结果的推理，也成为由顶向下的推理。</li></ul></li><li>诊断<ul><li>贝叶斯网络的诊断是指从结果推测一个起因的推理，也称为由底至上的推理。</li></ul></li><li>学习<ul><li>贝叶斯网络的学习是指由先验的贝叶斯网络得到后验的贝叶斯网络的过程。</li></ul></li></ul></li><li><strong>怎样从历史数据中训练出结点之间的条件概率或联合条件概率</strong>？<ul><li>要训练条件概率$P(B|A)$，可以在历史数据中统计A发生的次数$T(A)$，然后统计在A发生的数据中B发生的次数$T(A,B)$，条件概率$P(B|A) = T(B)/T(A)$。</li><li>要训练联合条件概率$P(C|A,B$)，可以在历史数据中统计A、B共同发生的次数$T(A,B)$，然后在A、B共同发生的数据中统计C发生的次数T$(A,B,C)$，联合条件概率$P(C|A,B)=T(A,B,C)/T(A,B)$。</li><li>以上的符号A、B、C可以表示某个事件，也可以表示该事件的相反事件。</li></ul></li><li><strong>如果贝叶斯网络的各个结点都没有任何证据，从历史数据中如何用两种不同的方法的得到各结点的发生概率</strong>？<ul><li>用各节点的发生次数除以总的数据条数，就是各个节点的发生概率。</li><li>首先，用第一种方法计算原因节点的发生概率，然后计算原因节点到中间节点或结果节点的条件概率，最后根据原因节点的概率和这些条件概率计算结果节点的概率。</li></ul></li><li><strong>前馈网络和递归网络有什么本质区别</strong>？<ul><li>前馈网络和递归网络的本质区别是网络的某些输出是不是循环作为网络的输入。</li><li>前馈网络的所有输出都不能作为输入，而递归网络的某些输出可以循环作为网络的输入。</li></ul></li><li><strong>多层前馈网络中隐藏层神经元的作用是什么</strong>？<ul><li>多层前馈网络中隐藏层神经元的作用是增强网络的适应能力。</li><li>通过隐藏层，多层前馈网络可以逼近系统中任意非线性的成分。</li></ul></li><li><strong>在 BP 算法中，总体误差对网络输出的偏导数和和有序导数是否一致</strong>？<strong>总体误差对网络输入的偏导数和有序导数是否一致</strong>？<ul><li>在BP算法中，总体误差对网络输出的偏导数和有序导数始终一致。<ul><li>这是因为：总体误差与网络输出变量之间没有中间变量。</li></ul></li><li>而总体误差对网络输入的偏导数和有序导数是不一致的。<ul><li>这是因为：总体误差和输入变量之间有中间变量。</li></ul></li></ul></li><li><strong>遗传算法的主要应用有哪些</strong>？<ul><li>函数优化问题</li><li>组合优化问题</li><li>生产调度问题</li><li>自动控制</li><li>图像处理</li><li>人工生命</li><li>遗传编程</li><li>机器学习</li></ul></li><li><strong>简单遗传算法包括哪些步骤</strong>？<ul><li>SGA的基本流程如下：<ul><li>初始化，产生初始种群。</li><li>个体评价，即计算种群中每个个体的适应度。</li><li>按选择概率Ps，执行选择算子，从当前种群中选择部分个体进入下一代种群。</li><li>按交叉概率Pc，执行交叉算子。</li><li>按变异概率Pm，执行变异算子。</li><li>若满足设定的终止条件，则输出种群中适应度最优的个体作为问题的最优解或满意解，否则执行（2）。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;填空题&quot;&gt;&lt;a href=&quot;#填空题&quot; class=&quot;headerlink&quot; title=&quot;填空题&quot;&gt;&lt;/a&gt;填空题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据仓库就是一个&lt;strong&gt;面向主题的&lt;/strong&gt;、集成的、&lt;strong&gt;相对稳定的&lt;/strong&gt;、反映历史变化的数据集合。&lt;/li&gt;
&lt;li&gt;数据处理通常分成两大类：联机事务处理(OLTP)和&lt;strong&gt;联机分析处理(OLAP)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;调和数据是存储在&lt;strong&gt;企业级数据仓库&lt;/strong&gt;(EDW)和操作型数据存储中的数据。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据挖掘" scheme="http://tianyuzhou.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>算法基础概念</title>
    <link href="http://tianyuzhou.github.io/2020/12/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://tianyuzhou.github.io/2020/12/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2020-12-23T12:37:54.000Z</published>
    <updated>2021-02-17T13:32:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li><strong>递归</strong><ul><li>直接或间接地调用自身的算法称为递归算法，用函数自身给出定义的函数称为递归函数。</li><li>每个递归函数都要有非递归定义的初始值，如阶乘函数，斐波那契，汉诺塔。<span id="more"></span></li></ul></li><li><strong>分治策略</strong><ul><li>基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题<strong>相互独立且与原问题相同</strong>。递归地解这些子问题，然后将各个子问题的解<strong>合并</strong>得到原问题的解。</li><li>例如：二分查找、大整数乘法、strassen矩阵乘法、归并排序、快速排序、棋盘覆盖</li></ul></li><li><strong>动态规划</strong>（自底向上）<ul><li>和分治法类似，都是将待求问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>动态规划从最小的问题开始，<strong>逐层向上</strong>求解，<strong>通过子问题之间的依赖关系，有效利用前面已经得到的结果</strong>，最大限度减少重复工作，以提高算法效率。</li><li>要素<ul><li>最优子结构性质（优化原则）<ul><li>当<strong>问题的最优解<em>包含了</em>其子问题的最优解</strong>时，则称该问题具有最优子结构性质。这个性质是动态规划算法求解的重要线索。</li></ul></li><li>子问题重叠性质<ul><li>在运用递归算法自顶向下解题时，每次产生的子问题并不总是新问题，动态规划将计算过的子问题保存在一个表格中，当再次使用时直接搜索到它拿过来用就行了。</li></ul></li></ul></li><li>例如：大矩阵乘法、最长公共子序列、流水作业调度、0-1背包</li></ul></li><li><strong>贪心法</strong><ul><li>贪心算法并不从整体的最优解考虑，而是做出当前的局部最优的选择。</li><li>要素<ul><li>最优子结构（组合优化）</li><li>贪心选择性质<ul><li>贪心选择性质是指所求问题的整体最优解可以通过一系列<strong>局部最优</strong>的选择(即贪心选择)来达到。</li></ul></li></ul></li><li>例如：活动安排问题、哈夫曼编码($O(nlogn)$)</li></ul></li><li>动态规划算法与贪心算法的异同:<ul><li>共同点：<ul><li>都需要最优子结构性质。</li><li>都用来求有优化问题。</li><li>不同点：<ul><li>动态规划：<ul><li>每一步作一个选择——<strong>依赖</strong>于子问题的解。</li></ul></li><li>贪心方法：<ul><li>每一步作一个选择——<strong>不依赖</strong>于子问题的解。</li><li>动态规划方法的条件：最优子结构性质；子问题的重叠性质。</li><li>可用贪心方法的条件：最优子结构性质；贪心选择性质。</li></ul></li></ul></li></ul></li><li>动态规划：<strong>自底向上求解</strong>（动态规划方法是自底向上计算各个子问 题的最优解，即先计算子问题的最优解，然后再利用子问题的最优解构造大问题的最优解，因此需要最优子结构）</li><li>贪心法：<strong>自顶向下求解</strong>。</li><li>可用贪心法时，动态规划方法可能不适用；</li><li>可用动态规划方法时，贪心法可能不适用。</li></ul></li><li><strong>回溯法</strong><ul><li>为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。</li><li><strong>具有限界函数的深度优先生成法称为回溯法</strong>。</li><li>两种解空间树：<ul><li>子集树<ul><li>当我们求解的结果是集合的某一子集的时候，其对应的解空间是子集树。</li><li>例如：八皇后问题、0-1背包问题</li></ul></li><li>排列树<ul><li>当我们求解的结果是集合元素的某一种排列的时候，其对应的解空间就是排列树。</li><li>例如：货郎问题（$O(n!)$）</li></ul></li></ul></li></ul></li><li><strong>分支限界法</strong>（回溯法的改进）<ul><li>队列式(FIFO)分支限界法—将活结点表组织成一个队列，按照先进先出(FIFO)原则选取下一个结点为扩展结点;</li><li>优先队列式分支限界法—将活结点表组织 成一个优先队列，按照规定的优先级选取优先级最高的结点成为当前扩展结点。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;直接或间接地调用自身的算法称为递归算法，用函数自身给出定义的函数称为递归函数。&lt;/li&gt;
&lt;li&gt;每个递归函数都要有非递归定义的初始值，如阶乘函数，斐波那契，汉诺塔。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法分析与设计" scheme="http://tianyuzhou.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://tianyuzhou.github.io/2020/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://tianyuzhou.github.io/2020/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-12-20T07:36:19.000Z</published>
    <updated>2021-02-17T13:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>应用层协议的特点</li><li>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。<strong>应用层的具体内容就是规定应用进程在<em>通信时</em>所遵循的协议</strong>。</li><li>应用层的许多协议都是基于<strong>客户服务器</strong>方式。<span id="more"></span></li></ul><h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><ul><li>域名系统概述<ul><li>许多应用层软件经常直接使用<strong>域名系统 DNS**</strong> (Domain Name System)，但<strong>计算机的用户只是间接而不是直接使用域名系统</strong>。</li><li>互联网采用层次结构的命名树作为主机的名字，并使用<strong>分布式</strong>的域名系统 DNS。</li><li>名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为<strong>域名服务器</strong>。</li></ul></li><li>互联网的域名结构<ul><li>互联网采用了<strong>层次树状结构</strong>的命名方法。</li><li>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</li><li>域名的结构由标号序列组成，各标号之间用点隔开：<strong>… . 三级域名 . 二级域名 . 顶级域名</strong></li><li>各标号分别代表不同级别的域名。</li><li>顶级域名 TLD(Top Level Domain)<ul><li><strong>国家顶级域名 nTLD</strong><ul><li>.cn 表示中国，</li><li>.us 表示美国，</li><li>.uk 表示英国，等等。</li></ul></li><li><strong>通用顶级域名 gTLD</strong><ul><li>最早的顶级域名是：</li><li>.com（公司和企业）</li><li>.net（网络服务机构）</li><li>.org（非赢利性组织）</li><li>.edu（美国专用的教育机构）</li><li>.gov（美国专用的政府部门）</li><li>.mil（美国专用的军事部门）</li><li>.int（国际组织）</li></ul></li><li><strong>基础结构域名 (infrastructure domain)</strong><ul><li>这种顶级域名只有一个，即 <strong>arpa</strong>，用于反向域名解析，因此又称为<strong>反向域名</strong>。</li></ul></li></ul></li></ul></li><li>域名服务器<ul><li>一个服务器所负责管辖的（或有权限的）范围叫做<strong>区</strong> (zone)。</li><li>各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。</li><li>每一个区设置相应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的<strong>域名到 IP 地址的映射</strong>。</li><li><strong>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位</strong>。</li><li><img src="https://pic.zty.plus/DNS%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86.png" alt="DNS区"></li><li>域名服务器有以下四种类型<ul><li><strong>根域名服务器</strong><ul><li>根域名服务器是<strong>最高层次</strong>的域名服务器，也是<strong>最重要</strong>的域名服务器。所有的根域名服务器都<strong>知道所有的顶级域名服务器的域名和 IP 地址</strong>。</li><li>不管是哪一个<strong>本地域名服务器</strong>，若要对互联网上任何一个域名进行解析，只要自己无法解析，就<strong>首先求助于根域名服务器</strong>。</li><li>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a 一直到 m（前 13 个字母）。(a.rootservers.net，b.rootservers.net ……)</li><li><strong>根域名服务器共有 13 套装置，不是 13 个机器</strong>。</li></ul></li><li><strong>顶级域名服务器</strong><ul><li>顶级域名服务器（即 <strong>TLD 服务器</strong>,Top Level Domain）负责<strong>管理在该顶级域名服务器注册的所有二级域名</strong>。</li><li>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li></ul></li><li><strong>权限域名服务器</strong><ul><li>责一个区的域名服务器。</li><li>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器</li></ul></li><li><strong>本地域名服务器</strong><ul><li>本地域名服务器对域名系统非常重要。</li><li>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li><li>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，</li><li>这种域名服务器有时也称为<strong>默认域名服务器</strong>。</li></ul></li></ul></li><li>域名的解析过程<ul><li><strong>主机向本地域名服务器的查询一般都是采用</strong>递归查询。<br><img src="https://pic.zty.plus/%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" alt="递归查询"></li><li><strong>本地域名服务器向根域名服务器的查询通常是采用</strong>迭代查询。<br><img src="https://pic.zty.plus/%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" alt="迭代查询"></li></ul></li></ul></li></ul><h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h3><ul><li>FTP概述<ul><li><strong>文件传送协议 FTP</strong> (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。</li><li>FTP 提供<strong>交互式</strong>的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</li><li>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</li></ul></li><li>FTP 的基本工作原理<ul><li>FTP 特点<ul><li>文件传送协议 FTP 只提供文件传送的一些基本的服务，它<strong>使用 TCP 可靠的运输服务</strong>。</li><li>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP 使用<strong>客户服务器方式</strong>。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：<strong>一个主进程</strong>，负责接受新的请求；另外有<strong>若干个从属进程</strong>，负责处理单个请求。</li></ul></li><li>主进程的工作步骤<ul><li>打开熟知端口（<strong>端口号为 21</strong>），使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</li></ul></li><li>两个连接<ul><li><strong>控制连接</strong>(21)在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的<strong>控制进程</strong>，但控制连接不用来传送文件。</li><li>实际用于传输文件的是“<strong>数据连接</strong>(20)”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“<strong>数据传送进程</strong>”和“<strong>数据连接</strong>”，用来连接客户端和服务器端的数据传送进程。</li><li>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</li><li><img src="https://pic.zty.plus/FTP%E4%B8%A4%E8%BF%9E%E6%8E%A5.png" alt="FTP两连接"></li></ul></li><li>两个不同的端口号<ul><li>客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的<strong>熟知端口 (21)</strong>，同时还要<strong>告诉服务器进程自己的另一个端口号码，用于建立数据传送连接</strong>。</li><li>接着，服务器进程用自己传送数据的<strong>熟知端口 (20)</strong> 与客户进程所提供的端口号码建立数据传送连接。</li><li>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</li><li>好处：<ul><li>使协议更加简单和更容易实现。</li><li>在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。</li></ul></li></ul></li></ul></li><li>简单文件传送协议 TFTP<ul><li>TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。</li><li>TFTP 使用<strong>客户服务器方式</strong>和使用 <strong>UDP 数据报</strong>，因此 TFTP 需要有自己的差错改正措施。</li><li>TFTP 只支持文件传输而<strong>不支持交互</strong>。</li><li>TFTP 没有一个庞大的命令集，<strong>没有列目录的功能</strong>，也<strong>不能对用户进行身份鉴别</strong>。</li></ul></li></ul><h3 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h3><ul><li>TELNET 是一个简单的远程终端协议，也是互联网的正式标准。</li><li>用户用 TELNET 就可在其所在地<strong>通过 TCP 连接</strong>注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</li><li>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。</li></ul><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><ul><li>万维网概述<ul><li>万维网 WWW (World Wide Web) <strong>并非某种特殊的计算机网络</strong>。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用<strong>链接</strong>的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li><li><img src="https://pic.zty.plus/%E4%B8%87%E7%BB%B4%E7%BD%91%E5%88%86%E5%B8%83%E5%BC%8F.png" alt="万维网分布式"></li><li>超媒体与超文本<ul><li>万维网是<strong>分布式超媒体 (hypermedia) 系统</strong>，它是<strong>超文本 (hypertext) 系统的扩充</strong>。</li><li><strong>一个超文本由多个信息源链接成</strong>。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。</li><li><strong>超媒体与超文本的区别是文档内容不同</strong>。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</li></ul></li><li>万维网的工作方式<ul><li>万维网以<strong>客户-服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul></li><li>万维网必须解决的问题<ul><li><strong>怎样标志分布在整个互联网上的万维网文档？</strong><ul><li>使用<strong>统一资源定位符 URL</strong> (Uniform Resource Locator) 来标志万维网上的各种文档。</li><li>使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</li></ul></li><li><strong>用何协议实现万维网上各种超链的链接？</strong><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议 HTTP</strong> (HyperText Transfer Protocol)。</li><li>HTTP 是一个<strong>应用层协议</strong>，它<strong>使用 TCP 连接</strong>进行可靠的传送。</li></ul></li><li><strong>怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？</strong><ul><li><strong>超文本标记语言 HTML</strong> (HyperText Markup Language) 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。</li></ul></li><li><strong>怎样使用户能够很方便地找到所需的信息？</strong><ul><li>为了在万维网上方便地查找信息，用户可使用各种的<strong>搜索工具</strong>（即<strong>搜索引擎</strong>）。</li></ul></li></ul></li></ul></li><li>统一资源定位符 URL<ul><li>URL的格式<ul><li>由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。</li><li>URL 的一般形式是：<ul><li><img src="https://pic.zty.plus/URL%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F.png" alt="URL的一般形式"></li></ul></li></ul></li></ul></li><li>超文本传送协议 HTTP<ul><li>HTTP 的操作过程<ul><li>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。</li><li>从层次的角度看，HTTP 是<strong>面向事务</strong>的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</li><li><img src="https://pic.zty.plus/%E4%B8%87%E7%BB%B4%E7%BD%91%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="万维网工作过程"></li><li>用户点击 URL <a href="http://www.tsinghua.edu.cn/chn/yxsz/index.htm">http://www.tsinghua.edu.cn/chn/yxsz/index.htm</a> 后所发生的事件<ul><li>(1) 浏览器分析超链指向页面的 URL。</li><li>(2) 浏览器向 DNS 请求解析 www.tsinghua.edu.cn 的 IP 地址。</li><li>(3) 域名系统 DNS 解析出清华大学服务器的 IP 地址。</li><li>(4) 浏览器与服务器建立 TCP 连接。</li><li>(5) 浏览器发出取文件命令：GET /chn/yxsz/index.htm。</li><li>(6) 服务器给出响应，把文件 index.htm 发给浏览器。</li><li>(7) TCP 连接释放。</li><li>(8) 浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</li></ul></li></ul></li><li>HTTP 的主要特点<ul><li>HTTP 是<strong>面向事务的</strong>客户服务器协议。</li><li><strong>HTTP 1.0</strong> 协议是<strong>无状态的</strong> (stateless)。</li><li>HTTP 协议本身也是<strong>无连接的</strong>，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li><img src="https://pic.zty.plus/HTTP%E8%80%97%E6%97%B6.png" alt="HTTP耗时"></li><li>持续连接<ul><li><strong>HTTP/1.1 协议使用持续连接</strong> (persistent connection)。</li><li>万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</li><li>这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</li><li>目前一些流行的浏览器（例如，IE 6.0）的默认设置就是使用 HTTP/1.1。</li></ul></li><li>持续连接的两种工作方式<ul><li><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但<strong>服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源</strong>。</li><li><strong>流水线方式</strong>：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT 时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li></ul></li></ul></li><li>代理服务器<ul><li><strong>代理服务器</strong> (proxy server) 又称为<strong>万维网高速缓存</strong> (Web cache)，它代表浏览器发出 HTTP 请求。</li><li>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。</li><li>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。  </li></ul></li><li>HTTP 的报文结构<ul><li>HTTP 有两类报文：<ul><li><strong>请求报文</strong>——从客户向服务器发送请求报文。</li><li><strong>响应报文</strong>——从服务器到客户的回答。</li><li>由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 <strong>ASCII</strong> 码串，因而每个字段的长度都是不确定的。</li></ul></li></ul></li><li>在服务器上存放用户的信息<ul><li>万维网站点使用 Cookie 来跟踪用户。</li><li><strong>Cookie</strong> 表示在 HTTP 服务器和客户之间传递的状态信息。</li><li>使用 Cookie 的网站服务器为用户产生一个<strong>唯一的识别码</strong>。利用此识别码，网站就能够跟踪该用户在该网站的活动。</li></ul></li></ul></li><li>万维网的文档<ul><li>超文本标记语言 HTML<ul><li>XML<ul><li>XML (Extensible Markup Language)是可扩展标记语言，它和HTML很相似。</li><li>但XML的设计宗旨是传输数据，而不是显示数据（HTML是为了在浏览器上显示数据）。</li></ul></li><li>XHTML<ul><li>XHTML (Extensible HTML) 是可扩展超文本标记语言，它与 HTML 4.01 几乎是相同的。</li></ul></li><li>CSS<ul><li>CSS (Cascading Style Sheets) 是层叠样式表，它是一种样式表语言，用于为 HTML 文档定义布局。</li></ul></li></ul></li><li>动态万维网文档<ul><li><strong>静态文档</strong>是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。</li><li><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序<strong>动态创建</strong>。</li><li>动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。</li></ul></li></ul></li><li>万维网的信息检索系统<ul><li>全文检索搜索和分类目录搜索<ul><li>在万维网中用来进行搜索的程序叫做<strong>搜索引擎</strong>。</li><li><strong>全文检索搜索引擎</strong>是一种纯技术型的检索工具。它的工作原理是通过搜索软件到互联网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。</li><li>用户在查询时只要输入关键词，就从已经建立的索引数据库上进行查询（<strong>并不是实时地在互联网上检索到的信息</strong>）。</li></ul></li><li>分类目录搜索<ul><li><strong>分类目录搜索引擎</strong>并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。</li><li>分类目录搜索也叫做<strong>分类网站搜索</strong>。</li></ul></li><li>最著名的全文检索搜索引擎：<ul><li>Google（谷歌）(www.google.com)</li><li>百度 (www.baidu.com)</li></ul></li><li>最著名的分类目录搜索引擎：<ul><li>雅虎 (www.yahoo.com)</li><li>雅虎中国 (cn.yahoo.com)</li><li>新浪 (www.sina.com)</li><li>搜狐 (www.sohu.com)</li><li>网易 (www.163.com)</li></ul></li></ul></li></ul><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><ul><li>电子邮件概述<ul><li>电子邮件的一些标准<ul><li>发送邮件的协议：SMTP</li><li>读取邮件的协议：POP3 和 IMAP</li><li>MIME 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。</li></ul></li><li>电子邮件的最主要的组成构件<ul><li><img src="https://pic.zty.plus/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E6%9E%84%E4%BB%B6.png" alt="电子邮件"></li></ul></li></ul></li><li>简单邮件传送协议 SMTP<ul><li>SMTP 所规定的就是在两个相互通信的 SMTP 进程之间应如何交换信息。</li><li>由于 SMTP 使用<strong>客户服务器</strong>方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。</li><li>SMTP 规定了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上（也可不附上）很简单的文字说明。</li><li>SMTP 通信的三个阶段<ul><li><strong>连接建立</strong>：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。<strong>SMTP不使用中间的邮件服务器</strong>。</li><li><strong>邮件传送</strong></li><li><strong>连接释放</strong>：邮件发送完毕后，SMTP 应释放 TCP 连接。</li></ul></li></ul></li></ul><h3 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h3><ul><li>互联网广泛使用的<strong>动态主机配置协议</strong> DHCP (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取IP 地址而不用手工参与。</li><li>DHCP 使用客户-服务器方式<ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器<strong>广播发送*</strong>发现报文*（DHCPDISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做<em>提供报文</em>（DHCPOFFER）。</li></ul></li><li>DHCP 中继代理(relay agent)<ul><li>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP <strong>中继代理</strong>，它配置了 DHCP 服务器的 IP 地址信息。</li><li>当 DHCP 中继代理收到主机发送的发现报文后，就以<strong>单播方式</strong>向 DHCP 服务器<strong>转发</strong>此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</li><li><img src="https://pic.zty.plus/DHCP%E4%B8%AD%E7%BB%A7%E4%BB%A3%E7%90%86.png" alt="DHCP中继代理"></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;应用层协议的特点&lt;/li&gt;
&lt;li&gt;每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。&lt;strong&gt;应用层的具体内容就是规定应用进程在&lt;em&gt;通信时&lt;/em&gt;所遵循的协议&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;应用层的许多协议都是基于&lt;strong&gt;客户服务器&lt;/strong&gt;方式。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>组成与系统结构-复习</title>
    <link href="http://tianyuzhou.github.io/2020/12/17/%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%8D%E4%B9%A0/"/>
    <id>http://tianyuzhou.github.io/2020/12/17/%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-12-17T05:59:07.000Z</published>
    <updated>2021-02-17T13:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><strong>对阶</strong><ul><li>浮点数加/减运算时，在尾数相加/减之前所进行的操作称为对阶。</li><li>对阶时，需要比较两个阶的大小。阶小的那个数的尾数右移（小数点左移），阶码增加。右移一次，阶码加1，直到两数的阶码相等为止。<span id="more"></span></li></ul></li><li><strong>真值</strong><ul><li><strong>机器数真正的值</strong>(即原来带有正负号的数)称为机器数的真值。</li></ul></li><li><strong>机器数</strong><ul><li>通常将数值数据在计算机内部编码表示的数称为机器数。</li></ul></li><li><strong>机器字长</strong><ul><li>一个二进制位(bit,比特)是计算机内部信息表示的最小单位。</li><li>而机器字长指的是特定计算机中CPU用于<strong>定点整数运算的数据通路的宽度</strong>，通常也就是CPU内<strong>定点数运算器和通用寄存器的位数</strong>。</li></ul></li><li><strong>数据通路</strong><ul><li>数据通路是指，指令在执行过程中数据所经过的<strong>部件</strong>以及<strong>部件之间的连接线路</strong>，主要由 <strong>ALU</strong> 和<strong>一组寄存器、存储器、总线等组成</strong>。</li><li>国内许多教科书中提到的运算器即是运算数据通路。</li></ul></li><li><strong>立即寻址</strong><ul><li>指令中的地址码直接给出操作数本身。</li></ul></li><li><strong>直接寻址</strong><ul><li>指令中的地址码给出的是操作数所在的存储单元地址，称为直接地址。</li></ul></li><li><strong>间接寻址</strong><ul><li>指令中的地址码给出的是操作数所在的存储单元地址所在的存储单元地址，称为间接地址。</li></ul></li><li><strong>寄存器寻址</strong><ul><li>指令中的地址码给出的是操作数所在的寄存器的编号。</li></ul></li><li><strong>寄存器间接寻址</strong><ul><li>指令中的地址码给出的是操作数所在的存储单元的地址所在的寄存器的编号。</li></ul></li><li><strong>相对寻址</strong><ul><li>相对寻址方式下，指令中的形式地址给出一个位移量D，而基准地址由程序计数器PC提供。即有效地址$EA=(PC)+D$。</li></ul></li><li><strong>基址寻址</strong><ul><li>基址寻址方式下，指令中的地址码给出一个形式地址，作为位移量，并且<strong>隐含或明显地</strong>指定一个寄存器作为基址寄存器，基址寄存器的内容和形式地址相加，得到操作数的有效地址，根据有效地址到存储器中访问，去取操作数或写运算结果。</li></ul></li><li><strong>变址寻址</strong><ul><li>变址寻址方式下，指令中的地址码给出一个形式地址，并且隐<strong>含或明显地</strong>指定一个寄存器作为变址寄存器，变址寄存器的内容（变址值）和形式地址相加，得到操作数的有效地址，根据有效地址到存储器中访问，去取操作数或写运算结果。</li></ul></li><li><strong>中断向量</strong><ul><li>每个中断源都有对应的处理程序，我们称这个处理程序为中断服务程序，其<strong>入口地址</strong>称为中断向量。</li></ul></li><li><strong>向量中断</strong><ul><li>是指一种<strong>识别中断源的技术或方式</strong>。识别中断源的目的就是要找到中断源对应的中断服务程序的入口地址，即获得向量地址。</li></ul></li><li><strong>中断向量表</strong><ul><li>所有中断（包括异常）的中断服务程序入口地址构成一个表，称为中断向量表。</li><li>也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。</li></ul></li><li><strong>向量地址</strong><ul><li>中断向量表或中断向量跳转表中每个<strong>表项</strong>所在的内存地址称为向量地址。</li></ul></li><li><strong>结构冒险</strong><ul><li>在指令流水线中，同一个<strong>部件</strong>同时被不同指令所使用的现象称为结构冒险，也称为资源冲突。</li></ul></li><li><strong>数据冒险</strong><ul><li>在指令流水线中，后面指令用到前面指令的<strong>结果</strong>时，前面指令的结果还未产生的现象称为数据冒险，也称为数据相关。</li></ul></li><li><strong>控制冒险</strong><ul><li>在指令流水线中，<strong>转移指令或异常</strong>等情况改变了程序执行的流程，而使得在目标地址产生前已被取到流水线中的指令无效的现象称为控制冒险，也称分支冒险。</li></ul></li><li><strong>存储保护</strong><ul><li>虚拟存储器可以实现多道程序运行，也就是说，在一个主存物理空间中同时有多个进程共存。</li><li>为避免<strong>主存中</strong>多道程序的相互干扰，防止某进程出错而破坏其他进程的正确性，或某进程不合法地访问其他进程的存储器，应对每个进程进行存储保护。</li></ul></li><li><strong>缺页</strong><ul><li>需要访问的页不在内存中时，则发生“缺页异常”。通过检查“有效位”就可以判断是否“缺页”。</li></ul></li><li><strong>页表</strong><ul><li>每个进程有一个页表，记录该进程的每个页存放在主存的哪个页框中，或在辅存的哪个地方。</li><li>页表中一般有装入位（有效位）、修改位、使用位、实页号等。</li></ul></li><li><strong>DMA 方式</strong><ul><li>DMA 是Direct Memory Access(直接存储器存取)的缩写。</li><li>每次需要进行外设数据读写时，首先 CPU 把要传送的数据个数、数据块在内存的首址、数据传送的方向（是读还是写操作）、设备的地址等参数送给 DMA 控制器，然后发送一个命令给 DMA 接口，启动外设进行数据准备工作。在这些工作完成后，CPU 就继续进行其他工作。</li><li>此时，外设和 CPU 并行工作，而 I/O 设备和主存交换数据的事情就交给了 DMA 控制器。</li></ul></li></ul><h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><ul><li><strong>为什么计算机内部采用二进制表示信息？既然计算机内部所有信息都用二进制表示，为什么还用到十六进制或八进制数？</strong><ul><li>使用二进制原因：<ul><li>二进制系统只有两个基本符号：0 和 1。所以它的基本符号少，易于稳态电路的实现。</li><li>二进制的编码、记数、运算等规则简单。</li><li>二进制中的 0 和 1 与逻辑命题的“真”和“假”的对应关系简单，为计算机中实现逻辑运算和程序中的逻辑判断提供了便利的条件，特别是能通过逻辑门电路方便地实现算术运算。</li></ul></li><li>计算机内部在进行信息的存储、传送和运算时，都是以二进制形式来表示信息的。但在屏幕上或书本上书写信息时，由于二进制信息位数多，阅读、记忆不方便，而十六进制、八进制和二进制的对应关系简单，又便于阅读、记忆和书写，所以引入十六进制或八进制，使得人们在开发、调试程序和阅读机器内部代码时，能方便地用八进制或十六进制来等价表示二进制信息。</li></ul></li><li><strong>常用的定点数编码方式有哪几种？通常它们各自用来表示什么？</strong><ul><li>定点数是计算机中小数点固定在最左边或最右边的数，有定点整数和定点小数两种。</li><li>定点数的编码方式有<strong>原码、反码、补码和移码</strong>。浮点数的<strong>尾数</strong>一般用<strong>原码</strong>小数来表示；浮点数的<strong>阶码</strong>一般用<strong>移码</strong>来表示；常用<strong>补码</strong>表示<strong>带符号整数</strong>；而反码很少被使用，只用在某些特殊场合。</li></ul></li><li><strong>在浮点数的基数和总位数一定的情况下，浮点数的表示范围和精度分别由什么决定？两者如何互制约？</strong><ul><li>浮点数的精度取决于尾数的位数，数值范围取决于阶码的位数。在浮点数总位数不变的情况下，阶码位数越多，则尾数位数越少，即表示范围越大，则精度越差（数变稀疏）。</li></ul></li><li><strong>一条指令中应该显式或隐式地给出寻址信息是什么？</strong><ul><li><strong>操作码</strong>：指定操作类型，如移位、加减乘除、传送等。</li><li><strong>源操作数或其地址</strong>：指出一个或多个源操作数或其地址，可以是主(虚)存地址、寄存器编号、或 I/O 端口，也可以在指令中直接给出一个立即数。</li><li><strong>结果的地址</strong>：结果所存放的地址，可以是主(虚)存地址、寄存器编号、或 I/O 端口。</li><li><strong>下一条指令地址</strong>：下一条指令存放的地址，可以是主(虚)存地址。</li></ul></li><li><strong>哪些寻址方式下的操作数在寄存器中？哪些寻址方式下的操作数在存储器中？</strong><ul><li>操作数在寄存器中：寄存器寻址。</li><li>操作数在存储器中：直接寻址、间接寻址、寄存器间接寻址、偏移寻址（变址寻址、基址寻址、相对寻址）。</li></ul></li><li><strong>基址寻址方式和变址寻址方式的作用各是什么？有何相同点和不同点？</strong><ul><li><strong>相同点</strong>：变址寻址方式和基址寻址方式的有效地址形成过程类似。</li><li><strong>不同点</strong>（两个方面）：<ul><li><strong>具体应用的场合不同</strong>：<ul><li>变址寻址面向用户，可用于访问字符串、数组、表格等成批数据或其中的某些元素（变址寻址作用）。</li><li>基址寻址面向系统，用于解决程序的重定位问题和短地址访问大空间的问题（基址寻址作用）。</li></ul></li><li><strong>使用方式不同</strong>：<ul><li>变址寻址时，指令中提供的形式地址是一个基准地址，位移量由变址寄存器给出。</li><li>而基址寻址时，指令中给出的形式地址为位移量，而基址寄存器中存放的是基准地址。</li></ul></li></ul></li></ul></li><li><strong>RISC(精简指令集计算机) 处理器的特点有哪些？</strong><ul><li><strong>指令数目少</strong>：只包含使用频度高的简单指令。</li><li><strong>指令格式规整</strong>：寻址方式少，指令格式少，指令长度一致。</li><li><strong>采用$Load/Store$型指令设计风格</strong>：只有 Load 和 Store 指令才能访存。</li><li><strong>采用流水线方式执行指令</strong>：规整的指令格式有利于采用流水线方式执行，除$Load/Store$指令外，其他指令都只需一个或小于一个时钟周期就可完成，指令周期短。</li><li><strong>采用大量通用寄存器</strong>：编译器可将变量分配到寄存器中，以减少访存次数。</li><li><strong>采用硬连线控制器</strong>：指令少而规整使得控制器的实现变得简单，可以不用或少用微程序控制。</li><li><strong>采用优化的编译系统</strong>：指令数少有利于编译器的优化。</li></ul></li><li><strong>CPU 中标志寄存器的功能是什么？有哪几种基本标志？</strong><ul><li>标志寄存器又称程序状态字。用于存放条件标志、控制标志，反映处理器的状态和ALU运算结果的某些特征及控制指令的执行。</li><li>6个状态标志：<ul><li>CF(Carry Flag)——进位标志位。</li><li>PF(Parity Flag)——奇偶标志位。该标志位反映运算结果中1的个数是偶数还是奇数。</li><li>AF(Auxiliary carry Flag)——辅助进位标志位。当执行一个加法(或减法)运算，使结果的低4位向高4位有进位(或借位)时，AF=1；否则AF=0。</li><li>ZF(Zero Flag)——零标志位。</li><li>SF(Sign Flag)——符号标志位。</li><li>OF(Overflow Flag)——溢出标志位。</li></ul></li><li>3个控制标志位用来控制CPU的操作，由指令进行置位和复位。<ul><li>DF(Direction Flag)——方向标志位。它用以指定字符串处理时的方向。</li><li>IF(Interrupt enable Flag)——中断允许标志位。它用来控制8086是否允许接收外部中断请求。</li><li>TF(Trap Flag)——跟踪标志位。它是为调试程序而设定的陷阱控制位。当该位置“1”时，8086 CPU处于单步状态，此时CPU每执行完一条指令就自动产生一次内部中断。当该位复位后，CPU恢复正常工作。</li></ul></li></ul></li><li><strong>CPU 的基本组成和基本功能各是什么？</strong><ul><li>CPU 主要由<strong>数据通路</strong>和<strong>控制单元</strong>(部件)组成。<ul><li>数据通路中包含组合逻辑单元和存储信息的状态单元。组合逻辑单元用于对数据进行处理，如加法器、ALU、扩展器(0扩展或符号扩展)、多路选择器以及总线接口逻辑等；状态单元包括触发器、寄存器等，用于对指令执行的中间状态或最终结果进行保存。</li><li>控制单元也称为控制器，主要功能是对取出的指令进行译码，并与指令执行得到的条件码或当前机器的状态、时序信号等组合，生成对数据通路进行控制的控制信号。</li></ul></li><li>CPU总是周而复始地执行指令，并在执行指令过程中检测和处理内部异常事件和外部中断请求。在此过程中，要求CPU具有以下各种功能：<ul><li><strong>取指令并译码</strong>：从存储器取出指令，并对指令操作码译码，以控制CPU进行相应的操作。</li><li><strong>计算PC的值</strong>：通过自动计算PC的值来确定下一条指令地址，以正确控制执行顺序。</li><li><strong>算数逻辑运算</strong>：计算操作数地址，或对操作数进行算术或逻辑运算。</li><li><strong>取操作数或写结果</strong>：通过控制对存储器或I/O接口的访问来读取操作数或写结果。</li><li><strong>异常或中断处理</strong>：检测有无异常事件或中断请求，必要时响应并调出相应处理程序执行。</li><li><strong>时序控制</strong>：通过生成时钟信号来控制上述每个操作的先后顺序和操作时间。</li></ul></li></ul></li><li><strong>取指令部件的功能是什么？</strong><ul><li>取指令并计算下条指令地址。</li><li>下地址逻辑中，要区分是顺序执行还是转移执行。顺序执行，PC=PC+取出的指令长度；转移执行要根据当前指令是分支还是跳转指令来计算目标地址。</li></ul></li><li><strong>控制器的功能是什么？</strong><ul><li>对指令进行译码，将译码结果和状态/标志信号和时序信号进行组合，产生各种操作信号，即产生各条指令所需的控制信号。</li><li>有两大类控制信号：CPU 内部控制信号和发送到系统总线上的控制信号。</li></ul></li><li><strong>硬连线控制器和微程序控制器的特点各是什么？</strong><ul><li>硬连线路控制器的优点是<strong>速度快</strong>，<strong>适合于实现简单或规整的指令系统</strong>。但是，它是一个多输入/多输出的巨大逻辑网络。对于复杂的指令系统来说，其<strong>结构庞杂</strong>，<strong>实现困难</strong>，<strong>修改、维护不易</strong>，<strong>灵活性差</strong>。</li><li>微程序控制器的特点是具有<strong>规整性</strong>、<strong>可维护性</strong>和<strong>灵活性</strong>，但<strong>速度慢</strong>。</li><li>为了结合两种方式的优点，很多出理解采用两者结合的方式来实现。</li></ul></li><li><strong>为什么 CISC 大多用微程序控制器实现，RISC 大多用硬连线控制器实现？</strong><ul><li>CISC 的<strong>指令功能复杂</strong>，<strong>寻址方式多</strong>，<strong>指令长度可变</strong>，<strong>指令格式多样</strong>。对应的硬连线控制器<strong>结构庞杂</strong>，<strong>实现困难</strong>，<strong>修改、维护不易</strong>，<strong>灵活性差</strong>。所以适合采用微程序方式来设计控制器。</li><li>RISC 的指令集中只包含程序常用的指令，具有<strong>指令数目少</strong>、<strong>指令格式规整</strong>、<strong>采用(Load/Store)型指令风格</strong>等特点。所以适合采用硬连线方式来设计控制器。</li></ul></li><li><strong>流水线方式下，一条指令的执行时间缩短还是加长了？程序执行时间是缩短了还加长了？</strong><ul><li>流水线方式会<strong>延长</strong>一条指令的执行时间，但不会缩短。原因是在一条确定的流水线的流水段个数中，是以最复杂的指令执行过程所需的流水段个数为标准设计的；在确定每个流水段宽度时也是以最复杂流水段所需的宽度来设计。此外每个流水段之间的信息缓存和传递等也会增加额外开销。</li><li>流水线方式可以<strong>缩短</strong>程序的执行时间，即大大增加指令执行的吞吐率。</li></ul></li><li><strong>具有什么特征的指令集易于实现指令流水线？</strong><ul><li><strong>指令长度应尽量一致</strong>（定长指令字和定长操作码）使得每条指令的预取及译码操作时间完全一致，<strong>便于流水线控制</strong>。</li><li><strong>指令格式尽量规整，尽量保证源寄存器的位置相同</strong>，<strong>便于规划取操作数步骤</strong>，并使得对指令进行译码的同时，可以读取寄存器操作数。</li><li><strong>采用装入/存储(Load/Store)型指令风格</strong>，<strong>便于利用执行运算步骤来进行地址计算</strong>，即将地址计算和运算指令的执行步骤规整在同一个周期。</li></ul></li><li><strong>流水线处理器中时钟周期如何确定？单条流水线处理器的 CPI 为多少？每个时钟周期一定有一条指令完成吗？为什么？</strong><ul><li>流水线的流水段个数以最复杂的指令执行过程所需的流水段个数为标准设计的；在确定每个流水段宽度时也是以最复杂流水段所需的宽度来设计。</li><li>不能。理想情况下，经过若干周期后，能在每个时钟周期内执行完一条指令，即 CPI=1 但是，当程序中出现以下情况时，流水线被破坏，因而，不能达到CPI=1。</li><li>原因：有多条指令的不同阶段都要用到同一个功能部件时，发生资源冲突（<strong>结构冒险</strong>），后面指令要延时执行；当程序的执行流程发生改变时，发生控制相关（<strong>控制冒险</strong>），原来按顺序取出的指令无效；当后面指令的操作数是前面指令的运行结果时，发生数据相关（<strong>数据冒险</strong>），后面指令要延时执行。此外，还有cache缺失、TLB缺失、异常和中断等的发生都会阻塞流水线的执行。</li></ul></li><li><strong>为什么要在各流水段之间加寄存器？各流水段寄存器的宽度是否都一样？为什么？</strong><ul><li>每两个相邻流水段之间需要设置一个流水段寄存器，用来存放前一个流水段中产生的并需要传输到其后所有流水段的信息，包括各种<strong>数据</strong>（PC、指令、立即数、运算结果、寄存器号等）和<strong>控制信号</strong>两大类信息。</li><li>每个流水段功能不同，所需传递到信息也不同，因此各流水段寄存器长度也不同。</li></ul></li><li><strong>计算机内部为何要采用层次化存储体系结构？层次化存储体系结构如何构成？</strong><ul><li>原因：每一种单独的存储器都不是又快、又大、又便宜，<strong>为了构建这种理想的存储系统</strong>，计算机采用了一种层次化的存储体系结构。</li><li>按照<strong>速度从快到慢</strong>、<strong>容量从小到大</strong>、<strong>价格从高到低</strong>的顺序，由近到远地将不同存储器设置在离 CPU 远近不同地地方，这样的顺序是寄存器-&gt;cache-&gt;主存-&gt;SSD或磁盘-&gt;光盘和磁带。</li></ul></li><li><strong>SRAM 芯片和 DRAM 芯片各有哪些特点？各自用在哪些场合？</strong><ul><li>静态随机访问存储器(Static RAM,SRAM)：靠触发器的双稳态的正负反馈电路存储信息，因而<strong>速度快</strong>，是<strong>非破坏性读出</strong>，但电路中<strong>元器件多</strong>，因而<strong>集成度小</strong>、<strong>价格贵</strong>、<strong>功耗大</strong>。<strong>适合做高速小容量的半导体存储器</strong>，如<strong>高速缓冲存储器</strong>(cache)。</li><li>动态随机访问存储器(Dynamic RAM,DRAM)：靠电容存储电荷来保存信息。<strong>集成度高</strong>、<strong>功耗小</strong>、<strong>价格相对较低</strong>，是<strong>破坏性读出</strong>，读出后需要再生，而且需要<strong>定时刷新</strong>。适合做<strong>慢速大容量的半导体存储器</strong>，如<strong>主存</strong>。</li></ul></li><li><strong>为什么在 CPU 和主存之间引入 cache 能提高 CPU 访存效率？</strong><ul><li>原因：程序执行代码和数据的存储访问具有<strong>局部性特点</strong>，包括时间局部性和空间局部性。</li><li>时间局部性指某个单元在一个很短的时间段内被重复访问的可能性很大；空间局部性指某个单元被访问后其周围单元不久也将被访问的可能性很大。</li><li>只要将刚被访问的单元及其邻近单元一起复制到cache中，那么，在最近一段时间内CPU访问的信息都可以在cache中访问到，而不需要访问慢速的主存。</li></ul></li><li><strong>什么是页表？什么是快表(TLB)？</strong><ul><li>页表：每个进程有一个页表，记录该进程的每个页存放在主存的哪个页框中，或在辅存的哪个地方。页表中一般有装入位（有效位）、修改位、使用位、实页号等。</li><li>快表：用一个特殊的 cache 来跟踪记录最近用过的页表表项。因为页表表项主要用于地址转换，所以把这种特殊的 cache 称为转换后援缓冲器(Translation-Lookaside Buffer,TLB)。因为在TLB中查找页表表项速度很快，所以TLB也被称为快表。</li></ul></li><li><strong>什么是 I/O 接口？I/O 接口的基本功能有哪些？按数据传送方式分有哪两种接口类型？</strong><ul><li>I/O 接口是用于<strong>连接主机和外设</strong>并通过接受主机命令来<strong>对外设进行控制的部件</strong>的总称。</li><li>功能：<ul><li><strong>数据缓冲</strong>：匹配主机和外设工作速度；</li><li><strong>错误或状态检测</strong>：是否完成、是否出错；</li><li><strong>控制和定时</strong>：协调内部资源和外设间动作的先后关系；</li><li><strong>数据格式转换</strong>：串/并行转换，数据宽度转换等。</li></ul></li><li>按数据传送方式分有：并行接口、串行接口。</li></ul></li><li><strong>CPU 如何进行设备的寻址？I/O 端口的编址方式有哪两种？各有何特点？</strong><ul><li>CPU 通过地址总线进行设备寻址。</li><li>I/O 端口一般有两种编址方式：独立编址和统一编址。</li><li><strong>独立编址</strong>：<strong>将 I/O 端口和主存单元分别编号</strong>，不占用主存单元的地址空间，因而主存单元和 I/O 端口可能会有相同的编号，但地址位数大多不同，主存单元多，地址空间大，因而地址位数多；I/O 端口少，地址空间小，因而地址位数少。因为可能有相同的编号，指令中<strong>无法靠地址来区分要访问的是主存单元还是 I/O 端口</strong>，所以，需要有和访存指令不同的操作码，因此， <strong>需要设计专门的I/O指令</strong>。</li><li><strong>统一编址</strong>：<strong>I/O 端口和主存单元统一编址</strong>，所以也称为存储器映射I/O (memory-mapped I/O)方式。一个地址空间分成了两部分，各在不同的地址段中，但地址的位数是相同的，<strong>可根据地址范围的不同来区分访问的是主存单元还是 I/O 端口</strong>，所以<strong>无需专门的输入输出指令</strong>。</li></ul></li><li><strong>什么是程序查询 I/O 方式？说明其工作原理。</strong><ul><li>CPU 通过执行查询程序来完成对外设的控制，实现和外设的数据传送。</li><li>在查询程序中，CPU首先通过读取状态端口中的状态信息，了解接口是否已“就绪”(或“完成”)，若是，就通过数据端口进行新的数据传送，并查询外设是否空闲，在外设空闲的情况下，通过发送控制信息到命令端口，然后由接口发“启动”命令送外设；如果接口没有就绪，或外设不空闲，则CPU继续查询，以等待接口就绪或外设空闲。</li><li>所有信息(包括控制、数据、状态)的交换由查询程序中的I/O指令完成。</li></ul></li><li><strong>什么是中断 I/O 方式？说明其工作原理。</strong><ul><li>程序中断I/O方式下，CPU启动外设后，就转到另外一个程序执行，此时，外设和 CPU 并行工作。</li><li>一旦外设完成任务，便发中断请求给CPU，告知CPU此次任务已经完成。此时，CPU暂停正在执行的程序，转到一个中断服务程序进行中断处理，在中断处理过程中，进行外设下一步的准备工作(例如，传送下一个要打印的数据，或者取走键盘数据或采样数据，为下次输入腾空数据缓冲寄存器，等等)，最后启动外设，并回到原程序继续执行。此时，CPU和外设又能并行工作。</li></ul></li><li><strong>为什么在保护现场和恢复现场的过程中,CPU 必须关中断？</strong><ul><li>在保护断点和现场以及恢复断点和现场过程中，如果又有新的中断被响应，则原被保护的断点或现场就会被破坏。</li><li>因而，需要一种机制能保证断点和现场的保护及恢复过程不被新的中断请求打断。</li></ul></li><li><strong>DMA 方式能够提高成批数据交换效率的主要原因何在？</strong><ul><li>DMA 方式下，CPU 只要在最初的 DMA 控制器初始化和最后处理“DMA 结束”中断时介入，而在整个一块数据传送过程中都不需要 CPU 参与，因而 CPU 用于 I/O 的开销非常小。</li></ul></li><li><strong>CPU 响应 DMA 请求和响应中断请求有什么区别？为什么通常使 DMA 请求具有高于中断请求的优先权？</strong><ul><li>DMA 方式下，向 CPU 请求的是<strong>总线控制权</strong>，要求 CPU 让出总线控制权给 DMA 控制器，由DMA控制器来控制总线完成主存和外设之间的数据交换。因此，CPU只要用完总线后就可以响应请求，释放总线，让出总线控制权。CPU 总是在一次总线事务完成后响应，因此，<strong>DMA 响应时间应该少于一个总线周期</strong>。</li><li>而中断方式下请求的是 <strong>CPU 时间</strong>，要求 CPU 中止正在执行的程序，<strong>转到中断服务程序去执行</strong>，通过执行中断服务程序，对中断事件进行相应的处理。CPU 总是要等到一条指令执行结束后，才去查询有无中断请求，所以<strong>响应时间少于一个指令周期的时间</strong>。</li><li>原因：<strong>DMA请求得不到及时响应，I/O传输数据可能会丢失。</strong></li></ul></li><li><strong>如何解决结构冒险？</strong><ul><li>通过以下两种规整流水线结构的方式可以解决部分结构冒险：<ul><li>规定每个功能部件在每条指令执行过程中只能被使用一次。例如，每条指令只能用一次“寄存器写口”。</li><li>每个功能部件只能在一个特定的流水段内被使用。例如，“寄存器写口”只能在第5个流水阶段被使用。</li><li>另外，指令和数据分别存放在不同的存储器中，使得同时访问指令和数据不会引起存储器资源的结构冒险。</li></ul></li></ul></li><li><strong>什么是控制冒险？哪些情况下会发生控制冒险？</strong><ul><li>正常情况下PC的值按顺序增量，但在执行转移类指令或发生异常和中断时，PC 的值由指令或异常/中断处理部件给岀。</li><li>流水线方式下，如果在取下一条指令时，正确的下条指令地址还没有送到 PC 中，那么所取的下条指令就不是正确的，因而发生控制冒险。</li><li>可以看出，如果确定下条指令地址所用时间较长，就会因为来不及在一个时钟周期内得到正确的 PC 值而发生控制冒险。通常，转移类指令会发生控制冒险，例如，分支指令（条件转移指令）要根据条件测试结果来确定 PC 的值，因而会发生控制冒险；返回指令需要从存储器中读取返回地址送PC，因而也会发生控制冒险。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对阶&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;浮点数加/减运算时，在尾数相加/减之前所进行的操作称为对阶。&lt;/li&gt;
&lt;li&gt;对阶时，需要比较两个阶的大小。阶小的那个数的尾数右移（小数点左移），阶码增加。右移一次，阶码加1，直到两数的阶码相等为止。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机组成与系统结构" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>运输层</title>
    <link href="http://tianyuzhou.github.io/2020/12/15/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://tianyuzhou.github.io/2020/12/15/%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2020-12-15T12:13:05.000Z</published>
    <updated>2021-02-17T13:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h3><ul><li><p>进程之间的通信</p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于<strong>面向通信部分的最高层</strong>，同时也是<strong>用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。<span id="more"></span></li></ul></li><li><p>运输层的作用</p><ul><li>“<strong>逻辑通信</strong>”的意思是“好像是这样通信，但事实上并非真的这样通信”。</li><li><strong>从IP层来说，通信的两端是两台主机</strong>。但“两台主机之间的通信”这种说法还不够清楚。</li><li>严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。</li><li><strong>从运输层的角度看，通信的真正端点并不是主机而是主机中的进程</strong>。也就是说，端到端的通信是应用进程之间的通信。<br><img src="https://pic.zty.plus/%E8%BF%90%E8%BE%93%E5%B1%82%E4%BD%9C%E7%94%A8.png" alt="运输层作用"></li><li>在一台主机中经常有<strong>多个应用进程</strong>同时分别和另一台主机中的多个应用进程通信。</li><li>这表明运输层有一个很重要的功能——<strong>复用</strong> (multiplexing)和<strong>分用</strong> (demultiplexing)。</li><li>根据应用程序的不同需求，运输层需要有两种不同的运输协议，即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong>。<br><img src="https://pic.zty.plus/%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%8D%E7%94%A8%E5%92%8C%E5%88%86%E7%94%A8.png" alt="基于端口的复用和分用"></li><li>屏蔽作用<ul><li>运输层向高层用户<strong>屏蔽</strong>了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条<strong>端到端的逻辑通信信道</strong>。</li><li>但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。</li></ul></li></ul></li><li>运输层的两个主要协议<ul><li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)</li><li><strong>传输控制协议 TCP</strong> (Transmission Control)<br><img src="https://pic.zty.plus/TCP%26UDP.png" alt="TCP&amp;UDP"></li><li>当运输层采用面向连接的 <strong>TCP 协议时</strong>，尽管下面的网络是不可靠的（只提供尽最大努力服务），但<strong>这种逻辑通信信道就相当于一条<em>全双工的可靠信道</em></strong>。</li><li>当运输层采用无连接的 <strong>UDP 协议时</strong>，<strong>这种逻辑通信信道是一条<em>不可靠信道</em></strong>。<br><img src="https://pic.zty.plus/UPD-TCP%E5%8C%BA%E5%88%AB.png" alt="TCP和UDP区别"></li></ul></li><li>运输层的端口<ul><li>运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。</li><li>解决这个问题的方法就是在运输层使用<strong>协议端口号</strong> (protocol port number)，或通常简称为<strong>端口</strong> (port)。</li><li>软件端口与硬件端口<ul><li>在协议栈层间的抽象的协议端口是<strong>软件端口</strong>。</li><li>路由器或交换机上的端口是<strong>硬件端口</strong>。</li><li><strong>硬件端口</strong>是不同<strong>硬件设备</strong>进行交互的<strong>接口</strong>，而<strong>软件端口</strong>是应用层的各种<strong>协议进程</strong>与<strong>运输实体</strong>进行层间交互的一种<strong>地址</strong>。</li></ul></li><li><img src="https://pic.zty.plus/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3.png" alt="常用端口"></li></ul></li></ul><h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h3><ul><li>UDP概述<ul><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能：<ul><li>复用和分用的功能</li><li>差错检测的功能</li></ul></li><li>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</li></ul></li><li>UDP主要特点<ul><li><strong>UDP 是无连接的</strong>，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。</li><li><strong>UDP 使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li><strong>UDP 是面向报文的</strong>。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。</li><li><strong>UDP 没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。</li><li><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li><strong>UDP 的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li></ul></li><li>UDP 的首部格式<ul><li>用户数据报 UDP 有<strong>两个字段</strong>：<strong>数据字段</strong>和<strong>首部字段</strong>。首部字段很简单，只有 <strong>8 个字节</strong>。<br><img src="https://pic.zty.plus/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="UDP数据报格式"></li><li>当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。<br><img src="https://pic.zty.plus/UDP%E7%AB%AF%E5%8F%A3%E5%88%86%E7%94%A8.png" alt="UDP端口分用"></li><li>请注意，虽然在 UDP 之间的<strong>通信要用到其端口号</strong>，但由于 UDP 的通信是无连接的，因此<strong>不需要使用套接字</strong>。</li></ul></li></ul><h3 id="传输控制协议-TCP-概述"><a href="#传输控制协议-TCP-概述" class="headerlink" title="传输控制协议 TCP 概述"></a>传输控制协议 TCP 概述</h3><ul><li><p>TCP 最主要的特点</p><ul><li>TCP 是<strong>面向连接</strong>的运输层协议。</li><li>每一条 TCP 连接<strong>只能有两个端点</strong> (endpoint)，每一条 TCP 连接<strong>只能是点对点</strong>的（一对一）。</li><li>TCP 提供<strong>可靠交付</strong>的服务。</li><li>TCP 提供<strong>全双工</strong>通信。</li><li><strong>面向字节流</strong><ul><li>TCP 中的“流”(stream)指的是流入或流出进程的<strong>字节序列</strong>。</li><li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。<ul><li>TCP <strong>不保证</strong>接收方应用程序所收到的数据块和发送方应用程序所发出的<strong>数据块具有对应大小的关系</strong>。</li><li>但接收方应用程序收到的字节流必须和发送方应用程序发出的<strong>字节流完全一样</strong>。</li></ul></li></ul></li></ul></li><li><p>注意</p><ul><li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的<strong>窗口值</strong>和<strong>当前网络拥塞的程度</strong>来决定一个报文段应包含多少个字节（UDP 发送的报文长度是<strong>应用进程给出</strong>的）。</li><li>TCP 可把太长的数据块划分短一些再传送。</li><li>TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul></li><li>TCP 的连接<ul><li>TCP 把连接作为<strong>最基本的抽象</strong>。</li><li>每一条 TCP 连接有<strong>两个端点</strong>。</li><li>TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口。</li><li><strong>TCP 连接的端点叫做套接字 (socket) 或插口</strong>。</li><li><strong>端口号拼接到 (contatenated with) IP 地址即构成了套接字</strong>。</li></ul></li></ul><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><ul><li>理想的传输条件有以下两个特点：<ul><li><strong>传输信道不产生差错</strong>。</li><li>不管发送方以多快的速度发送数据，接收方总是<strong>来得及处理收到的数据</strong>。</li></ul></li><li>在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。</li><li><strong>然而实际的网络都不具备以上两个理想条件</strong>。必须使用一些<strong>可靠传输协议</strong>，在不可靠的传输信道实现可靠传输。</li><li>停止等待协议<ul><li>停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</li><li>全双工通信的双方既是发送方也是接收方</li><li>出现差错解决方法：<strong>超时重传</strong><ul><li>A 为每一个已发送的分组都设置了一个超时计时器。</li><li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</li><li><img src="https://pic.zty.plus/TCP%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99.png" alt="TCP出现差错"></li></ul></li><li>确认丢失和确认迟到<ul><li><img src="https://pic.zty.plus/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.png" alt="确认丢失和确认迟到"></li></ul></li><li>注意<ul><li>在发送完一个分组后，必须<strong>暂时保留</strong>已发送的分组的副本，以备重发。</li><li><strong>分组和确认分组都必须进行编号</strong>。</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间<strong>更长一些</strong>。</li></ul></li><li>自动重传请求 ARQ<ul><li><strong>通常 A 最终总是可以收到对所有发出的分组的确认</strong>。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</li><li><strong>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信</strong>。</li><li>像上述的这种可靠传输协议常称为自动重传请求 ARQ  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，<strong>接收方不需要请求发送方重传某个出错的分组</strong>。</li></ul></li><li>信道利用率<ul><li>停止等待协议的优点是简单，缺点是信道利用率太低。<br><img src="https://pic.zty.plus/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="停止等待-信道利用率"></li><li>流水线传输<ul><li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。</li><li><strong>流水线传输</strong>就是发送方可<strong>连续发送多个分组</strong>，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。</li><li>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。<br><img src="https://pic.zty.plus/%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="流水线传输-信道利用率"></li></ul></li></ul></li></ul></li><li>连续ARQ协议<ul><li>滑动窗口协议比较复杂，是 TCP 协议的精髓所在。</li><li>发送方维持的发送窗口，它的意义是：<strong>位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。</strong>这样，信道利用率就提高了。</li><li>连续 ARQ 协议规定，<strong>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</strong><br><img src="https://pic.zty.plus/%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.png" alt="连续ARQ协议"></li><li>累计确认<ul><li>接收方一般采用<strong>累积确认</strong>的方式。即不必对收到的分组逐个发送确认，而是<strong>对<em>按序到达</em>的最后一个分组发送确认</strong>，这样就表示：<strong>到这个分组为止的所有分组都已正确收到了</strong>。</li><li>优点：容易实现，即使<strong>确认丢失</strong>也不必重传。</li><li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</li></ul></li><li>Go-back-N（回退 N）<ul><li>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好<strong>把后面的三个分组都再重传一次</strong>。</li><li>这就叫做 Go-back-N（回退 N），表示<strong>需要再退回来重传已发送过的 N 个分组</strong>。</li><li>可见当<strong>通信线路质量不好时，连续 ARQ 协议会带来负面的影响</strong>。</li></ul></li><li>TCP 可靠通信的具体实现<ul><li>TCP 连接的每一端都必须设有<strong>两个窗口</strong>——一个<strong>发送窗口</strong>和一个<strong>接收窗口</strong>。</li><li>TCP 的可靠传输机制用<strong>字节的序号</strong>进行控制。TCP 所有的确认都是<strong>基于序号而不是基于报文段</strong>。</li><li>TCP 两端的四个窗口经常处于<strong>动态变化</strong>之中。</li><li>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法<strong>估算较为合理的重传时间</strong>。</li></ul></li></ul></li></ul><h3 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h3><ul><li>TCP 虽然是<strong>面向字节流</strong>的，但 TCP <strong>传送的数据单元却是报文段</strong>。</li><li>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。</li><li>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。<br><img src="https://pic.zty.plus/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP 报文段的首部格式"></li></ul><h3 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h3><ul><li>以字节为单位的滑动窗口<ul><li>TCP 的滑动窗口是<strong>以字节为单位</strong>的。</li><li>现假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节，而确认号是 31（这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。</li><li>根据这两个数据，A 就构造出自己的发送窗口。<br><img src="https://pic.zty.plus/TCP%E7%AA%97%E5%8F%A3.png" alt="TCP窗口"></li><li>根据 B 给出的窗口值，A 构造出自己的发送窗口。</li><li>发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。</li><li>发送窗口里面的序号表示允许发送的序号。</li><li>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。</li><li><img src="https://pic.zty.plus/TCP%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A81.png" alt="TCP窗口移动1"></li><li><img src="https://pic.zty.plus/TCP%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A82.png" alt="TCP窗口移动2"></li><li><img src="https://pic.zty.plus/TCP%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A83.png" alt="TCP窗口移动3"></li><li>需要强调三点<ul><li>第一，A 的<strong>发送窗口</strong>并<strong>不总是和</strong> B 的<strong>接收窗口一样大</strong>（因为有一定的时间滞后）。</li><li>第二，<strong>TCP 标准没有规定对不按序到达的数据应如何处理</strong>。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>第三，TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。</li></ul></li></ul></li><li>选择确认 SACK<ul><li>问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？</li><li>答案是可以的。<strong>选择确认 SACK</strong> (Selective ACK) 就是一种可行的处理方法。</li><li>接收方收到了和前面的字节流不连续的两个字节块。</li><li>如果这些字节的序号都在接收窗口之内，那么接收方就<strong>先收下</strong>这些数据，但要<strong>把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据</strong>。</li></ul></li></ul><h3 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h3><ul><li>利用滑动窗口实现流量控制<ul><li>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li><li><strong>流量控制</strong> (flow control) 就是让发送方的发送速率不要太快，既要<strong>让接收方来得及接收，也不要使网络发生拥塞</strong>。</li><li>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。<br><img src="https://pic.zty.plus/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="滑动窗口-流量控制"></li><li><strong>可能发生死锁</strong><ul><li>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。</li><li>但这个报文段在传送过程中<strong>丢失</strong>了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。</li><li>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</li><li>为了解决这个问题，TCP 为每一个连接设有一个<strong>持续计时器</strong> (persistence timer)。</li><li><strong>持续计时器</strong><ul><li>TCP 为每一个连接设有一个持续计时器  (persistence timer) 。</li><li>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。</li><li>若持续计时器设置的时间到期，就发送一个<strong>零窗口探测报文段</strong>（<strong>仅携带 1 字节的数据</strong>），而对方就在确认这个探测报文段时给出了现在的窗口值。</li><li>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</li><li>若窗口不是零，则死锁的僵局就可以打破了。</li></ul></li></ul></li></ul></li></ul><h3 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h3><ul><li>拥塞控制的一般原理<ul><li>在某段时间，若对网络中某<strong>资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种现象称为<strong>拥塞</strong> (congestion)。</li><li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li><li>出现拥塞的原因：$∑对资源需求&gt;可用资源$</li><li><strong>增加资源能解决拥塞吗？</strong><ul><li><strong>不能</strong>。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还<strong>可能使网络的性能更坏</strong>。</li><li>网络拥塞往往是由许多因素引起的。例如：<ul><li>增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；</li><li>提高处理机处理的速率会会将瓶颈转移到其他地方；</li></ul></li></ul></li><li>拥塞常常趋于恶化<ul><li>如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。</li><li>但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。</li><li><strong>可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞</strong>。</li></ul></li><li>拥塞控制所起的作用<ul><li><img src="https://pic.zty.plus/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="拥塞控制所起的作用"></li></ul></li><li><strong>拥塞控制的一般原理</strong><ul><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态</strong>的（而不是静态的）<strong>问题</strong>。</li><li>当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。<strong>但分组的丢失是网络发生拥塞的<em>征兆</em>而不是原因</strong>。</li><li><strong>在许多情况下，甚至正是<em>拥塞控制本身</em>成为引起网络性能恶化甚至发生<em>死锁</em>的原因</strong>。这点应特别引起重视。</li></ul></li><li>开环控制和闭环控制<ul><li><strong>开环控制</strong>方法就是在设计网络时<strong>事先</strong>将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</li><li>闭环控制方法是基于<strong>反馈环路</strong>（<strong>事后</strong>）的概念。属于闭环控制的有以下几种措施：<ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>将拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ul></li></ul></li><li>监测网络的拥塞的指标<ul><li>主要指标有：<ul><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ul></li></ul></li><li>上述这些指标的上升都标志着拥塞的增长。</li></ul></li><li>TCP 的拥塞控制方法<ul><li>TCP 采用<strong>基于窗口的方法</strong>进行拥塞控制。该方法属于<strong>闭环控制</strong>方法。</li><li>TCP发送方维持一个<strong>拥塞窗口 CWND</strong> (Congestion Window)<ul><li>拥塞窗口的大小取决于网络的<strong>拥塞程度</strong>，并且<strong>动态地在变化</strong>。</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</li><li>所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：&lt;/br&gt;$真正的发送窗口值 = Min(公告窗口值，拥塞窗口值)$</li></ul></li><li>控制拥塞窗口的原则<ul><li><strong>只要网络没有出现拥塞，拥塞窗口就可以再增大一些</strong>，以便把更多的分组发送出去，这样就可以提高网络的利用率。</li><li><strong>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些</strong>，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</li></ul></li><li>拥塞的判断<ul><li><strong>重传定时器超时</strong><ul><li>现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络可能出现了拥塞。</li><li><strong>收到三个相同（重复）的 ACK</strong><ul><li>个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</li></ul></li></ul></li></ul></li><li>TCP拥塞控制算法<ul><li>四种（ RFC 5681）：<ul><li>慢开始 (slow-start)<ul><li>$拥塞窗口cwnd每次的增加量 = min (N,SMSS)$<ul><li>其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。</li><li>发送方的最大报文段 SMSS (Sender Maximum Segment Size)。</li><li>初始拥塞窗口 cwnd 根据SMMS设置。</li><li>慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。</li></ul></li><li>指数增长</li></ul></li><li>拥塞避免 (congestion avoidance)<ul><li>每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1。</li><li>线性增长</li></ul></li><li>快重传 (fast retransmit)<ul><li><strong>发送方只要一连收到三个重复确认</strong>，就知道接收方确实没有收到报文段，因而应当<strong>立即进行重传</strong>（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</li><li>不难看出，快重传并<strong>非取消重传计时器</strong>，而是在某些情况下可<strong>更早地重传</strong>丢失的报文段。</li></ul></li><li>快恢复 (fast recovery)<ul><li>当发送端收到<strong>连续三个重复的确认</strong>时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法。</li><li>FR (Fast Recovery) 算法：<ul><li>$慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2$；</li><li>$新拥塞窗口 cwnd = 慢开始门限 ssthresh$；</li><li>开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</li></ul></li></ul></li></ul></li><li><img src="https://pic.zty.plus/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="拥塞控制算法"></li></ul></li></ul></li></ul><h3 id="拥塞控制与流量控制的区别"><a href="#拥塞控制与流量控制的区别" class="headerlink" title="拥塞控制与流量控制的区别"></a>拥塞控制与流量控制的区别</h3><ul><li><strong>拥塞控制</strong>就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</li><li><strong>拥塞控制</strong>所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li><li><strong>拥塞控制</strong>是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li><strong>流量控制</strong>往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。</li><li><strong>流量控制</strong>所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>拥塞控制和流量控制之所以常常被弄混，是因为某些拥塞控制算法是向发送端发送控制报文，并告诉发送端，网络已出现麻烦，必须放慢发送速率。这点又和流量控制是很相似的。</li></ul><h3 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h3><ul><li>运输连接的三个阶段<ul><li>TCP 是面向连接的协议。</li><li>运输连接有三个阶段：<ul><li><strong>连接建立</strong></li><li><strong>数据传送</strong></li><li><strong>连接释放</strong></li></ul></li><li>运输连接的管理就是使运输连接的建立和释放都能正常地进行。</li></ul></li><li>TCP 的连接建立<ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li><li><img src="https://pic.zty.plus/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></li></ul></li><li>TCP 的连接释放<ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li><li><img src="https://pic.zty.plus/TCP%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="四次握手"></li><li>第一次<ul><li>数据传输结束后，通信的双方都可释放连接。</li><li>现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。</li><li>A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</li></ul></li><li>第二次<ul><li>B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。</li><li>TCP 服务器进程通知高层应用进程。</li><li>从 A 到 B 这个方向的连接就释放了，TCP 连接</li><li>处于半关闭状态。B 若发送数据，A 仍要接收。</li></ul></li><li>第三次<ul><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。</li></ul></li><li>第四次<ul><li>A 收到连接释放报文段后，必须发出确认。</li><li>在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。</li></ul></li><li>A 必须等待 2MSL 的时间<ul><li>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</li><li>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;运输层协议概述&quot;&gt;&lt;a href=&quot;#运输层协议概述&quot; class=&quot;headerlink&quot; title=&quot;运输层协议概述&quot;&gt;&lt;/a&gt;运输层协议概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程之间的通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于&lt;strong&gt;面向通信部分的最高层&lt;/strong&gt;，同时也是&lt;strong&gt;用户功能中的最低层&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，&lt;strong&gt;只有位于网络边缘部分的主机的协议栈才有运输层&lt;/strong&gt;，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://tianyuzhou.github.io/2020/12/12/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://tianyuzhou.github.io/2020/12/12/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-12-12T12:51:33.000Z</published>
    <updated>2021-02-17T13:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><ul><li>虚电路服务<ul><li><strong>面向连接</strong>，可靠通信应当由网络来保证。</li><li>端到端的差错处理和流量控制可以由网络负责，也可以由用户主机负责。<span id="more"></span></li></ul></li><li>数据报服务<ul><li>无连接，可靠通信应当由用户主机来保证。</li><li>端到端的差错处理和流量控制由用户主机负责。</li></ul></li><li><strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。</li><li>网络层不提供服务质量的承诺。<br><img src="https://pic.zty.plus/%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.png" alt="虚电路与数据报"></li></ul><h3 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h3><ul><li>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。</li><li>与 IP 协议配套使用的还有三个协议：</li><li>地址解析协议 ARP (Address Resolution Protocol)(RARP是反向地址解析协议)</li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)</li><li>网际组管理协议 IGMP (Internet Group Management Protocol)<br><img src="https://pic.zty.plus/%E7%BD%91%E9%99%85%E5%B1%82IP%E5%8D%8F%E8%AE%AE%E5%8F%8A%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.png" alt="网际层的 IP 协议及配套协议"></li></ul><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><ul><li><p>三个历史阶段</p><ul><li><strong>分类的 IP 地址</strong>：这是最基本的编址方法。</li><li><strong>子网的划分</strong>：这是对最基本的编址方法的改进。</li><li><strong>构成超网：</strong>这是比较新的<strong>无分类编址方法</strong>。</li></ul></li><li><p>分类 IP 地址<br><img src="https://pic.zty.plus/%E5%88%86%E7%B1%BBip%E5%9C%B0%E5%9D%80.png" alt="分类IP地址"></p></li><li>各类IP地址的网络号字段和主机号字段<br><img src="https://pic.zty.plus/%E5%90%84%E4%B8%AA%E5%88%86%E7%B1%BBip%E5%9C%B0%E5%9D%80.png" alt="各分类IP地址"></li><li>点分十进制记法 ：机器中存放的 IP 地址是 32 位二进制代码，我们将每 8 位为一组将每 8 位的二进制数转换为十进制数，采用点分十进制记法，进一步提高可读性。</li><li><p>一般不使用的特殊的 IP 地址<br><img src="https://pic.zty.plus/%E7%89%B9%E6%AE%8AIP.png" alt="特殊IP"></p></li><li><p>IP 地址与硬件地址</p><ul><li><strong>硬件地址</strong>（或物理地址）是数据链路层和物理层使用的地址。</li><li><strong>IP 地址</strong>是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。</li></ul></li><li><p>地址解析协议 ARP</p><ul><li>通信时使用了两个地址：<ul><li>IP 地址（网络层地址）</li><li>MAC 地址（数据链路层地址）</li></ul></li><li>ARP 作用：<ul><li>从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</li></ul></li><li>要点：<ul><li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</li><li>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br><img src="https://pic.zty.plus/ARP.png" alt="ARP"></li><li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 <strong>ARP 高速缓存</strong>中查看有无主机 B 的 IP 地址。<ul><li><strong>如有</strong>，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</li><li><strong>如没有</strong>， ARP 进程在本局域网上<strong>广播发送</strong>一个 <strong>ARP 请求分组</strong>。收到 <strong>ARP 响应分组</strong>后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</li></ul></li><li><strong>ARP请求分组</strong>：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址。</li><li><strong>本地广播 ARP 请求</strong>（路由器不转发ARP请求）。</li><li><strong>ARP 响应分组</strong>：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。</li><li><strong>ARP 分组封装在物理网络的帧中传输</strong>。</li></ul></li><li>ARP 高速缓存的作用：<ul><li><strong>存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量。</strong></li></ul></li><li>注意的问题：<ul><li>ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。</li><li>如果所要找的主机和源主机不在同一个局域网上，就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</li></ul></li></ul></li><li><p>IP 数据报的格式</p><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li>首部的前一部分是<strong>固定长度</strong>，共<strong>20字节</strong>，是所有 IP 数据报必须具有的。</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。<br><img src="https://pic.zty.plus/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.PNG" alt="IP数据报"></li><li>可变部分选项字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。</li><li>路由表：<ul><li>路由表没有给分组指明到某个网络的完整路径。</li><li>路由表指出，到<strong>某个网络</strong>应当先到某个路由器（即<strong>下一跳路由器</strong>）。</li></ul></li></ul></li></ul><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><ul><li><p>划分子网 （重要）</p><ul><li>划分原因：<ul><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li></ul></li><li>从两级 IP 地址到三级 IP 地址，IP 地址中又增加了一个<strong>子网号字段</strong>，使两级的 IP 地址变成为三级的 IP 地址。</li><li>划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而<strong>不改变 IP 地址原来的网络号 net-id</strong>。<br><img src="https://pic.zty.plus/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.PNG" alt="划分子网"></li><li>优点：<ul><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ul></li><li>划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。</li></ul></li><li><p>子网掩码（重要）</p><ul><li>设置原因：<ul><li>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。</li><li>使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。</li></ul></li><li>规则：<ul><li>子网掩码长度 ＝ 32 位</li><li>某位 ＝ 1：IP地址中的对应位为网络号和子网号</li><li>某位 ＝ 0：IP地址中的对应位为主机号</li></ul></li><li>子网掩码是一个重要属性：<ul><li><strong>子网掩码是一个网络或一个子网的重要属性</strong>。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</li></ul></li></ul></li><li><p>子网划分方法</p><ul><li>有<strong>固定长度子网</strong>和<strong>变长子网</strong>两种子网划分方法。</li><li>在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了。<ul><li><a href="https://blog.csdn.net/qq_34228570/article/details/80245031">子网划分为什么全0全1子网号不能使用？</a></li></ul></li><li>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。<br><img src="https://pic.zty.plus/B%E7%B1%BB%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.PNG" alt="B类子网划分"></li></ul></li><li><p>无分类编址 CIDR</p><ul><li>网络前缀：<ul><li>为了解决：<ul><li>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</li><li>互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li><li>整个 IPv4 的地址空间最终将全部耗尽。</li></ul></li></ul></li><li>IP 编址问题的演进<ul><li>使用变长子网掩码 VLSM (Variable Length Subnet   Mask)可进一步提高 IP 地址资源的利用率。</li><li>在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是<strong>无分类域间路由选择 CIDR (Classless Inter-Domain Routing)</strong>。</li></ul></li><li>CIDR 最主要的特点<ul><li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li><li>CIDR使用各种长度的<strong>网络前缀</strong>(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。<br><img src="https://pic.zty.plus/%E6%97%A0%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80.PNG" alt="无分类的两级编址"></li><li>CIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如：220.78.168.0/24</li></ul></li><li>CIDR 地址块<ul><li>CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</li><li>128.14.32.0/20 表示的地址块共有$2^{12}$ 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。<ul><li>这个地址块的起始地址是 128.14.32.0。</li><li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</li><li>128.14.32.0/20 地址块的最小地址：128.14.32.0</li><li>128.14.32.0/20 地址块的最大地址：128.14.47.255</li><li>全 0 和全 1 的主机号地址一般不使用。</li></ul></li></ul></li><li>路由聚合 (route aggregation)<ul><li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为<strong>路由聚合</strong>，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</li><li>路由聚合有利于<strong>减少路由器之间的路由选择信息的交换</strong>，从而提高了整个互联网的性能。</li><li><strong>路由聚合也称为构成超网 (supernetting)</strong>。</li><li>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</li><li>对于 /20 地址块，它的掩码是 20 个连续的 1。斜线记法中的数字就是掩码中1的个数。<br><img src="https://pic.zty.plus/%E5%B8%B8%E7%94%A8CIDR.PNG" alt="常用CIDR地址块"></li></ul></li><li>构成超网<ul><li>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C  类地址。</li><li>这些 C 类地址合起来就构成了超网。</li><li><strong>CIDR 地址块中的地址数一定是 2 的整数次幂</strong>。</li><li>网络前缀越短，其地址块所包含的地址数就越多。而<strong>在三级结构的IP地址中，划分子网是使网络前缀变长</strong>。</li><li>CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。</li></ul></li></ul></li><li><p>网际控制报文协议 ICMP</p><ul><li>使用原因：<ul><li>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</li><li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。<br><img src="https://pic.zty.plus/ICMP.PNG" alt="ICMP报文格式"></li></ul></li><li>ICMP 报文的种类<ul><li>ICMP 报文的种类有两种，即 ICMP <strong>差错报告报文</strong>和 ICMP <strong>询问报文</strong>。</li><li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型、代码和检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。</li><li>ICMP 差错报文：<ul><li>终点不可达</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）(Redirect)</li></ul></li><li>不应发送 ICMP 差错报告报文的几种情况<ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ul></li><li>ICMP 询问报文：<ul><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li></ul></li></ul></li><li>ICMP 的应用举例<ul><li>PING (Packet InterNet Groper-因特网包探索器)<ul><li><strong>PING 用来测试两个主机之间的连通性。</strong></li><li>PING 使用了 ICMP <strong>回送请求与回送回答报文</strong>。</li><li>PING 是<strong>应用层直接使用</strong>网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。</li></ul></li><li>Traceroute 的应用举例<ul><li>在 Windows 操作系统中这个命令是 tracert。</li><li>用来跟踪一个分组从源点到终点的路径。</li><li>它利用 IP 数据报中的 <strong>TTL 字段</strong>和 ICMP <strong>时间超过差错报告报文</strong>实现对从源点到终点的路径的跟踪。</li></ul></li></ul></li></ul></li><li><p>互联网的路由选择协议</p><ul><li>自治系统 AS(Autonomous System)<ul><li><strong>自治系统 AS 的定义</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 <strong>AS 内的路由</strong>，同时还使用一种 <strong>AS 之间</strong>的路由选择协议用以确定分组在 AS 之间的路由。</li><li>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但<strong>重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。</strong></li></ul></li><li>互联网有两大类路由选择协议<ul><li><strong>内部网关协议 IGP</strong> (Interior Gateway Protocol)<ul><li>在一个自治系统内部使用的路由选择协议。</li><li>目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li></ul></li><li><strong>外部网关协议 EGP</strong> (External Gateway Protocol)<ul><li>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。</li><li>在外部网关协议中目前使用最多的是 BGP-4。</li></ul></li><li>自治系统之间的路由选择也叫做<strong>域间路由选择</strong> (interdomain routing)</li><li>在自治系统内部的路由选择叫做<strong>域内路由选择</strong> (intradomain routing)</li><li>内部网关协议 IGP：具体的协议有多种，如 RIP 和 OSPF 等。</li><li>外部网关协议 EGP：目前使用的协议就是 BGP。<br><img src="https://pic.zty.plus/%E5%86%85%E5%A4%96%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE.PNG" alt="网关协议"></li></ul></li><li>内部网关协议 RIP<ul><li>工作原理<ul><li>路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。</li><li>RIP 是一种<strong>分布式的、基于距离向量的路由选择协议</strong>。</li><li>RIP 协议要求网络中的<strong>每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</strong>。</li></ul></li><li>关于距离（跳数）：<ul><li>RIP 认为一个好的路由就是它通过的路由器的数目少，即“<strong>距离短</strong>”。</li><li><strong>RIP 允许一条路径最多只能包含 15 个路由器。</strong></li><li><strong>“距离”的最大值为 16 时即相当于不可达</strong>。可见 RIP 只适用于小型互联网。</li><li><strong>RIP 不能在两个网络之间同时使用多条路由</strong>。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</li></ul></li></ul></li><li>RIP 协议特点<ul><li>仅和<strong>相邻路由器</strong>交换信息。</li><li>交换的信息是当前本路由器所知道的<strong>全部信息，即自己的路由表</strong>。</li><li>按<strong>固定的时间间隔交换路由信息</strong>，例如，<strong>每隔 30 秒</strong>。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li><li><strong>好消息传播得快，坏消息传播得慢</strong>。RIP 存在的一个问题：当网络出现故障时，要经过比较长的时间(例如数分钟) 才能将此信息传送到所有的路由器。</li></ul></li><li>RIP 协议的优缺点<ul><li>优点：<ul><li><strong>实现简单，开销较小</strong>。</li></ul></li><li>缺点：<ul><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul></li></ul></li><li>内部网关协议 OSPF<ul><li><strong>开放最短路径优先</strong> OSPF (Open Shortest Path First)是为克服 RIP 的缺点在 1989 年开发出来的。</li><li><strong>OSPF 的原理很简单，但实现起来却较复杂</strong>。</li></ul></li><li>OSPF 协议的基本特点<ul><li><strong>开放</strong>表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。</li><li><strong>最短路径优先</strong>是因为使用了 Dijkstra 提出的最短路径算法 SPF</li><li>采用<strong>分布式的链路状态协议</strong> (link state protocol)。</li><li><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</li></ul></li><li>三个要点<ul><li>向<strong>本自治系统中所有路由器</strong>发送信息，这里使用的方法是<strong>洪泛法</strong>。</li><li>发送的信息就是与本路由器<strong>相邻的所有路由器的<em>链路状态</em></strong>，但这只是路由器所知道的部分信息。<ul><li>“链路状态”就是说明本路由器都<strong>和哪些路由器相邻</strong>，以及<strong>该链路的“度量”</strong>(metric)。</li></ul></li><li>只有当链路状态<strong>发生变化</strong>时，路由器才用洪泛法向所有路由器发送此信息。</li></ul></li><li>链路状态数据库 (link-state database)<ul><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li><li>这个数据库实际上就是<strong>全网的拓扑结构图，它在全网范围内是一致的</strong>（这称为链路状态数据库的同步）。</li><li>OSPF 的链路状态数据库能<strong>较快地进行更新</strong>，使各个路由器能及时更新其路由表。</li><li><strong>OSPF 的更新过程收敛得快是其重要优点</strong>。</li></ul></li><li>划分区域<ul><li>划分区域的<strong>好处</strong>就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就<strong>减少了整个网络上的通信量</strong>。</li><li><strong>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况</strong>。</li><li>OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做主干区域 (backbone area)。</li><li>主干区域的标识符规定为0.0.0.0。主干区域的作用是用来<strong>连通其他在下层的区域</strong>。<br><img src="https://pic.zty.plus/OSPF%20%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" alt="OSPF区域划分"></li></ul></li><li>外部网关协议 BGP<ul><li>BGP 是不同自治系统的路由器之间交换路由信息的协议。</li><li>BGP 较新版本是 2006 年 1 月发表的 BGP-4（BGP 第 4 个版本），即 RFC 4271 ~ 4278。</li><li>可以将 BGP-4 简写为 BGP。</li></ul></li><li>BGP 使用环境不同<ul><li>互联网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。<ul><li>当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。</li><li><strong>比较合理的做法是在 AS 之间交换“可达性”信息</strong>。</li></ul></li><li>自治系统之间的路由选择必须考虑有关<strong>策略</strong>。<ul><li>不同AS性能相差可能会很大，所以依据跳数做路由选择不合适。而且还要考虑有关策略，有的AS愿意让别人过，有的AS不愿意让别人过，有的AS只愿意让交钱的人过，有的AS不愿意让自己的信息从某个AS中过。</li></ul></li><li>因此，边界网关协议 BGP 只能是<strong>力求寻找一条能够到达目的网络且比较好的路由</strong>（不能兜圈子），而<strong>并非要寻找一条最佳路由</strong>。</li></ul></li><li>BGP 发言人<ul><li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ <strong>BGP 发言人</strong>” (BGP speaker) 。</li><li>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 <strong>BGP 发言人往往就是 BGP 边界路由器</strong>，<strong>但也可以不是 BGP 边界路由器</strong>。</li></ul></li><li>BGP 交换路由信息<ul><li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 <strong>TCP 连接</strong>，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</li><li>使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。</li><li>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站</strong>(neighbor)或<strong>对等站</strong>(peer) 。<br><img src="https://pic.zty.plus/BGP%E5%8F%91%E8%A8%80%E4%BA%BA.png" alt="BGP发言人"></li></ul></li><li>BGP 协议的特点<ul><li>BGP 协议交换路由信息的结点数量级是<strong>自治系统数的量级</strong>，这要比这些自治系统中的网络数少很多。</li><li>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。</li><li>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</li><li>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但<strong>以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处</strong>。</li></ul></li><li>路由器的构成<ul><li>路由器是一种典型的网络层设备。</li><li>路由器是互联网中的关键设备。</li><li>路由器的主要作用是：<ul><li>连通不同的网络。</li><li>选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来</li></ul></li></ul></li><li>典型的路由器的结构<ul><li>整个的路由器结构可划分为两大部分：<ul><li>路由选择部分</li><li>分组转发部分</li></ul></li><li><strong>路由选择部分</strong><ul><li>也叫做控制部分，其核心构件是路由选择处理机。</li><li>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</li></ul></li><li><strong>分组转发部分</strong>由三部分组成：<ul><li><strong>交换结构</strong> (switching fabric)：又称为交换组织，其作用是根据<strong>转发表</strong> (forwarding table) 对分组进行处理。</li><li>一组输入端口</li><li>一组输出端口（请注意：这里的端口就是硬件接口）</li></ul></li></ul></li><li>“转发”和“路由选择”的区别<ul><li>“转发”(forwarding) 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</li><li>“路由选择”(routing) 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。</li><li>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。</li><li>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。</li></ul></li><li>IPv6<ul><li>解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP，即 IPv6。</li></ul></li><li>IPv6 的基本首部<ul><li>IPv6 仍支持<strong>无连接的传送</strong>，但将协议数据单元 PDU 称为<strong>分组</strong>。为方便起见，本书仍采用数据报这一名词。</li><li>所引进的主要变化如下：</li><li><strong>更大的地址空间</strong>。IPv6 将地址从 IPv4 的 32 位 增大到了 <strong>128 位</strong>。</li><li><strong>扩展的地址层次结构</strong>。</li><li><strong>灵活的首部格式</strong>。 IPv6 定义了许多可选的扩展首部。</li><li><strong>改进的选项</strong>。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。</li><li><strong>允许协议继续扩充</strong>。</li><li><strong>支持即插即用（即自动配置）</strong>。因此 IPv6 <strong>不需要使用 DHCP</strong>。</li><li><strong>支持资源的预分配</strong>。IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。</li><li><strong>IPv6 首部改为 8 字节对齐</strong>。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。</li></ul></li><li>IPv4 向 IPv6 过渡<ul><li>两种向 IPv6 过渡的策略：<ul><li>使用双协议栈<ul><li>协议栈 (dual stack) 是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）<strong>装有两个协议栈，一个 IPv4 和一个 IPv6</strong>。</li><li>根据 DNS 返回的地址类型可以确定使用 IPv4 地址还是 IPv6 地址。</li></ul></li><li>使用隧道技术<ul><li>在 IPv6 数据报要进入 IPv4 网络时，<strong>把 IPv6 数据报封装成为 IPv4 数据报</strong>，整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。</li><li>当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的 IPv6 协议栈。</li></ul></li></ul></li></ul></li><li>虚拟专用网 VPN和网络地址转换 NAT<ul><li>虚拟专用网 VPN<ul><li><strong>由于 IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul></li><li>本地地址与全球地址<ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。</li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li><li><strong>解决</strong>：RFC 1918 指明了一些专用地址 (private address)。专用地址只能用作本地地址而不能用作全球地址。<strong>在互联网中的所有路由器，对目的地址是专用地址的数据报<em>一律不进行转发</em></strong>。<br><img src="https://pic.zty.plus/%E4%B8%93%E7%94%A8ip.png" alt="专用IP"><br><em>采用这样的专用 IP 地址的互连网络称为<strong>专用互联网</strong>或<strong>本地互联网</strong>，或更简单些，就叫做<em>*专用网</em></em>。</li><li>因为这些专用地址仅在本机构内部使用。专用IP地址也叫做<strong>可重用地址</strong> (reusable address)。</li></ul></li><li>虚拟专用网 VPN<ul><li><strong>利用公用的互联网作为本机构各专用网之间的通信载体</strong>，这样的专用网又称为<strong>虚拟专用网VPN</strong> (Virtual Private Network)。</li><li>“<strong>专用网</strong>”是因为这种网络是为本机构的主机用于<strong>机构内部</strong>的通信，而不是用于和网络外非本机构的主机通信。</li><li>“虚拟”表示“好像是”，但实际上并不是，因为现在并<strong>没有真正使用通信专线</strong>，而VPN只是在效果上和真正的专用网一样。</li></ul></li><li>虚拟专用网 VPN 构建<ul><li>如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的<strong>数据都必须加密</strong>。</li><li>一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。<br><img src="https://pic.zty.plus/%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0VPN.png" alt="隧道技术实现VPN"></li></ul></li><li>网络地址转换 NAT<ul><li>问题：<ul><li>在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？</li></ul></li><li>解决：<ul><li>再申请一些全球 IP 地址。但这在很多情况下是不容易做到的。</li><li>采用网络地址转换 NAT。这是目前使用得最多的方法。</li></ul></li><li>网络地址转换 NAT (Network Address Translation)  方法于1994年提出。</li><li>需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 <strong>NAT路由器</strong>，<strong>它至少有一个有效的外部全球IP地址</strong>。</li><li>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上<strong>将其本地地址转换成全球 IP 地址</strong>，才能和互联网连接。<br><img src="https://pic.zty.plus/NAT%E5%8E%9F%E7%90%86.png" alt="NAT原理"></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;网络层提供的两种服务&quot;&gt;&lt;a href=&quot;#网络层提供的两种服务&quot; class=&quot;headerlink&quot; title=&quot;网络层提供的两种服务&quot;&gt;&lt;/a&gt;网络层提供的两种服务&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虚电路服务&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt;，可靠通信应当由网络来保证。&lt;/li&gt;
&lt;li&gt;端到端的差错处理和流量控制可以由网络负责，也可以由用户主机负责。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://tianyuzhou.github.io/2020/12/07/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://tianyuzhou.github.io/2020/12/07/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-12-07T12:31:53.000Z</published>
    <updated>2021-02-17T13:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>要解决的三个基本问题：<ul><li>封装成帧</li><li>透明传输</li><li>差错检测</li></ul></li><li>点对点传输协议（PPP）</li><li>广播信道（CSMA/CD）</li><li><p>以太网(MAC)</p><span id="more"></span><h3 id="数据链路层使用的信道"><a href="#数据链路层使用的信道" class="headerlink" title="数据链路层使用的信道"></a>数据链路层使用的信道</h3></li><li><p>点对点信道</p><ul><li>这种信道使用一对一的点对点通信方式。</li></ul></li><li>广播信道<ul><li>这种信道使用一对多的广播通信方式，因此过程比较复杂。</li></ul></li></ul><h3 id="使用点对点信道发的数据链路层"><a href="#使用点对点信道发的数据链路层" class="headerlink" title="使用点对点信道发的数据链路层"></a>使用点对点信道发的数据链路层</h3><h4 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h4><ul><li>链路（link）<ul><li>所谓链路就是从一个结点<strong>到相邻节点</strong>的一段物理线路（有线或无线），而中间没有任何其他的交换结点。</li></ul></li><li>数据链路（data link）<ul><li>除物理线路外，还必须有<strong>通信协议</strong>来控制这些数据的传输。若把实现这些<strong>协议的硬件和软件</strong>加到链路上，就构成了数据链路。现在最常用的方法是使用<strong>网络适配器</strong>（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了<strong>数据链路层</strong>和<strong>物理层</strong>这两层的功能。</li></ul></li><li>帧<ul><li>为了向网络层提供服务，数据链路层必须使用物理层提供的服务。</li><li>物理层，是以<strong>比特流</strong>进行传输的，这种比特流并不保证在数据传输过程中没有错误，接收到的位数量可能少于、等于或者多余发送的位数量。而且它们还可能有不同的值，这时数据链路层<strong>为了能实现有效的差错控制</strong>，就采用了一种“帧”的数据块进行分段传输。</li><li>采用帧格式传输，就必须有相应的帧同步技术，这就是数据链路层的“成帧”（也称帧同步）功能。</li></ul></li></ul><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ul><li>封装成帧（framing）<ul><li>在<strong>一段数据</strong>的前后分别<strong>添加<em>首部</em>和<em>尾部</em></strong>，这样就构成了一个帧。</li><li>确定帧的界限：<ul><li>首部和尾部的一个重要作用就是<strong>进行帧定界</strong>。当数据是由可打印的ASII码组成的文本文件时，帧定界可以使用特殊的<strong>帧定界符</strong>。</li></ul></li><li>控制字符SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一控制字符EOT（End Of Transmission）放在一帧最后，表示一帧的结束。</li><li>此外，首部和尾部还包括许多必要的控制信息，各种数据链路层协议都对帧首部和尾部的格式有明确规定。</li><li>为了提高帧的传输效率，应使帧的数据部分长度尽可能地大于首部和尾部的长度，但每一种种数据链路层协议都规定了所能传输的帧的<strong>数据部分长度上限——最大传输单元MTU</strong>（Maximum Transfer Unit）。</li></ul></li><li>透明传输<ul><li>如果数据中的某个字节的二进制码恰好和SOH 或 EOT一样，数据链路层就会错误地“找到帧地边界”。</li><li>解决方法：<ul><li>字节填充（byte stuffing）或字符填充（character stuffing）。发送端的数据链路层在数据中出现控制字符“SOH”或“EOT“的前面插入一个转义字符”ESC“（其十六进制编码是1B）。接收端的数据链路层将在数据送往网络层之前删除插入的转义字符。</li></ul></li></ul></li><li>差错检测<ul><li>在传输过程中可能会产生比特差错：1可能会变成0而0也可能变成1。在一段时间内，传输错误的比特与传输比特总数的比率称为误码率BER（Bit Error Rate）。误码率与信噪比有很大的关系。为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</li><li>循环冗余检验CRC的检错技术。</li><li>帧检测序列FCS（Frame Check Sequence）：FCS在数据后面添加上的冗余码称为帧检验序列FCS。<ul><li>需要注意的是：<ul><li>循环冗余检验CRC和帧检测序列FCS并不等同。</li><li>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码。</li><li>FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法。</li></ul></li></ul></li><li>CRC检验<ul><li>若得出的余数R=0，则判断这个帧没有差错，就接受。</li><li>若判断余数R≠0，则判断这个帧有差错，就丢弃。</li><li>CRC检验<a href="https://blog.csdn.net/weizhengbo/article/details/75040495">原理及例子</a>。</li><li>仅用循环冗余检验CRC差错检测技术<strong>只能做到无差错接受</strong>。</li><li>注意：<ul><li>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。</li><li>要做到“可靠传输”（即发送什么就收到什么）就必须再加上<strong>确认和重传机制</strong>。</li><li>应当明确，<strong>无比特差错</strong>与<strong>无传输差错</strong>是不同的概念。</li><li>在数据链路层使用CRC检验，能够实现<strong>无比特差错的传输</strong>，但这还<strong>不是可靠传输</strong>。</li><li>本章介绍的<strong>数据链路层协议都不是可靠传输的协议</strong>。</li></ul></li></ul></li></ul></li></ul><h3 id="点对点协议PPP-重点"><a href="#点对点协议PPP-重点" class="headerlink" title="点对点协议PPP(重点)"></a>点对点协议PPP(重点)</h3><ul><li>点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议PPP (Point-to-Point Protocol)。用户使用拨号电话线接入互联网时，用户计算机和ISP进行通信时所使用的数据链路层协议就是PPP协议。</li><li>PPP协议应满足的需求(特点)：<ul><li><strong>简单</strong>：这是首要的要求。</li><li><strong>封装成帧</strong>：必须规定特殊的字符作为帧定界符。</li><li><strong>透明性</strong>：必须保证数据传输的透明性。</li><li><strong>多种网络层协议</strong>：能够在同一条物理链路上同时支持多种网络层协议。</li><li><strong>多种类型链路</strong>：能够在多种类型的链路上运行。</li><li><strong>差错检测</strong>：能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li><strong>检测连接状态</strong>：能够及时自动检测出链路是否处于正常工作状态。</li><li>最大传送单元：必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。</li><li>网络层地址协商：必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li><li>数据压缩协商：必须提供一种方法来协商使用数据压缩算法。</li></ul></li><li>PPP协议不需要的功能：<ul><li>纠错、流量控制、序号、多点线路、半双工或单工链路（只支持全双工链路）。</li></ul></li><li>PPP协议有三个组成部分：<ul><li>一个将IP数据报封装到串行链路的方法。</li><li>链路控制协议LCP(Link Control Protocol)，用来建立、配置和测试数据链路的连接。</li><li>网络控制协议NCP(Network Control Protocol)，其中每一个协议支持不同的网络层协议。</li></ul></li><li>PPP协议的帧格式：<ul><li>PPP帧的首部和尾部分别为4个字段和2个字段。</li><li>标志字段F=0x7E、地址字段A只置为OxFF、控制字段C通常置为0x03。地址字段和控制字段实际上并不起作用。</li><li>PPP是面向字节的，所有的PPP帧的长度都是整数字节。<br><img src="https://pic.zty.plus/PPP%E5%8D%8F%E8%AE%AE.jpg" alt="PPP帧"></li><li>PPP有一个2个字节的协议字段：<ul><li>若为0x0021,则信息字段就是IP数据报。</li><li>若为0x8021,则信息字段是网络控制数据。</li><li>若为0XC021,则信息字段是PPP链路控制数据。</li><li>若为0XC023,则信息字段是鉴别数据。</li></ul></li></ul></li><li>透明传输问题：<ul><li>当PPP用在<strong>同步传输</strong>链路时，协议规定采用硬件来完成比特填充(和HDLC的做法一样）。</li><li>当PPP用在<strong>异步传输</strong>时，就使用一种特殊的字符填充法。将信息字段中出现的每一个0x7E字节转变成为2字节序列（0x7D,0x5E）。</li><li>若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列（0x7D,0x5D）。</li><li>若信息字段中出现ASCII码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。</li></ul></li><li>PPP协议之所以不使用序号、确认和重传机制是出于以下的考虑：<ul><li>在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。</li><li>在因特网环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列FCS字段可保证无差错接受。</li></ul></li><li>非必须让数据链路层提供可靠传输（不加入帧编号、确认和重传机制）的原因：<ul><li>现在通信线路的质量大大提高，由通信链路质量不好引起差错的概率已经大大降低。</li><li>因此，现在的互联网采用区别对待的方法：<ul><li>通信质量良好的<strong>有线</strong>传输链路，数据链路层协议不使用确认和重传机制，即不要求提供可靠传输。</li><li>通信质量较差的<strong>无线</strong>传输链路，数据链路层协议使用确认和重传机制，即向上提供可靠传输。</li><li>实践证明，这样可以<strong>提高通信效率</strong>。</li></ul></li></ul></li></ul><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><ul><li>局域网的数据链路层：<ul><li>局域网最主要的特点是：<ul><li>网络为一个单位所拥有；地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下主要优点：<ul><li>具有广播功能，从一个站点可很方便地访问全网。</li><li>局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li><li>局域网拓扑结构：<br><img src="https://pic.zty.plus/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%8B%93%E6%89%91.jpg" alt="局域网"></li><li>以太网的两个标准：</li><li>DIX Ethernet V2是世界上第一个局域网产品(以太网)的规约。</li><li>IEEE 802.3是第一个IEEE的以太网标准。</li></ul></li><li>数据链路层的两个子层：<ul><li>逻辑链路控制LLC (Logical Link Control)子层。</li><li>媒体接入控制 MAC (Medium Access Control)子层。</li><li>与接入到<strong>传输媒体有关</strong>的内容都放在<strong>MAC子层</strong>，而LLC子层则与传输媒体无关。</li><li>不管采用何种协议的局域网，对LLC子层来说都是透明的即LLC子层看不见下面的局域网。<br><img src="https://pic.zty.plus/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%B1%82.jpg" alt="数据链路层-两个子层"></li><li>实际上，由于互联网发展很快而TCP/IP体系的使用局域网只剩下DIX Ethernet V2，因此LLC的作用已经消失了，很多厂商的适配器上仅有MAC协议而没有LLC协议。</li></ul></li><li><p>适配器：</p><ul><li>网络接口板又称为通信适配器(adapter)或网络接口卡NIC (Network Interface Card),或“网卡”。</li><li>适配器的重要功能：<ul><li>进行串行（电缆或双绞线）/并行（主板上的I/O总线）转换。</li><li>对数据进行缓存（网络上的数据率与计算机上的数据率不同）。</li><li>实现以太网协议。<br><img src="https://pic.zty.plus/%E9%80%82%E9%85%8D%E5%99%A8.jpg" alt="适配器"></li></ul></li></ul></li><li><p>CSMA/CD协议：</p><ul><li>为了通信的简便，以太网（符合DIX Ethernet V2标准的局域网）采取了两种重要的措施：<ul><li>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。对发送的数据帧<strong>不进行编号，也不要求对方发回确认</strong>。这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。因此，<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠交付</strong>。</li><li>以太网发送的数据都使用曼彻斯特，曼彻斯特编码缺点是：它所占的<strong>频带宽度</strong>（这里指频率上下界差）比原始的基带信号增加了一倍。</li></ul></li><li>CSMA/CD含义：<ul><li><strong>载波监听多点接入/碰撞检测</strong>（Carrier Sense<br>Multiple Access with Collision Detection）。</li></ul></li><li><strong>多点接入</strong>表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。总线上并没有什么“载波”。因此，“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li><li><strong>碰撞检测</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</li></ul></li><li>为什么要进行碰撞检测？<ul><li>由于电磁波在总线上的<strong>传播速率是有限的</strong>，当某个站监听到总线是空闲时，也可能总线并<strong>非真正是空闲的</strong>。</li><li>A向B发出的信息，要经过一定的时间后才能传送到B。B若在A发送的信息到达B之前发送自己的帧（因为这时B的载波监听检测不到A所发送的信息），则必然要在某个时间和A发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。所以需要在发送期间进行碰撞检测，以检测冲突。</li></ul></li><li>争用期：<ul><li>电磁波在1km电缆的传播时延约为5μs（这个数字应当记住）。</li><li>最先发送数据帧的站，在发送数据帧后至多经过时间2$\tau$（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。因此，以太网的端到端往返时延2$\tau$称为<strong>争用期</strong>，或<strong>碰撞窗口</strong>。</li><li><strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。</li><li>二进制指数类型退避算法：<ul><li>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。基本退避时间取为争用期2$\tau$。</li></ul></li><li>争用期的长度：<ul><li>以太网在发送数据时，若<strong>前64字节</strong>没有发生冲突，则后续的数据就 不会发生冲突。</li></ul></li></ul></li><li>CSMA/CD协议的要点：<ul><li>准备发送。但在发送之前，必须先检测信道</li><li>检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。</li><li>检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。</li></ul></li><li><p><strong>CSMA/CD重要特性</strong>：</p><ul><li>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行<strong>双向交替通信（半双工通信）</strong>。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul></li><li><p>使用集线器的星形拓扑：</p><ul><li><strong>集线器（hub）</strong>：<ul><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器（hub）。</li><li>星形以太网10BASE-T使用无屏蔽双绞线，采用星形拓扑，通信距离稍短，每个站到集线器的距离不超过100m。</li><li>特点：<ul><li>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。使用集线器的以太网在<strong>逻辑上仍是一个总线网</strong>，各工作站<strong>使用的还是CSMA/CD协议</strong>，并共享逻辑上的总线。</li><li>集线器很像一个多接口的转发器</li><li>集线器<strong>工作在物理层</strong>，简单地转发比特，<strong>不进行碰撞检测</strong>（由各站中的<strong>适配器</strong>执行CSMA/CD协议）。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</li></ul></li></ul></li></ul></li><li><p>以太网的信道利用率：</p><ul><li>多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到100%。</li><li>在以太网中定义了参数a，它是以太网<strong>单程端到端时延$\tau$与帧的发送时间$T_0$之比</strong>：<ul><li>$a=\frac{\tau}{T_0}$</li><li>当a $\rightarrow$ 0, 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。</li><li>a越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。</li><li>也就是说，<strong>以太网的连线长度受到限制</strong>（否则$\tau$会太大）,同时<strong>以太网的帧不能太短</strong>（否则$T_0$会太小）。</li></ul></li></ul></li><li><p>以太网的MAC层（重要）：</p><ul><li>MAC层的硬件地址：在局域网中，<strong>硬件地址</strong>又称为<strong>物理地址</strong>，或<strong>MAC地址</strong>。</li><li>48位的MAC地址：<ul><li>IEEE 802标准规定MAC地址字段可采用6字（48位）或2字节（16位）这两种中的一种。（现在实际都使用48位的）</li><li>IEEE的注册管理机构RA负责向厂家分配地址字段6个字节中的<strong>前三个字节</strong>（即高位24位），称为<strong>组织唯一标识符OUI</strong>（公司标识符）。</li><li>址字段6个字节中的后三个字节（即低位24位）由厂家自行指派，称为<strong>扩展标识符</strong>，必须保证生产出的适配器没有重复地址。</li></ul></li><li>适配器检查MAC地址：<ul><li>适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</li><li>“发往本站的帧”包括以下三种帧：<ul><li>单播(unicast)帧(一对一)</li><li>广播(broadcast)帧(一对全体)</li><li>多播(multicast)帧(一对多)</li><li>所有的适配器都至少能够识别前两种帧，即能够识别单播地址和广播地址。有的适配器可用编程方法识别多播地址。</li><li>只有目的地址才能使用广播地址和多播地址。</li><li>以混杂方式(promiscuous mode)工作的以太网适配器只要“听到”有帧在以太网上传输就2都接收下来。</li></ul></li></ul></li><li>MAC帧的格式：常用的以太网MAC帧格式有两种标准：<ul><li>DIX Ethernet V2标准、IEEE的802.3标准，最常用的MAC帧是以太网V2的格式。<br><img src="https://pic.zty.plus/MAC%E5%B8%A7.JPG" alt="MAC帧"></li></ul></li><li>无效的MAC帧：<ul><li>数据字段的长度与长度字段的值不一致（IEEE 802.3第三个字段：长度/类型）；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列FCS查出有差错；</li><li>数据字段的长度不在46 ~ 1500字节之间。</li><li>有效的MAC帧长度为64〜1518字节之间。</li><li>对于检查出的无效MAC帧就简单地丢弃。以太网不负责重传丢弃的帧。</li></ul></li></ul></li></ul><h3 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h3><ul><li>在物理层扩展以太网：<ul><li>集线器扩展，增加碰撞域。</li></ul></li><li>在数据链路层扩展以太网：<ul><li>交换式集线器（以太网交换机、第二层交换机）：<ul><li>以太网交换机实质上就是一个多接口的网桥（根据MAC帧的目的地址进行转发和过滤）。</li></ul></li><li>特点：<ul><li>通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。</li><li>以太网交换机具有<strong>并行性</strong>。能同时连通多对接口，使多对主机能同时通信。相互通信的主机都是独占传输媒体，<strong>无碰撞地传输数据</strong>。</li><li>以太网交换机的接口<strong>有存储器</strong>，能在输出端口<strong>繁忙时把到来的帧进行缓存</strong>。</li><li>以太网交换机是一种<strong>即插即用</strong>设备，其内部的帧交换表(又称为地址表)是通过<strong>自学习算法</strong>自动地逐渐建立起来的。</li><li>以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li></ul></li><li>以太网交换机的优点：<ul><li>用户独享带宽，增加了总容量。</li><li>从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。</li><li>以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。</li></ul></li><li>以太网交换机的交换方式：存储转发方式、直通(cut-through)方式。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;要解决的三个基本问题：&lt;ul&gt;
&lt;li&gt;封装成帧&lt;/li&gt;
&lt;li&gt;透明传输&lt;/li&gt;
&lt;li&gt;差错检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;点对点传输协议（PPP）&lt;/li&gt;
&lt;li&gt;广播信道（CSMA/CD）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以太网(MAC)&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>物理层-对比</title>
    <link href="http://tianyuzhou.github.io/2020/12/05/%E7%89%A9%E7%90%86%E5%B1%82-%E5%AF%B9%E6%AF%94/"/>
    <id>http://tianyuzhou.github.io/2020/12/05/%E7%89%A9%E7%90%86%E5%B1%82-%E5%AF%B9%E6%AF%94/</id>
    <published>2020-12-05T03:22:31.000Z</published>
    <updated>2021-02-17T13:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul><li>离散数据x∈{0,1}</li><li><p>连续数据：x∈[0,1]</p><span id="more"></span><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3></li><li><p>离散信号</p></li><li>连续信号</li></ul><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><ul><li>信号某一方向的传输媒介，<strong>具有方向性（不可变）</strong>。</li><li>通常一条通信线路有两条信道（双向）。<strong>（信道不等于通信电路）</strong></li><li>单工（一条），半双工/全双工（两条）（区别：能否同时发送和接收）</li></ul><h3 id="两个速率"><a href="#两个速率" class="headerlink" title="两个速率"></a>两个速率</h3><ul><li>码元传输速率（波特率）：单位时间内数字通信系统所传输的<strong>码元个数</strong>（脉冲个数，信号变化次数）。（Baud）</li><li>信息传输速率（比特率）：单位时间内数字通信系统传输的<strong>二进制码元个数</strong>（比特率）。</li><li>关系：若一个码元表示k进制数（k种形态），则有：<strong>信息传输速率=码元传输速率×$\log_2(k)$</strong>（信息传输速率&gt;=码元传输速率）。</li></ul><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><ul><li>在计算机网络中：<strong>数据传输率</strong>的<strong><em>最高上限值</em></strong>，单位bps、bit/s。</li><li>在通信领域中：通信线路最高承受的信号<strong>频率</strong>与最低承受信号的<strong>频率</strong>的<strong><em>差值</em></strong>，单位Hz。</li></ul><h3 id="两个定理"><a href="#两个定理" class="headerlink" title="两个定理"></a>两个定理</h3><ul><li>奈斯定理（通信层面）：<ul><li>内容：在<strong>理想低通（无噪声，带宽有限）的信道</strong>中，极限<strong>码元</strong>的传输速率为2W（Baud），其中W为通信领域的信道带宽，单位Hz。</li><li>作用：给出了<strong>码元传输速率</strong>的限制。</li><li>结论：<ul><li>在任何信道上，码元的传输速率是有上限的，若超过此上限会出现<strong>码间串扰</strong>（码元之间的界限模糊不清）。</li><li>信道的频带越宽，就可以用更高的速率对码元进行有效传输。</li></ul></li></ul></li><li>香农定理（信息层面）：<ul><li>内容：<strong>在高斯白噪声干扰的信道</strong>中，极限数据传输速率为$W\log(1+\frac{S}{N})$，单位为bps，S/N为信噪比，若用dB表示则需通过$dB=10\lg(\frac{S}{N})$来转换。</li><li>作用：<ul><li>给出了<strong>数据传输速率</strong>的限制（实际传输速率可能低不少）。</li></ul></li><li>结论：<ul><li>信道的带宽越宽，<strong>信噪比越大，则信息的传输速率越高</strong>。</li><li>只要信息的传输速率低于极限传输速率，就一定能找到某种方法来实现无差错的传输。（意思是在物理层面上不会因传输速率过快而导致信号失真）</li></ul></li></ul></li><li>结合奈斯定理和香浓定理，可知：单个码元的所携带的二进制信息量是有限的。</li><li>题型：<ul><li>若已知码元和比特的关系（一个码元有几种状态），次数可以通过奈斯定理去计算，最终结果受到两个公式的限制，即<strong>V=min{奈斯,香农}</strong>。</li><li>在<strong>脉码调制PCM</strong>中的<strong>采样频率</strong>即最终频率<strong>f</strong>，也就是说<strong>数据传输率</strong>为<strong>f</strong>×$\log_2n$,而无需进行<strong>2f</strong>处理（采样定理）。</li></ul></li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ul><li>数据-&gt;数字信号<ul><li>数字数据-&gt;数字信号：<ul><li>曼彻斯特：每一个码元<strong>中间都有跳变</strong>，<strong>1下降沿</strong>，<strong>0上升沿</strong>。（可做时钟同步）<ul><li>曼彻斯特关心一个码元内的跳变。</li></ul></li><li>差分曼彻斯特：每一个码元<strong>中间都有跳变</strong>，1起始不跳，0起始跳。（可做时钟同步）<ul><li>差分曼彻斯特关心码元间的跳变。</li><li><strong>第一个是0的从低到高，第一个是1的从高到低</strong>，后面的就看有没有跳变来决定了。</li></ul></li><li>（差分）曼彻斯特每个比特需要两个信号周期（与不归零相比），<strong>编码效率为50%</strong>。</li><li>4B/5B：<ul><li>数据流4位一组转5位（为了保证有足够多的跳变，提取时钟信息），冗余码做控制或保留。</li></ul></li><li><img src="https://pic.zty.plus/%E7%BC%96%E7%A0%81ppt.jpeg" alt="编码"></li></ul></li><li>模拟信号-&gt;数字信号：常用于对<strong>音频信号</strong>编码的调制（脉码调制PCM）<ul><li>采样：将时间上连续的模拟信号<strong>离散化</strong>。（根据奈斯定理2W原则有：采样频率必须&gt;=数字信号最大频率×2）</li><li>量化：将离散的模拟信号标准化为数字值。</li><li>编码：将量化的结果转化为二进制编码。</li></ul></li></ul></li></ul><h4 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h4><ul><li>数据-&gt;模拟信号<ul><li>数字数据-&gt;模拟信号：<ul><li>幅移键控（ASK）：以振幅的大小（有无）来表示1,0。</li><li>频移键控（FSK）：以频率大小来表示1,0。</li><li>相移键控（PSK）：以相位的正负来表示1,0。</li><li>正交振幅调制（QSK）：ASK+PSK</li><li><img src="https://pic.zty.plus/%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6ppt.jpeg" alt="带通调制"></li></ul></li><li>模拟数据-&gt;模拟信号：<ul><li>为了实现传输的有效性同分利用带宽资源。</li></ul></li></ul></li></ul><h3 id="三种交换"><a href="#三种交换" class="headerlink" title="三种交换"></a>三种交换</h3><ul><li><p>电路交换</p><ul><li>概念：<ul><li>数据传输前，两节点间必须建立一条专用的<strong>物理通信</strong>路径（交换设备和链路逐段连接而成），整条线路的资源在传输期间一直被<strong>独占</strong>，直到通信结束后释放。</li><li>电路建立后是<strong>直连式</strong>：电路上任何节点<strong>直通式</strong>转发数据，<strong>无存储转发时延</strong>。</li></ul></li><li>单位：<ul><li>比特流</li></ul></li><li>优点：<ul><li>通信时延小</li><li>有序传输</li><li>无冲突</li><li>即可传输数字信号，又可传输模拟信号</li><li>实时性强</li><li>控制简单</li></ul></li><li>缺点：<ul><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差，通信线路任何一点出现故障都需要重新建立连接</li></ul></li><li>差错：<ul><li>无差错检测</li></ul></li></ul></li><li><p>报文交换</p><ul><li>概念：<ul><li>将<strong>整个报文</strong>一段链路一段链路地转发，可自由选择路由路径。</li></ul></li><li>单位：<ul><li>报文（源地址、目的地址、……）</li></ul></li><li>优点：<ul><li>无需建立链接（存储转发）</li><li>动态分配电路</li><li>提高线路可靠性：中间节点出现故障可另选择路由</li><li>提高线路利用率：通信双方不独占线路</li><li>提供多目标服务：可同时发往多个目的地址</li></ul></li><li>缺点：<ul><li>报文在传输途中，中间节点存储转发造成时延（包括检查正确性）</li><li>不可传输模拟信号</li><li>对报文无限制，需要网络节点有较大缓存</li></ul></li><li>差错：<ul><li>可通过报文尾部FCS进行差错（位错）检测（在交换节点中）。</li></ul></li></ul></li><li><p>分组交换</p><ul><li>概念：<ul><li>将整个<strong>报文</strong>拆分（添加控制信息）成合理大小地<strong>分组</strong>，各分组独立选择路由路径，与报文一样一段链路一段链路地转发</li><li>以太网采用分组交换</li><li>两种方式（网络层）：数据报方式（不可靠）、虚电路方式。</li></ul></li><li>单位：<ul><li>分组</li></ul></li><li>优点：<ul><li>无需建立链接（存储转发）</li><li>动态分配电路</li><li>提高线路可靠性：中间节点出现故障可另选择路由</li><li>提高线路利用率：通信双方不独占线路</li><li>提供多目标服务：可同时发往多个目的地址</li></ul></li><li>缺点：<ul><li>报文在传输途中，中间节点存储转发造成时延（包括检查正确性）</li><li>不可传输模拟信号</li><li>需要传输额外的信息量（各分组地控制信息）</li><li>可能出现失序、丢失、重复地分组（因为各分组独立自主选择路由路径）</li></ul></li><li>差错：<ul><li>可通过分组尾部FCS进行差错（位错）检测（在交换节点中）。</li></ul></li></ul></li><li><p>区别：</p><ul><li><img src="https://pic.zty.plus/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2ppt.jpeg" alt="三种交换"></li><li>报文交换：<ul><li>每个报文在发送时会产生一次时延</li><li>经过路由器存储转发会发生另一次时延</li></ul></li><li>分组交换：<ul><li>每个分组发送时会产生一次时延</li><li>路由器接收到第一个分组后直接开始转发，产生一次时延，<strong>除了第一个分组，其余分组经过路由器转发不会产生额外的时延</strong>（因为多个分组可以并行地被不同路由器转发）。</li></ul></li></ul></li><li>选择:<ul><li>传输的信息量大，传输时间远大于呼叫时间：电路交换</li><li>端到端由很多链路组成：分组交换</li><li>转发时延：分组交换&lt;=报文交换</li><li>网络信道利用率：分组交换、报文交换&lt;=电路交换</li><li>数据传输率：电路交换&gt;报文交换&gt;分组交换</li></ul></li><li>备注：<ul><li>在四种交换：电路交换、报文交换、<strong>（网络层）分组交换（数据报服务、虚电路服务）</strong>中，<strong>只有虚电路服务能够提供可靠传输</strong>，报文交换未知。</li><li>电路交换：整个信号连续不断地直通式传送，不存在帧错（失序、丢失、重复）的问题，但是没有对位错的校验。</li><li>报文交换：只有一个传输单位（报文），不存在帧失序的问题，但是报文有没有FCS检测位错呢？待定不知道看可不可靠。</li><li>数据报服务（面向无连接）：可通过帧尾的FSC进行位错校验，但无法保证不帧错。</li><li>虚电路服务（面向连接）：可通过帧尾的FSC进行位错校验，由于建立了一条<strong>逻辑上的</strong>专用通信电路，故能保证不帧错。<ul><li>面向链接，逻辑相连，AB可同时向对方发送数据，分组首部不包含目的地址，包含虚电路标识符，每个阶段可以链接多条虚电路。</li></ul></li><li>可靠传输=不位错+不帧错</li><li>一般由于数据链路层总是能够通过FSC来保证不位错，故我们<strong>通常所说的可靠传输</strong>通过 超时 + 重传（保证不帧错）机制来实现即可。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;离散数据x∈{0,1}&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连续数据：x∈[0,1]&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://tianyuzhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统课后习题</title>
    <link href="http://tianyuzhou.github.io/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
    <id>http://tianyuzhou.github.io/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</id>
    <published>2020-11-15T05:45:06.000Z</published>
    <updated>2021-02-17T13:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>西安电子科技大学出版社出版的<strong>计算机操作系统（第四版）</strong>课后习题整理</li><li>作者：汤小丹 梁红兵 哲凤屏 汤子瀛</li></ul><h3 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h3><span id="more"></span><ol><li>设计现代OS的主要目标是什么？<ul><li>有效性</li><li>方便性</li><li>可扩充性</li><li>开放性</li></ul></li><li>OS的作用可表现在哪几个方面？<ul><li>OS作为用户与计算机硬件系统之间的接口</li><li>OS作为计算机系统资源的管理者</li><li>OS实现了对计算机资源的抽象</li></ul></li><li>为什么没说OS实现了对计算机资源的抽象？<ul><li>OS首先在裸机上覆盖一层<strong>I/O设备管理软件</strong>，实现了对<strong>计算机硬件操作</strong>的第一层抽象</li><li>在第一层软件上再覆盖<strong>文件管理软件</strong>，实现了对<strong>硬件资源操作</strong>的第二层抽象</li><li>OS通过在计算机硬件上安装<strong>多层系统软件</strong>，增强了系统功能，隐藏了对硬件操作的细节，由它们共同实现了对<strong>计算机资源</strong>的抽象</li></ul></li><li>试说明推动多道批处理系统形成和发展的主要动力是什么？<ul><li>主要动力来源于四个方面的社会需求与技术发展<ul><li>不断提高计算机资源的利用率</li><li>方便用户</li><li>器件的不断更新换代</li><li>计算机体系结构的不断发展</li><li>不断提出新的应用需求</li></ul></li></ul></li><li>何谓脱机I/O和联机I/O？<ul><li>脱机I/O是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在外围机的控制下，把纸带或卡片上的数据或程序输入到磁带上。该方式下的输入和输出由外围机控制完成，是在脱离主机的情况下进行的</li><li>联机I/O方式是指程序和数据的输入输出都是直接在主机的直接控制下进行的</li><li><a href="https://baike.baidu.com/item/%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87">外围机（外围设备）？</a></li></ul></li><li>试说明推动分时系统形成和发展的主要动力是什么？<ul><li>主要动力是：更好地满足用户的需要</li><li>主要表现在：<ul><li>CPU的分时使用缩短了作业的平均周转时间</li><li>人机交互能力使用户能直接控制自己的作业</li><li>主机的共享使多用户能同时使用同一台计算机，独立地处理自己的作业</li></ul></li></ul></li><li>实现分时系统地关键问题是什么？应如何解决？<ul><li>关键问题：当用户在自己的终端上键入自己的命令时，系统应能及时接收并及时处理该命令，在用户能接受的时延内将结果返回给用户</li><li>解决办法：<ul><li>针对<strong>及时接收问题</strong>，可以在系统中设置<strong>多路卡</strong>，使主机能够同时接收用户从各个终端上输入的数据；为每个终端<strong>配置缓冲区</strong>，暂存用户键入的命令或数据</li><li>针对<strong>及时处理问题</strong>，应使所有用户的作业都<strong>直接进入内存</strong>，并且为每个作业分配一个<strong>时间片</strong>，允许作业只在自己的时间片内运行，这样在不长的时间内，能使每个作业都运行一次</li></ul></li></ul></li><li>为什么要引入实时OS？<ul><li>实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</li><li>引入实时OS是为了满足应用的需求，更好地满足<strong>实时控制领域</strong>和<strong>实时信息处理领域</strong>的需要。</li></ul></li><li>什么是硬实时任务和软实时任务？试举例说明。<ul><li>硬实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。<ul><li>例如：运载火箭的控制等</li></ul></li><li>软实时任务是指它的截止时间并不严格，偶尔错过任务截止时间，对系统产生的影响不大。<ul><li>例如：网页内容更新，火车售票系统。</li></ul></li></ul></li><li>试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。<ul><li>及时性：<strong>实时信息处理系统</strong>对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而<strong>实时控制系统</strong>的及时性，是以控制对象所要求的开始截止时间或完成时间来确定的，一般为<strong>秒级到毫秒级，甚至有的要低于100微秒</strong>。</li><li>交互性：<strong>实时信息处理系统</strong>具有交互性，但人与系统的交互仅限于访问系统中某些特定的专用服务程序。不像<strong>分时系统</strong>那样能向终端用户提供数据和资源共享等服务</li><li>可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至灾难性后果，所以在实时系统中，往往都采取了<strong>多级容错措施</strong>保障系统的安全性及数据的安全性</li></ul></li><li>OS有哪几大特征？其最基本的特征是什么？<ul><li>特征：<strong>并发性、共享性、虚拟性、异步性</strong>四个基本特征</li><li>最基本特征：共享和并发是操作系统的两个最基本的特征，虚拟以并发和共享为前提，异步是并发和共享的必然结果。</li></ul></li><li>在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对于独占资源应采取何种共享方式？<ul><li>一般情况下：只能说明资源能被大家使用，如图书馆中的图书能提供给大家借阅，但并<strong>未限定借阅者必须在同一时间（间隔）和同一地点阅读</strong>。这样的资源共享方式，只要通过适当的安排，用户之间并<strong>不会产生对资源的竞争</strong>，因此资源管理比较简单。</li><li>OS环境下：资源共享或称为资源复用是指系统中的资源可供内存中多个并发执行的进程共同使用。宏观上<strong>既限定了时间（进程在内存期间），也限定了地点（内存）</strong>。由于系统资源远少于多道程序需求的总合，<strong>会形成对共享资源的争夺</strong>，资源管理复杂得多。</li><li>独占资源：在一段时间内，只允许一个进程访问该资源。应采用<strong>互斥共享方式</strong>。</li><li>其他资源：允许在一段时间内由多个进程“同时”（微观上交替进行）访问。可采用<strong>同时访问方式</strong>。例如：磁盘设备等。</li></ul></li><li>什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。<ul><li>时分复用技术：利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使得设备得到最充分的利用（也是提高资源利用率的根本原因）。</li><li>举例：<ul><li>虚拟处理机技术：利用多道程序设计技术，为每道程序建立至少一个进程，然多道程序并发执行。实现为多个用户服务，将一台物理处理机逻辑上分为多台处理机。</li><li>虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，供多个用户“同时”使用。</li></ul></li></ul></li><li>是什么原因使操作系统具有异步性特征？<ul><li>由于<strong>资源等</strong>因素的限制，使进程通常都不可能“一气呵成”，而是以“停停走走”的方式运行，即异步方式运行。</li></ul></li><li>处理机管理有哪些主要功能？它们的主要任务是什么？<ul><li><strong>进程控制（管理）：</strong> 为作业创建进程，撤销已结束进程控制进程在运行过程中的状态转换</li><li><strong>进程同步：</strong> 为多个进程（含线程）的运行进行协调</li><li><strong>进程通信：</strong> 用来实现在相互合作的进程之间的信息交换</li><li><strong>（处理机）调度：</strong><ul><li>作业调度：从后备队列按照一定算法，选出若干个作业，为它们分配所需的资源（首先是分配内存）。</li><li>进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。</li></ul></li></ul></li><li>内存管理有哪些主要功能？它们的主要任务是什么？<ul><li><strong>内存分配：</strong> 为每道程序分配内存</li><li><strong>内存保护：</strong> 确保每道用户程序都只在自己的内存空间运行，彼此互不干扰</li><li><strong>地址映射：</strong> 将地址空间的逻辑地址转换为内存空间与对应的物理地址</li><li><strong>内存扩充：</strong> 用于实现请求调用功能，置换功能等</li></ul></li><li>设备管理有哪些主要功能？其主要任务是什么？<ul><li>主要功能:缓冲管理、设备分配和设备处理以及虚拟设备等。</li><li>主要任务:完成用户提出的I/O请求，为用户分配I/O设备；提高CPU和I/O设 备的利用率；提高I/O速度；以及方便用户使用I/O设备。</li></ul></li><li>文件管理有哪些主要功能？其主要任务是什么？<ul><li>主要功能：文件存储空间的管理、目录管理、文件的读/写管理和保护。</li><li>主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。</li></ul></li><li>试说明推动传统OS演变为现代OS的主要因素是什么？<ul><li>用户对OS的系统安全、网络功能和服务、多媒体功能的需求增加。</li><li>计算机技术的不断发展。</li></ul></li><li>什么是微内核OS？<ul><li>足够小的内核</li><li>基于客户/服务器模式</li><li>应用机制与策略分离原理</li><li>采用面向对象技术</li></ul></li><li>微内核操作系统具有哪些优点？它为何能有这些优点？<ul><li>提高了系统的可扩展性</li><li>增强了系统的可靠性</li><li>可移植性</li><li>提供了对分布式系统的支持</li><li>融入了面向对象技术</li></ul></li><li>现代操作系统较之传统操作系统又增加了哪些功能和特征？<ul><li>面向安全、面向网络、面向多媒体</li></ul></li><li>在微内核OS中，为什么要采用客户/服务器模式？<ul><li>C/S模式具有独特的优点：<ul><li>数据的分布处理和存储</li><li>便于集中管理</li><li>灵活性和可扩充性</li><li>易于改编应用软件</li></ul></li></ul></li><li>在基于微内核结构的OS中，应用了哪些新技术？<ul><li>采用面向对象的程序设计技术</li></ul></li><li>何谓微内核技术？在微内核中通常提供了哪些功能？<ul><li>把操作系统中更多的成分和功能放到更高的层次（即用户模式）中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。</li><li>在微内核中通常提供了<strong>进程（线程）管理</strong>、<strong>低级存储器管理</strong>、<strong>中断和陷入处理</strong>等功能。</li></ul></li></ol><h3 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h3><ol><li>什么是前趋图？为什么要引入前趋图？<ul><li>前趋图(Precedence Graph)是一个<strong>有向无循环图</strong>，记为DAG(Directed AcyclicGraph)，用于描述<strong>进程之间</strong>执行的<strong>前后关系</strong>。</li></ul></li><li>画出下列四条语句的前趋图<ul><li>略</li></ul></li><li>为什么程序并发执行会产生间断性特征？<ul><li>程序在并发执行时，由于它们<strong>共享系统资源</strong>，以及为完成同一项任务需要<strong>相互合作</strong>，致使这些并发进程之间形成了<strong>互相制约</strong>的关系，从而使得进程在执行期间出现间断性。</li></ul></li><li>程序并发执行时为什么会失去封闭性和可再现性？<ul><li>程序并发执行时，多个程序<strong>共享系统中的各种资源</strong>，因而这些<strong>资源的状态由多个程序改变</strong>，致使程序运行失去了封闭性，也会导致其失去可再现性。</li></ul></li><li>在操作系统中为什么要引入进程概念？它会产生什么样的影响?<ul><li>为了<strong>使程序</strong>在多道程序环境下<strong>能并发执行</strong>，并对并发执行的程序<strong>加以控制和描述</strong>，在操 作系统中引入了进程概念。</li><li>影响：使程序的并发执行得以实行。</li></ul></li><li>试从动态性，并发性和独立性上比较进程和程序?<ul><li><strong>动态性</strong>是进程<strong>最基本的特性</strong>，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是<strong>静态实体</strong>。</li><li><strong>并发性</strong>是进程的重要特征，同时也是<strong>OS的</strong>重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。</li><li><strong>独立性</strong>是指进程实体是一个能<strong>独立运行的基本单位</strong>，也是系统中<strong>独立获得资源</strong>和<strong>独立调度</strong>的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。</li></ul></li><li>试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？<ul><li><strong>作为独立运行基本单位的标志</strong><ul><li>PCB的建立表示程序成为一个能在多道程序环境下独立运行、合法的基本单位，也就获得了OS服务的权力。</li></ul></li><li><strong>能实现间断运行方式</strong><ul><li>PCB在进程阻塞时保存和恢复CPU现场信息</li></ul></li><li><strong>提供进程管理所需要的信息</strong><ul><li>PCB记录程序和数据在内存或外存中的始址指针，找到相应的程序和数据</li><li>访问系统中的文件或I/O需要借助PCB的信息</li><li>通过PCB的资源清单可了解到该进程所需的全部资源</li></ul></li><li><strong>提供进程调度所需要的信息</strong><ul><li>PCB存储了进程状态信息（就绪与否）</li><li>优先级、等待时间、已执行时间、事件（阻塞原因）</li></ul></li><li><strong>实现与其它进程的同步和通信</strong><ul><li>PCB中有用于实现进程通信的区域或通信队列指针等</li></ul></li><li>综上：<strong>PCB是进程实体的一部分</strong>，是操作系统中最重要的<strong>记录型数据结构</strong>。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。<strong>OS通过PCB感知进程的存在，根据PCB对并发执行的进程进行控制和管理</strong>。</li></ul></li><li>PCB提供了进程管理和进程调度的哪些信息？<ul><li>提供进程管理所需要的信息<ul><li>PCB记录程序和数据在内存或外存中的始址指针，找到相应的程序和数据</li><li>访问系统中的文件或I/O需要借助PCB的信息</li><li>通过PCB的资源清单可了解到该进程所需的全部资源</li></ul></li><li>提供进程调度所需要的信息<ul><li>PCB存储了进程状态信息（就绪与否）</li><li>优先级、等待时间、已执行时间、事件（阻塞原因）</li></ul></li></ul></li><li>进程控制块的组织方式有哪几种？<ul><li><strong>线性方式</strong><ul><li>将系统中所有PCB组织在一张线性表中。</li><li>实现简单，开销小，但每次查找需要扫描整张表，适合进程数目不多的系统。</li></ul></li><li><strong>链接方式</strong><ul><li>把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。这样就可以形成就绪队列、若干阻塞队列、空闲队列等。</li></ul></li><li><strong>索引方式</strong><ul><li>系统根据所有进程的状态不同，建立几张索引表。例如，就绪索引表、阻塞索引表等。</li></ul></li></ul></li><li>何谓操作系统内核？内核的主要功能是什么？<ul><li>操作系统内核：被安排在紧靠硬件的软件层次中，将它们常驻内存的与硬件紧密相关的模块。</li><li>支撑功能：<ul><li>中断处理（OS最基本的功能）、时钟管理、原语操作</li></ul></li><li>资源管理功能<ul><li>进程管理、存储器管理、设备管理</li></ul></li></ul></li><li>试说明进程在三个基本状态之间转换的典型原因。<ul><li>就绪状态→执行状态：进程分配到CPU资源</li><li>执行状态→就绪状态：时间片用完</li><li>执行状态→阻塞状态：I/O请求</li><li>阻塞状态→就绪状态：I/O完成</li></ul></li><li>为什么要引入挂起状态？该状态有哪些性质？<ul><li>引入挂起状态处于五种不同的需要:终端用户需要，父进程需要，操作系统需要，对换需要和负荷调节需要。</li><li>处于挂起状态的进程不能接收处理机调度。</li></ul></li><li>在进行进程切换时，所要保存的处理机状态信息有哪些？<ul><li>通用寄存器，进程当前暂存信息</li><li>指令计数器，下一指令地址信息</li><li>程序状态字PSW，进程状态信息</li><li>用户指针栈，过程和系统调用参数及调用地址信息</li></ul></li><li>试说明引起进程创建的主要事件。<ul><li>用户登录、作业调度、提供服务、应用请求（前三者由系统内核创建，最后一个为用户进程自己创建）</li></ul></li><li>试说明引起进程被撤销的主要事件。<ul><li>正常结束、异常结束（越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障）、外界干预（操作员或操作系统干预、父进程请求、父进程终止）。</li></ul></li><li>在创建一个进程时所要完成的主要工作是什么？<ul><li>OS发现请求创建新进程事件后，调用进程创建原语Creat()<ul><li><strong>申请空白PCB</strong>，为新进程申请获得唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB。</li><li><strong>为新进程分配其运行所需的资源</strong>，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。</li><li><strong>初始化进程控制块</strong>(PCB)，包括：初始化标识信息、初始化处理机状态信息、初始化处理机控制信息。</li><li><strong>将新进程插入就绪队列</strong>，如果进程就绪队列能够接纳新进程。</li></ul></li></ul></li><li>在撤销一个进程时所要完成的主要工作是什么？<ul><li>根据被终止进程标识符，从PCB集中检索出进程PCB，读出该进程状态。</li><li>若被终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。</li><li>若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。</li><li>将被终止进程拥有的全部资源，归还给父进程，或归还给系统。</li><li>将被终止进程PCB从所在队列或列表中移出，等待其它程序搜集信息。</li></ul></li><li>试说明引起进程阻塞或被唤醒的主要事件是什么？<ul><li>向系统请求共享<strong>资源</strong>失败-阻塞，其他进程始放该资源-唤醒。</li><li>等待某<strong>操作</strong>（事件）完成-阻塞，操作（事件）完成-唤醒。</li><li>新<strong>数据</strong>尚未到达-阻塞，数据到达-唤醒。</li><li>等待新<strong>任务</strong>-阻塞，新任务到达-唤醒。</li></ul></li><li>为什么要在OS中引入线程？<ul><li>在操作系统中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性，提高CPU的利用率。</li><li>进程是分配资源的基本单位，而线程则是系统调度的基本单位。</li></ul></li><li>试说明线程具有哪些属性？<ul><li>轻型实体、<strong>独立调度和分派</strong>的基本单位、可并发执行、共享进程资源。</li></ul></li><li>试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。<ul><li><strong>调度性</strong>：线程在OS中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。</li><li><strong>并发性</strong>：进程可以并发执行，一个进程的多个线程也可并发执行。</li><li><strong>拥有资源</strong>：进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源（TCB），本身基本不拥有系统资源，但可以访问隶属进程的资源。</li><li><strong>系统开销</strong>：操作系统在创建、撤消和切换进程时付出的开销显著大于线程。</li></ul></li><li>线程控制块TCB中包含了哪些内容？<ul><li>线程标识符</li><li>一组寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul></li><li>何谓用户级线程和内核支持线程？<ul><li>用户级线程：仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、 线程间的同步与通信等功能，都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。</li><li>内核支持线程：在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、撤销和切换等都是依靠内核，在内核空间中实现的。在内核空间里还为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。</li></ul></li><li>试说明用户级线程的实现方法。<ul><li>用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中 间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。</li></ul></li><li>试说明内核支持线程的实现方法。<ul><li>系统在创建新进程时，分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。创建一个线程分配一个TCB，有关信息写入TCB，为之分配必要的资源。当PTDA中的TCB用完，而进程又有新线程时，只要所创建的线程数目未超过系统允许值，系统可 在为之分配新的TCB；在撤销一个线程时，也应回收线程的所有资源和TCB。</li></ul></li><li>多线程模型有哪几种类型？多对一模型有何优缺点？<ul><li>多对一模型<ul><li>优点：线程管理开销小，效率高</li><li>缺点：一个线程访问内核时发生阻塞，整个进程都会被阻塞；在任意时刻只有一个线程能访问内核，多个线程不能同时在多个处理机上运行。</li></ul></li><li>一对一模型<ul><li>优点：一个线程阻塞时，允许调度另一个线程运行（更好的并发功能）</li><li>缺点：每创建一个用户线程，相应的需要创建一个内核线程，开销较大。</li></ul></li><li>多对多模型<ul><li>优点：结合上述两模型优点</li></ul></li></ul></li></ol><h3 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h3><ol><li>高级调度与低级调度的主要任务是什么？为什么要引入中级调度？<ul><li>高级调度的主要任务是根据某种算法，把外存上处于后备队列中的那些<strong>作业</strong>调入内存。</li><li>低级调度是保存处理机的现场信息，按某种算法先取进程，再把处理器分配给<strong>进程</strong>。</li><li>引入中级调度的主要目的是为了<strong>提高内存利用率和系统吞吐量</strong>。配合<strong>对换技术</strong>，调度换出到磁盘的进程进入内存，准备执行。（挂起状态-&gt;就绪状态）</li></ul></li><li>处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？<ul><li>处理机调度算法的目标：<ul><li>资源利用率：使系统中的处理机和其他所有资源都尽可能地保持忙碌状态。</li><li>公平性：使每个进程都获得合理的CPU时间，不会发生进程饥饿现象。</li><li>平衡性：进程的类型分<strong>计算型和I/O型</strong>，为使系统中的CPU和外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。</li><li>策略强制执行：对所制定的的策略其中包括安全策略，只要需要，就必须以准确地执行，即使会造成某些工作地延迟也要执行。</li></ul></li><li>批处理系统的目标：<ul><li>平均周转时间短：从作业提交给系统开始，到作业完成为止地这段时间间隔短/作业数。<ul><li>作业在外存后备队列等待调度的时间、进程在就绪队列等待调度的时间、进程在CPU执行的时间、进程等待I/O地时间，即周转时间。</li></ul></li><li>系统吞吐量高：单位时间内系统所完成的作业数多。</li><li>处理机利用率高：CPU的利用尽量不空闲。（单纯提高利用率应该选择计算量大的作业运行，由上述可看出这些要求存在一些矛盾。）</li></ul></li></ul></li><li>何谓作业、作业步和作业流？<ul><li>作业包含通常的<strong>程序和数据</strong>，还配有作业说明书。系统根据该说明书和JCB的内容对程序的运行进行控制。<strong>批处理系统</strong>中是以<strong>作业</strong>为<strong>基本单位</strong>从外存调入内存。</li><li>作业步是指每个作业运行期间都必须经过若干个相对独立相互关联的顺序<strong>加工的步骤</strong>。</li><li>作业流是指若干个作业进入系统后依次存放在外存上形成的输入作业流；在操作系统的控制下，逐个作业进行处理，于是形成了处理作业流。</li></ul></li><li>在什么情况下需要使用作业控制块JCB？其中包含了哪些内容？<ul><li>每当作业进入系统时，系统便为每个作业建立一个作业控制块JCB，根据作业类型将它插入到相应的后备队列中。</li><li>JCB包含的内容通常有：(1)作业标识 (2)用户名称 (3)用户账户 (4)作业类型（CPU繁忙型、I/O芳名型、批量型、终端型）(5)作业状态 (6)调度信息（优先级、作业已运行）(7)资源要求 (8)进入系统时间 (9)开始处理时间 (10)作业完成时间 (11)作业退出时间 (12)资源使用情况等</li></ul></li><li>在作业调度中应如何确定接纳多少个作业和接纳哪些作业？<ul><li>作业调度每次接纳进入内存的作业数，取决于<strong>多道程序度</strong>。应将哪些作业从外存调入内存，取决于采用的<strong>调度算法</strong>。最简单的是先来服务调度算法，较常用的是短作业优先调度算法和基于作业优先级的调度算法。</li></ul></li><li>为什么要引入高响应比优先调度算法？它有何优点？<ul><li>在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽略了作业的运行时间，而SJF算法正好与之相反。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的算法。</li><li>优点：因此既照顾了短作业，又不致使长作业等待时间过长，从而改善了处理机调度的性能。</li><li>$优先权=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}$</li></ul></li><li>试说明低级调度的主要功能。<ul><li>保存处理机的现场信息</li><li>按某种算法选取进程</li><li>把处理机分配给进程</li></ul></li><li>在抢占调度方式中，抢占的原则是什么？<ul><li>抢占的原则有：时间片原则、优先权原则、短作业优先权原则等。</li></ul></li><li>在选择调度方式和调度算法时，应遵循的准则是什么？<ul><li>面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。</li><li>面向系统的准则：系统吞吐量高、处理机利用率高、各类资源的平衡利用。</li></ul></li><li>在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？<ul><li>批处理系统的调度算法：先来先服务(FCFS)、短作业优先(SJF)、优先级、高响应比优先(HRRN)、多级反馈队列调度(MFQ)算法。 分时系统的调度算法：时间片轮转法（轮转调度算法 RR）。</li><li>实时系统的调度算法：最早截止时间优先(EDF)、最低松弛度优先(LLF)算法。</li></ul></li><li>何谓静态和动态优先级？确定静态优先级的依据是什么？<ul><li>静态优先级是指：在创建进程时确定且在进程的整个运行期间保持不变的优先级。</li><li>动态优先级是指：在创建进程时赋予的优先权，可以随进程推进或随其等待时间增加而改变的优先级，可以获得更好的调度性能。</li><li>确定进程优先级的依据：进程类型、进程对资源的需求和用户要求</li></ul></li><li>试比较FCFS和SJF两种进程调度算法。<ul><li>相同点：两种调度算法都可以用于作业调度和进程调度。</li><li>不同点：FCFS调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业，将它们调入内存、分配资源、创建进程、插入到就绪队列。<strong>该算法有利于长作业/进程，不利于短作业/进程</strong>。</li><li>SJF算法每次调度都从后备队列中选择一个或若干个估计运行时间最短的作业，调入内存中运行。<strong>该算法有利于短作业/进程，不利于长作业/进程</strong>。</li></ul></li><li>在时间片轮转法中，应如何确定时间片的大小？<ul><li>时间片应<strong>略大于</strong>一次典型的交互需要的时间。</li><li>一般应考虑三个因素：系统对响应时间的要求、就绪队列中进程的数目和系统的处理能力。</li><li>时间片太小，会频繁执行进程调度和进程上下文切换，增加系统开销；太长，RR算法退化为FCFS算法。</li></ul></li><li>通过一个例子来说明通常的优先级调度算法不能适用于实时系统？<ul><li>实时系统的调度算法很多，主要是基于任务的开始截止时间和任务紧急/松弛程度的任务优先级调度算法，<strong>通常的优先级调度算法</strong>(需要使用抢占式优先级调度算法)不能满足实时系统的调度实时性要求而不适用。例如：火箭发射系统，紧急停止发射。</li></ul></li><li>为什么说多级反馈队列调度算法能较好地满足各方面用户的需求？<ul><li>终端型作业用户提交的作业大多属于较小的交互型作业，系统只要使这些作业在第一队列规定的时间片内完成，终端作业用户就会感到满足。</li><li>短批处理作业用户，开始时像终端型作业一样，如果在第一队列中执行一个时间片段即可完成，便可获得与终端作业一样的响应时间。对于稍长作业，通常只需在第二和第三队列各执行一时间片即可完成，其周转时间仍然较短。</li><li>长批处理作业，它将依次在第1，2，…，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</li><li>所以，多级反馈队列调度算法能满足多用户需求。</li></ul></li><li>为什么说传统的几种调度算法都不能算是公平调度算法？<ul><li>传统的调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作用业占用了多少处理机时间。</li><li>另外也为考虑到调度的公平性。</li></ul></li><li>保证调度算法是如何做到调度的公平性的？<ul><li>保证每个相同类型的进程获得相同的处理机时间。</li><li>记录每个进程自创建以来已执行的处理时间。</li><li>计算每个进程应获得的时间，自创建以来已执行的处理时间/n（n为同时运行的同类型进程数）。</li><li>计算进程获得处理机的比率，进程实际执行的处理时间和应获得的时间之比。</li><li>比较进程获得处理机的比率，选择比率最小的进程分配处理机，直到它的比率不是最小为止。</li></ul></li><li>公平分享调度算法又是如何做到调度的公平性的？<ul><li>该算法调度的公平性主要是针对用户而言，使用户获得相同的处理机时间，或所要求的时间比例。即需考虑每一个用户所拥有的进程数目。</li></ul></li><li>为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？<ul><li>实时系统中通常有着多个实时任务。若处理机的处理能力不够强，有可能因为处理机忙不过来而使某些实时任务得不到及时处理，导致发生难以预料的后果。</li></ul></li><li>按照调度方式可将实时调度算法分为哪几种？<ul><li>可分为非抢占式和抢占式两种算法。而非抢占式算法又分为非抢占式轮转和优先调度算法；抢占式调度算法又分为基于时钟中断的抢占式优先权和立即抢占式优先权调度算法。</li></ul></li><li>什么是最早截止时间优先调度算法？举例说明。<ul><li>根据任务的开始截止时间确定的任务优先级调度算法。截止时间越早则优先级越高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。 举例：非抢占式调度方式用于非周期实时任务。举例：P108</li></ul></li><li>什么是最低松弛度优先调度算法？举例说明之。<ul><li>该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高， 为该任务所赋予的优先级就愈高，以使之优先执行。举例：P109</li></ul></li><li>何谓“优先级倒置”现象，可以采取什么方法来解决？<ul><li>在OS中存在着影响进程运行的资源而产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。（低优先级进程或线程占用了某些临界资源）</li><li>解决方法：<ul><li>（1）当低优先级进程进入临界区后不允许其处理机被抢占，让其执行完自己退出临界区。但可能使高优先级进程等待时间较长。</li><li>（2）低优先级进程进入临界区后，继承将要执行的高优先级进程的优先级，防止优先级在这两个进程之间的进程插队。</li></ul></li></ul></li><li>试分别说明可重用资源和可消耗资源的性质。<ul><li>可重用性资源是一种可供用户重复使用多次的资源。</li><li>性质：<ul><li>每一个可重用资源中的单元只能分配给一个进程使用，不允许多进程共享。</li><li>进程在使用可重用资源时，必须按照这样的顺序：<ul><li>请求资源，失败则阻塞或循环等待。</li><li>使用资源，对资源进程操作。</li><li>释放资源，使用完成释放资源。</li></ul></li></ul></li><li>可消耗性资源又称为临时资源，它是在进程运行期间，由进程动态地创建和消耗。</li><li>性质：<ul><li>每一类可消耗性资源地单元数目在进程运行期间是可以不断变化的。</li><li>进程在运行过程中，可以不断地创造可消耗性资源地单元，将它们放入缓冲区，以增加该资源类的单元数目。</li><li>进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给资源类中。</li></ul></li></ul></li><li>试举例说明竞争不可抢占资源引起的死锁。<ul><li>一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</li><li>两个进程P1、P2准备写两个文件F1、F2；P1先打开F1，P2“同时”打开“F2；P1试图打开F2，P2试图打开F1，各自阻塞无限等待。</li></ul></li><li>为了破环“请求和保持”条件而提出了两种协议，试比较两种协议。<ul><li>第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。<ul><li>优点：简单、易行且安全。</li><li>缺点：资源被严重浪费、使进程经常会发生饥饿现象.</li></ul></li><li>第二种协议：对第一种协议的改进，允许一个进程只获得运行初期所需地资源后，便开始运行。进程在运行过程中再逐步释放已分配给自己、且已用毕地全部资源，然后在请求新的资源。<ul><li>优点：使进程更快地完成任务，提高设备利用率、减少进程发生饥饿地机率。</li></ul></li></ul></li><li>何谓死锁？产生死锁的原因和必要条件是什么？<ul><li>如果一组进程中的每一个进程都在等待仅由该进程组中的其它进程才能引发的事件，那么该组进程就是死锁。</li><li>产生死锁的原因为竞争资源（不可抢占资源、可消耗资源）和进程间推进顺序非法。其必要条件是：互斥条件、请求和保持条件、不可抢占条件、循环等待条件。</li></ul></li><li>解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？<ul><li>决死锁的四种方法即预防、避免、检测和解除死锁中，预防死锁最容易实现；（检测）解除死锁使资源的利用率最高，并发程度提高（对应防范程度逐渐减弱）。</li></ul></li><li>请详细说明可通过哪些途径预防死锁。<ul><li>破坏“请求和保持”条件，就是如果系统有足够资源，便一次性把进程需要的所有资源分配给它；</li><li>破坏“不可抢占”条件，就是已经拥有资源的进程，当它提出新资源请求而不能立即满足时，必须释放它已保持的所有资源，待以后需要时再重新申请；</li><li>破坏“循环等待”条件，就是将所有资源按类型排序标号，所有进程对资源的请求 必须严格按序号递增的次序提出。</li></ul></li></ol><h3 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h3><ol><li>为什么要配置层次式存储器？<ul><li>无法同时满足对存储器速度快、容量大、价格低的要求。</li><li>设置多个存储器可以使存储器两端的硬件能并行工作；</li><li>采用多级存储系统，特别是 Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案；</li><li>在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力。增加CPU中寄存器数量大大缓解对存储器压力。</li></ul></li><li>可采用哪几种方式将程序装入内存？它们分别适用于何种场合？<ul><li>绝对装入方式，只适用于单道程序环境。<ul><li>程序中的相对地址（逻辑地址）与实际内存地址完全相同。</li></ul></li><li>可（静态）重定位装入方式，适用于多道程序环境。<ul><li>不允许程序<strong>运行时</strong>在内存中移位置。（运行前可移动，但必须修改程序和数据的绝对地址。）</li><li>逻辑地址与实际装入内存后的物理地址不同。</li></ul></li><li>动态运行时装入方式，用于多道程序环境。<ul><li>实际情况是程序在运行时在内存中的位置可能经常需要改变（换入换出）</li><li>装入内存的地址仍然都是逻辑地址，在真正执行时进行地址转换（需要重定位寄存器的支持）。</li></ul></li></ul></li><li>何谓静态链接？静态链接时需要解决两个什么问题？<ul><li>静态链接是指在程序运行前，先将各目标模块及它们所需的库函数，链接成<strong>一个完整的装配模块</strong>，以后<strong>不再拆开</strong>的链接方式。</li><li>需要解决的问题：<ul><li><strong>对相对地址进行修改</strong>。<ul><li>各模块内部的相对地址加上对应的偏移量</li></ul></li><li><strong>变换外部调用符号</strong>。<ul><li>各模块间的外部调用符号也变换为相对地址</li></ul></li></ul></li></ul></li><li>何谓装入时动态链接？装入时动态链接方式有何优点？<ul><li>装入时动态链接是指将用户源程序编译后得到的<strong>一组目标模块</strong>（分开存放），在装入内存时采用边装入边链接的链接方式。</li><li>优点：<ul><li>便于修改和更新。<ul><li>不需要重新打开装入模块。</li></ul></li><li>便于实现对目标模块的共享。<ul><li>对比静态链接（不能实现共享），不需要每个应用都含有其目标模块的拷贝，可以将一个模块链接到多个应用上。</li></ul></li></ul></li></ul></li><li>运行时的动态链接？运行时动态链接方式有何优点？<ul><li>运行时动态链接是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。</li><li>优点：<ul><li>加快程序装入过程、节省大量的内存空间。<ul><li>不需要将所有可能运行的模块全部装入内存，因为有些模块根本不会运行。</li><li>例如：错误处理的目标模块，若整个运行过程都不出现错误，这个模块就不会被使用。</li></ul></li></ul></li></ul></li><li>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？<ul><li>在每个分区的起始部分，设置一些控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部设置一个后向指针，通过前后向链接指针，将所有空闲分区链成一个双向链。当分区分配出去后，把状态位由“0”改为“1”。</li></ul></li><li>为什么要引入动态重定位？如何实现？<ul><li>动态可重定位分区分配（动态分区分配的改进），使用了紧凑技术，程序或数据的地址发生变化，每次紧凑都要修改地址，很麻烦且大大影响系统效率。</li><li>在程序执行过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，即引入了动态重定位；</li><li>具体实现方法是在系统中增加一个<strong>重定位寄存器</strong>，用来装入程序在内存中的起始地址， 程序执行时，真正访问的内存地址是<strong>相对地址与重定位寄存器中的地址相加之和</strong>，从而实现动态重定位。</li></ul></li><li>什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？<ul><li>指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。</li><li>可分为：首次适应算法（First Fit，FF）、循环首次适应算法（Next Fit，NF）、最佳适应算法（Best Fit，BT）、最坏适应算法（Worst Fit，WF）</li></ul></li><li>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？<ul><li>在采用首次适应算法回收内存时可能出现4种情况：<ul><li>回收区前邻空闲区。将回收区与前邻空闲区合并，将前邻空闲区大小修改为两者之和。</li><li>回收区后邻空闲区。将两区合并，改后邻空闲区始址为回收区始址，大小为两者之和。</li><li>回收区前后均邻空闲区。将三个分区合并，修改前邻空闲区大小为三者之和。</li><li>回收区前后均不邻空闲区。为回收区设置空闲区表项，填入回收区始址和大小并插入空闲区队列。</li></ul></li></ul></li><li>什么是基于索引搜索的动态分区分配算法？它可分为哪几种？<ul><li>基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，分区很多，采用顺序搜索分区方法可能会很慢，这时会采用基于索引的分配算法。</li><li>常用的有：快速适应算法（Quick Fit）、伙伴系统（Buddy System）、哈希算法。</li></ul></li><li>伙伴系统表达式计算<ul><li>略（P141）</li></ul></li><li>分区存储管理中常用那些分配策略？比较它们的优缺点。<ul><li>分区存储管理中的常用分配策略：<strong>首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法</strong>。</li><li>首次适应算法优缺点：<ul><li>保留了高址部分的大空闲区，有利于后来的大型作业分配。</li><li>低址部分不断被划分，留下许多难以利用的小空闲区，每次查找都从低址开始增加了系统开销。</li></ul></li><li>循环首次适应算法优缺点：<ul><li>内存空闲分区分布均匀，减少了查找系统开销。</li><li>缺乏大空闲分区，导致不能装入大型作业。</li></ul></li><li>最佳适应算法优缺点：<ul><li>每次分配给文件的都是最适合该文件大小的分区。</li><li>内存中留下许多难以利用的小空闲区。</li></ul></li><li>最坏适应算法优缺点：<ul><li>剩下空闲区不太小，产生碎片几率小，对中小型作业分配分区操作有利。</li><li>存储器中缺乏大空闲区，对大型作业分区分配不利。</li></ul></li></ul></li><li>为什么要引入对换？对换可分为哪几种类型？<ul><li>最早用于用于麻省理工单用户分时系统CTSS，由于当时计算机内存非常小，为了使该系统能分时运行多个用户程序而引入。</li><li>两方面原因：<ul><li>一方面，多道程序环境下，内存中存在某些进程由于某事件未发生而被阻塞运行，占用了大量内存空间。</li><li>另一方面，外存中又有许多作业，因内存空间不足而不能进入内存运行。</li><li>这是对系统资源的严重浪费，且使系统吞吐量下降。</li></ul></li><li>对换类型：<ul><li>整体对换：以整个进程为单位的对换，又称“进程对换”。</li><li>页面(分段)对换：以进程的一个页面或分段为单位的对换，又称“部分对换”。</li></ul></li></ul></li><li>对文件区管理的目标和对对换空间管理的目标有何不同？<ul><li>在具有对换功能的OS中，通常把磁盘空间分为<strong>文件区和对换区</strong>两部分。</li><li>对文件区管理的主要目标：提高文件的空间利用率，然后才是提高对文件的访问速度。因此，采取离散分配的方式。</li><li>对对换空间管理的主要目标：提高进程换入换出的速度，然后才是提高文件存储空间的利用率。为此，采取连续分配方式，较少考虑外存中的碎片问题。</li></ul></li><li>为实现对换，系统应具备哪几方面的功能？<ul><li>系统应具备三方面功能：对换空间管理、进程换出、进程换入。</li></ul></li><li>在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？<ul><li>并非每次将整个进程换出</li><li>原因：<ul><li>从结构上讲，进程是由程序段、数据段和进程控制块PCB组成的，其中进程控制块总有部分或全部常驻内存，不被换出。</li><li>程序段和数据段可能正被若干进程共享，此时它们也不能被换出。</li></ul></li></ul></li><li>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？<ul><li>分页存储管理方式、分段存储管理方式、段页式存储管理方式。</li></ul></li><li>.什么是页面?什么是物理块?页面的大小应如何确定？<ul><li>页面：分页存储管理将<strong>进程</strong>的<strong>逻辑地址空间</strong>分成若干个页，并为各页加以编号。</li><li>物理块：把<strong>内存</strong>的<strong>物理地址空间</strong>分成若干个块，并为各块加以编号。</li><li>页面大小应选择适中，且页面大小应该是2的幂，通常为1KB~8KB。</li></ul></li><li>什么是页表？页表的作用是什么？<ul><li>页表是分页式存储管理使用的数据结构。一个进程分为多少页，它的页表就有多少行。每一行记录进程的一页页号和它存放的物理块的块号对应关系。</li><li>作用：页表用于进行地址变换，即实现页号到物理块号的地址映射。</li></ul></li><li>为实现分页存储管理，需要哪些硬件的支持？<ul><li>页表寄存器PTR</li><li>地址变换机构<ul><li>基本的地址变换机构</li><li>具有快表（高速缓冲寄存器或称联想寄存器）的地址变换机构</li></ul></li></ul></li><li>在分页系统中是如何实现地址变换的？<ul><li>利用地址变换机构实现从逻辑地址到物理地址的转变换，通过页表来实现从页号到物理块号的变换，将逻辑地址中的页号转换为内存中的物理块号。</li></ul></li><li>具有快表时是如何实现地址变换的？<ul><li>在CPU给出有效地址后，由地址变换机构自动将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号比较。</li><li>若找到匹配页号，表示要访问的页表项在快表中。可直接从快表读出该页对应物理块号，送到物理地址寄存器中。</li><li>如快表中没有对应页表项，则再访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页表项存入快表。</li></ul></li><li>较详细的说明引入分段存储管理方式是为了满足用户哪几个方面的需求。<ul><li><strong>方便编程</strong>。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定</li><li><strong>信息共享</strong>。在实现对程序和数据的共享时，是以信息逻辑单位为基础。<ul><li>分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适</li></ul></li><li><strong>信息保护</strong>。对信息的逻辑单位进行保护（标上标记即可），分段能更有效方便地实现信息保护功能。</li><li><strong>动态增长</strong>。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题</li><li><strong>动态链接</strong>。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。</li></ul></li><li>在具有快表的段页式存储管理方式中，如何实现地址变换?<ul><li>类似第22题</li></ul></li><li>为什么说分段系统较之分页系统更易于实现信息共享和保护？<ul><li>对于分页系统，每个页面是分散存储的，为了实现信息共享和保护，则页面之间需要一一对应起来，为此需要建立大量的页表项；</li><li>而对于分段系统，每个段都从0开始编址，并采用一段连续的地址空间，这样在实现共享和保护时，只需为所要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应起来即可。</li></ul></li><li>分页和分段有何区别?<ul><li>分页和分段都采用离散分配的方式，且都要通过地址映射机构来实现地址变换，这是它们的共同点；</li><li>对于它们的不同点有三：<ul><li>第一，从功能上看，页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率，即满足系统管理的需要，而不是用户的需要；而段是信息的逻辑单位，它含有一组其意义相对完整的信息，目的是为了能更好地满足用户的需要；</li><li>第二，页的大小固定且由系统确定，而段的长度却不固定，决定于用户所编写的程序；</li><li>第三分页的作业地址空间是一维的，而分段的作业地址空间是二维的。</li></ul></li></ul></li><li>试全面比较连续分配和离散分配方式<ul><li>连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单，只用于单用户单任务操作系统；分区方式分固定和动态分区。</li><li>离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段式存储管理旨在满足用户(程序员)的需要，段页式存储管理则将两者结合起来，具有分段系统便于实现、可共享、易于保护和动态链接等优点，又能像分页系统很好解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式；</li></ul></li></ol><h3 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h3><ol><li><p>常规存储器管理方式具有哪两大特征？它对系统性能有何影响？</p><ul><li>一次性：进程（作业）必须<strong>一次性地全部装入内存</strong>，对空间浪费非常大；</li><li>驻留性：在程序<strong>运行过程中</strong>，进程（作业）全部<strong>驻留在内存</strong>，暂时不用的数据无法释放，占用内存资源。</li></ul></li><li><p>什么是程序运行时的时间局限性和空间局限性？</p><ul><li>时间局限性：<ul><li>如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久的将来<strong>该存储单元</strong>可能再次被访问。</li><li>产生时间局限性的典型原因是在程序中存在着大量的循环操作。</li></ul></li><li>空间局限性：<ul><li>一旦程序访问了某个存储单元，则在不久的将来，其<strong>附近的存储单元</strong>也最有可能被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围内。</li><li>产生空间局限性的典型原因是程序是顺序执行的。</li></ul></li></ul></li><li><p>虚拟存储器有哪些特征？其中最本质的特征是什么？</p><ul><li>虚拟存储器有<strong>多次性、对换性、虚拟性</strong>三大特征。</li><li><strong>多次性</strong>：多次性是相对于传统存储器管理方式而言地，是指一个作业中地程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行，即只需将当前要运行地那部分程序和数据装入内存即可开始运行。</li><li><strong>对换性</strong>：对换性是相对于传统存储器管理方式的常驻性而言，是指一个作业中的程序和数据，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出。</li><li><strong>虚拟性</strong>：虚拟性是指能够从逻辑上扩充内存容量，使用户看到的内存内容远大于实际内存容量。</li><li>最本质的特征是<strong>虚拟性</strong>。</li></ul></li><li><p>实现虚拟存储器需要哪些硬件支持?</p><ul><li>请求分页（段）的页（段）表机制。</li><li>缺页（段）中断机构。</li><li>地址变换机构。</li></ul></li><li><p>实现虚拟存储器需要哪几个关键技术?</p><ul><li>在分页请求系统中是在分页的基础上，增加了<strong>请求调页功能和页面置换功能</strong>所形成的页式虚拟存储系统。允许只装入少数页面的程序（及数据），即可启动运行。</li><li>在请求分段系统中是在分段系统的基础上，增加了<strong>请求调段及分段置换功能</strong>后形成的段式虚拟存储系统。允许只装入少数段（而非所有段）的用户程序和数据，即可启动运行。</li></ul></li><li><p>在请求分页系统中，页表应包括哪些数据项？每项的作用是什么?</p><ul><li>页表应包括：<strong>页号、物理块号、状态位P、访问字段A、修改位M和外存地址</strong>。</li><li>其中状态位P指示该页<strong>是否调入内存</strong>，供程序访问时参考；</li><li>访问字段A用于记录本页在一段时间内<strong>被访问的次数</strong>，或最近<strong>己有多长时间未被访问</strong>，提供给置换算法选择换出页面时参考；</li><li>修改位M表示该页在调入内存后<strong>是否被修改过</strong>；</li><li>外存地址用于指出<strong>该页在外存上的地址</strong>，通常是物理块号，供调入该页时使用。</li></ul></li><li><p>试比较缺页中断机构与一般的中断，它们之间有何明显的区别？</p><ul><li>一般中断只需要保护现场然后就直接跳到需及时处理的地方。</li><li>缺页中断除了保护现场之外，还要判断内存中是否有足够的空间存储所需的页或段，然后再把所需页调进来再使用。</li></ul></li><li><p>试说明请求分页系统中的地址变换过程。<br><img src="https://pic.zty.plus/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.jpg" alt="请求分页地址变换"></p><ul><li>取逻辑地址分解为页号P和页内偏移w；</li><li>根据页号查找页表，获得该页的描述信息；</li><li>若该页中断位为1，产生缺页中断；　　</li><li>更新该页的描述信息；</li><li>根据页块号和页内偏移w，计算物理地址。</li><li>P170</li></ul></li><li><p>何谓固定分配局部置换和可变分配全局置换的内存分配策略?</p><ul><li>固定分配局部置换：<ul><li>固定分配是指，为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。</li><li>局部置换是指，如果进程在运行中发现缺页，则只能从分配给<strong>该进程的</strong>n个页面中，选出一页换出，然后再调入一页。</li></ul></li><li>可变分配全局置换：<ul><li>可变分配是指，先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地改变。</li><li>全局置换是指，如果进程在运行中发现缺页，则将<strong>OS所保留的空闲物理块</strong>或者以<strong>所有进程的全部物理块为标的</strong>，选择一块换出，然后将所缺之页调入。</li></ul></li></ul></li><li><p>在请求分页系统中，应从何处将所需页面调入内存？</p><ul><li>请求分页系统中的缺页从何处调入内存分三种情况：<ul><li><strong>系统拥有足够对换区空间时</strong>，可以全部从对换区调入所需页面，提高调页速度。在进程运行前将与该进程有关的文件从文件区拷贝到对换区。</li><li><strong>系统缺少足够对换区空间时</strong>，不被修改的文件直接从文件区调入，当换出这些页面时，未被修改的不必换出，再调入时，仍从文件区直接调入。对于可能修改的，在换出时便调到对换区，以后需要时再从对换区调入。</li><li><strong>UNIX方式</strong>。未运行页面从文件区调入。曾经运行过但被换出页面，下次从对换区调入。UNIX系统允许页面共享，某进程请求的页面有可能已调入内存，直接使用不再调入。</li></ul></li></ul></li><li><p>试说明在请求分页系统中页面的调入过程。</p><ul><li>每当程序所要访问的页面未在内存时（存在位为“0”），便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。</li><li>该程序通过查找页表，得到该页在外存的物理块后：<ul><li>如果此时内存能容纳新页，则启动磁盘I/O，将所缺之页调入内存，然后修改页表。</li><li>如果内存已满，则须先按照某种置换算法，从内存中选出一页准备换出；<ul><li>如果该页未被修改过（修改位为“0”），可不必将该页写回磁盘；</li><li>但如果此页已被修改（修改位为“1”），则必须将它写回磁盘，然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中。</li></ul></li></ul></li><li>在缺页调入内存后，利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据。整个页面的调入过程对用户是透明的。</li></ul></li><li><p>在请求分页系统中，常采用哪几种页面置换算法？</p><ul><li>采用的页面置换算法有：<ul><li>最佳（Optimal）置换算法和先进先出（FIFO）置换算法，最近最久未使用（LRU）置换算法，最少使用（LFU）置换算法，Clock置换算法，页面缓冲算法（PBA）等。</li></ul></li></ul></li><li><p>在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。</p><ul><li>M=3时，采用FIFO页面置换算法的缺页次数为9次，缺页率为75%；</li><li>M=4时，采用FIFO页面置换算法的缺页次数为10次，缺页率为83%。</li><li>增加分配给作业的内存块数，反而增加了缺页次数，提高了缺页率，这种现象被称为是Belady现象。</li></ul></li><li><p>实现LRU算法所需的硬件支持是什么？</p><ul><li>需要寄存器和栈两类硬件之一的支持。<ul><li>寄存器：<ul><li>给在内存中的每个页配置移位寄存器，当进程访问某物理块时，将相应寄存器的Rn-1位置1，此时，定时每隔一定时间将寄存器右移一位。最小数值对应的页面就是最近最久未使用的页面。</li></ul></li><li>栈：<ul><li>利用一个特殊栈保存当前使用的各页面的页面号，每当进程访问某页面时将该页面的页面号从栈中移出，将它压入栈顶。因此栈顶始终时最新被访问的页面的编号，栈底则是最近最久未使用的页面的页面号。</li></ul></li></ul></li></ul></li><li><p>试说明改进型Clock置换算法的基本原理。</p><ul><li>因为修改过的页面在换出时付出的开销比未被修改过的页面大，在改进型Clock算法中，既考虑页面的使用情况，还要增加<strong>置换代价</strong>的因素；在选择页面作为淘汰页面时，把同时满足<strong>未使用过</strong>和<strong>未被修改</strong>作为首选淘汰页面。</li></ul></li><li><p>影响页面换进换出效率的若干因素是什么？</p><ul><li><strong>页面置换算法</strong>：影响页面换进换出效率最重要的因素，直接影响进程在运行过程中的缺页率，影响页面换进换出的开销。</li><li><strong>写回磁盘的频率</strong>：如果是采取每个页面换出时，就将它写回磁盘的策略，这意味着每换出一个页面，便需要启动一次磁盘。但如果在系统中建立了一个已修改换出页面链表，对每一个要被换出的页面（已修改），系统可暂不把它们写回磁盘，而是将它们挂在已修改换出页面链表上，仅当被换出页面数目达到一定值时，再将它们一起写回到磁盘上，这样就显著地<strong><em>减少了磁盘I/O的操作次数</em></strong>。或者说，减少已修改页面换出的开销。</li><li><strong>读入内存的频率</strong>：在设置了已修改换出页面链表后，在该链表上就暂时有一批装有数据的页面，如果需要再次访问这些页面时，就不需从外存上调入，而直接从已修改换出页面链表中获取，这样也可以<strong><em>减少将页面从磁盘读入内存的频率</em></strong>，减少页面换进的开销。或者说，只需花费很小的开销，便可使这些页面，又回到该进程的驻留集中。</li></ul></li><li><p>页面缓冲算法的主要特点是什么？它是如何降低页面换进换出的频率的？</p><ul><li>显著地降低了页面换进、换出的频率，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销；</li><li>由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如先进先出（FIFO）算法，它不需要特殊硬件的支持，实现起来非常简单。</li><li>在该系统中，内存分配策略上采用了<strong>可变分配</strong>和<strong>局部置换方式</strong>。<ul><li><a href="https://www.cnblogs.com/mahuangping/p/5468577.html">请求分页中的内存分配方式</a></li></ul></li><li>为了能显著地降低了页面换进、换出的频率，在内存中设置了如下两个链表：<ul><li><strong>空闲页面链表</strong>：是一个空闲物理块链表，用于分配给频繁发生缺页的进程，以降低该进程的缺页率。当有一个未被修改的页要换出时，实际上并不将它换出到外存，而是把它们所在的物理块，挂在空闲链表的末尾。</li><li><strong>修改页面链表</strong>：由已修改的页面所形成的链表。设置该链表的目的，是为了减少已修改页面换出的次数。降低将已修该页面写回磁盘的频率，以及降低将磁盘内容读入内存的频率。</li></ul></li></ul></li><li><p>在请求分页系统中产生抖动的原因是什么？</p><ul><li><strong>抖动（Thrashing)</strong> ：<ul><li>指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页程序或数据送磁盘的对换区中，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此<strong>频繁更换页面</strong>，使得<strong>系统把大部分时间用在了页面的调进换出上</strong>，而几乎不能完成任何有效的工作，我们称这种现象为”抖动”。</li></ul></li><li>产生抖动的原因：<ul><li><strong>CPU的利用率和多道程序度的对立统一矛盾关系</strong>，为了提高CPU利用率，可提高多道程序度，但单纯提高多道程序度又会造成缺页率的急剧上升，导致CPU的利用率下降，而系统的调度程序又会为了提高CPU利用率而继续提高多道程序度，形成恶性循环，我们称这时的进程是处于”抖动”状态。</li></ul></li></ul></li><li><p>何谓工作集？它是基于什么原理确定的？</p><ul><li>工作集:<ul><li><strong>某段时间间隔内，进程要访问的页面集合</strong>。</li><li>工作集可用于指导驻留集大小。</li></ul></li><li>驻留集：<ul><li><strong>进程已装入内存的页面的集合</strong>，与系统采用的页面装入和页面置换算法有关。</li><li>经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。为了防止系统出现抖动现象，需要选择合适的驻留集体大小。</li><li>驻留集尺寸：<ul><li>进程驻留在内存中的页面数量，与系统采用的页面分配策略有关。</li></ul></li></ul></li><li>工作集模型的原理：<ul><li>让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。</li><li>如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</li><li>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</li></ul></li><li>不同提法：<ul><li><a href="https://blog.csdn.net/qq_43101637/article/details/106672208">工作集≠驻留集</a></li><li><a href="https://blog.csdn.net/gettogetto/article/details/56005716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">工作集=驻留集</a></li></ul></li></ul></li><li><p>当前可以利用哪几种方法来防止“抖动”？</p><ul><li>采取局部置换策略<ul><li>将”抖动”影响限制在较小范围内，但效果不太好，”抖动“发生后该进程会长期在磁盘I/O的等待队列中，还是会延长其它进程的缺页中断处理时间。</li></ul></li><li>把工作集算法融入到处理机调度中<ul><li>调入新作业前，必须检查每个进程在内存驻留的页面是否足够多。若是则可调入，若不是则应首先增加缺页率居高的作业的物理块。</li></ul></li><li>利用“L=S”准则调节缺页率<ul><li>L：缺页之间的平均时间，S：平均缺页服务时间（置换一个页面所需的时间）。</li><li>L远大于S：很少缺页，磁盘能力未得到充分利用；S大于L：频繁缺页，缺页速度超过磁盘处理能力；L=S：磁盘和处理机达到最大利用率。</li></ul></li><li>选择暂停的进程<ul><li>多道程序度偏高时，影响处理机利用率，为防止发生”抖动“，系统必须减少多道程序的数目。</li></ul></li></ul></li><li><p>试试说明如何利用“L=S”准则来调节缺页率，以避免“抖动”的发生?</p><ul><li>L：缺页之间的平均时间，S：平均缺页服务时间（置换一个页面所需的时间）。</li><li>L远大于S：很少缺页，磁盘能力未得到充分利用；S大于L：频繁缺页，缺页速度超过磁盘处理能力；L=S：磁盘和处理机达到最大利用率。</li></ul></li><li><p>为了实现请求分段式存储管理，应在系统中增加配置哪些硬件结构？</p><ul><li>请求段表机制、缺段中断机制和地址变换机构。</li></ul></li><li><p>在请求段表机制中，应设置哪些段表项？<br>| 段名 | 段长 | 段基址 | 存取方式 | 访问字段A | 修改位M | 存在位P | 增补位 | 外存始址 |<br>| —— | —— | ——— | ———— | ————- | ———- | ———- | ——— | ———— |</p></li><li><p>说明请求分段系统中的缺页中断处理过程。</p><ul><li><img src="https://pic.zty.plus/%E7%BC%BA%E6%AE%B5%E4%B8%AD%E6%96%AD.png" alt="缺段中断"></li></ul></li><li><p>请对共享段表中的各项作简要说明。</p><ul><li><img src="https://pic.zty.plus/%E5%85%B1%E4%BA%AB%E6%AE%B5%E8%A1%A8%E9%A1%B9.png" alt="共享段表项"></li><li>共享进程计数器count：<ul><li>记录有多少进程正在共享该分段，当某进程不再需要它时，检查是否为0，从而决定系统是否回收该段所占的内存区。</li></ul></li><li>存取控制字段：<ul><li>为不同进程赋予不同的存取权限（读写）。</li></ul></li><li>段号：<ul><li>对于一个共享段，在不同的进程中可以具有不同的段号，每个进程可用自己的段号去访问该共享段。</li></ul></li></ul></li><li><p>如何实现共享分段的分配和回收?</p><ul><li>共享段的分配：<ul><li>在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，当又有其它进程需要调用该共享段时，无须再为该段分配内存。</li></ul></li><li>共享段的回收：<ul><li>当共享此段的某进程不再需要该段时，若无其他进程使用该段，则由系统回收该共享段的物理内存，否则只是取消调用者进程在共享段表中的有关记录。</li></ul></li></ul></li></ol><h3 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h3><ol><li><p>试说明I/O系统的基本功能。</p><ul><li>隐藏物理设备的细节</li><li>与设备的无关性</li><li>提高处理机和I/O设备的利用率</li><li>对I/O设备进行控制e.确保对设备的正确共享</li><li>错误处理</li></ul></li><li><p>简要说明I/O软件的4个层次的基本功能。</p><ul><li><strong>中断处理程序：</strong><ul><li>用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后恢复现场，并返回到被中断的进程。</li></ul></li><li><strong>设备驱动程序：</strong><ul><li>与硬件直接有关，用来具体实现系统对设备发出的操作指令，驱动I/O设备工作。</li></ul></li><li><strong>设备独立性软件：</strong><ul><li>用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等。</li></ul></li><li><strong>用户层I/O软件：</strong><ul><li>用于实现用户与I/O设备交互。</li></ul></li></ul></li><li><p>I/O系统接口与软件/硬件（RW/HW）接口分别是什么接口?</p><ul><li><strong>I/O系统接口：</strong><ul><li>I/O系统接口是I/O系统与<strong>上层系统</strong>之间的接口，向上层提供对设备进行操作的抽象I/O命令，以<strong>方便高层对设备的使用</strong>。</li></ul></li><li><strong>软件/硬件（RW/HW）接口：</strong><ul><li>软件/硬件（RW/HW）接口的上面是<strong>中断处理程序</strong>和用于不同设备的<strong>设备驱动程序</strong>，它的下面是各种<strong>设备的控制器</strong>。</li></ul></li></ul></li><li><p>与设备无关性的基本含义是什么？为什么要设置该层？</p><ul><li>基本含义：<ul><li>应用程序独立于具体使用的物理设备。</li><li>为了实现设备独立性而引入了逻辑设备和物理设备两概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，还必须使用物理设备名称。</li></ul></li><li>设置原因：<ul><li>为了提高0S的可适应性和可扩展性，在现代0S中都毫无例外地实现了设备独立性，也称设备无关性。</li></ul></li><li>优点：<ul><li>增加了设备分配时的灵活性。</li><li>易于实现I/O重定向（用于I/O操作的设备可以更换（即重定向），而不必改变应用程序。</li></ul></li></ul></li><li><p>试说明设备控制器的组成。</p><ul><li>设备控制器与处理机的接口；</li><li>设备控制器与设备的接口；</li><li>I/O逻辑。</li></ul></li><li><p>为了实现CPU与设备控制器之间的通信，设备控制器应该具备哪些功能?</p><ul><li>基本功能：接收和识别命令；数据交换；标识和报告设备的状态；地址识别；数据缓冲；差错控制。</li></ul></li><li><p>什么是内存映像I/O？它是如何实现的？</p><ul><li>驱动程序将抽象I/O命令转换出的一系列具体的命令、参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的控制。这一工作可用两种方法来完成：利用特定的I/O指令、内存I/O映像。</li><li>内存映像I/O：<ul><li>在编址上<strong>不再区分</strong>内存单元地址和设备控制器中的寄存器地址，都采用k。当k值处于0~n-1范围时，被认为是内存地址，若k≥n时，被认为是某个控制器的寄存器地址。</li><li>内存映像I/O方式统一了对内存和对控制器的访问方法，简化了I/O的编程。</li></ul></li></ul></li><li><p>为什么说中断是0S赖以生存的基础？</p><ul><li>中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，没有中断，就不可能实现多道程序，因为<strong>进程之间的切换是通过中断来完成的</strong>。</li><li>另一方面，中断也是<strong>设备管理的基础</strong>，为了提高处理机的利用率和实现CPU和I/O设备并执行，也必需有中断的支持。中断处理程序是I/O系统中最低的一层。</li></ul></li><li><p>对中断源的两种处理方式分别用于那种场合？</p><ul><li>屏蔽（禁止)中断：<ul><li>当处理机正在处理一个中断时，将屏蔽掉所有的中断，直到处理机已处理完本次中断，再去检查是否有中断产生。所有中断按顺序处理，优点是简单，但不能用于实时性要求较高的中断请求。</li></ul></li><li>嵌套中断：<ul><li>在设置了中断优先级的系统中，当同时有多个不同优先级的中断请求，CPU优先响应优先级最高的中断请求，高优先级的中断请求可以抢占正在运行的低优先级中断的处理机。</li></ul></li></ul></li><li><p>设备中断处理程序通常需完成哪些工作？</p><ul><li>唤醒被阻塞的驱动进程。</li><li>保护被中断进程的CPU环境。</li><li>转入相应的设备处理程序。</li><li>中断处理。</li><li>恢复被中断进程的现场。</li></ul></li><li><p>简要说明中断处理程序对中断进行处理的几个步骤。</p><ul><li>测定是否有未响应的中断信号</li><li>唤醒被阻塞的驱动进程。</li><li>保护被中断进程的CPU环境</li><li>转入相应的设备处理程序</li><li>中断处理</li><li>恢复CPU的现场并退出中断</li></ul></li><li><p>试说明设备驱动程序具有哪些特点。</p><ul><li>驱动程序是请求I/O进程（与设备无关的软件）与设备控制器间的一个通信和转换程序。</li><li>驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，不同类型的设备应配置不同的驱动程序。</li><li>驱动程序与I/O设备采用的控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。</li><li>由于驱动程序与硬件紧密相关，部分程序必须用汇编语言书写，很多驱动程序的基本部分往往固化在ROM中。</li><li>驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。</li></ul></li><li><p>设备驱动程序通常需要完成哪些工作？</p><ul><li>接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。</li><li>检查用户I/O请求合法性，了解I/O设备状态，传递有关参数，设置设备工作方式。</li><li>发出I/O命令，如果设备空闲，便启动分配到的I/O设备，完成指定I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。</li><li>及时响应由控制器或通道发来的中断请求，根据中断类型调用相应中断处理程序处理。</li><li>对于有通道的计算机，驱动程序还应该根据用户I/O请求自动构成通道程序。</li></ul></li><li><p>简要说明设备驱动程序的处理过程可分为哪几步。</p><ul><li>将抽象要求转换为具体要求</li><li>对服务请求进行校验</li><li>检查设备的状态</li><li>传送必要的参数</li><li>启动I/O设备</li></ul></li><li><p>试说明I/O控制发展的主要推动因素是什么？</p><ul><li>尽量减少CPU对I/O控制的干预，把CPU从繁杂的I/O控制中解脱出来，以便更多地去完成数据处理任务。</li><li>缓和CPU的高速性和设备的低速性之间速度不匹配的矛盾，以提高CPU的利用率和系统的吞吐量。</li><li>提高CPU和I/O设备操作的并行程度，使CPU和I/O设备都处于忙碌状态，从而提高整个系统的资源利用率和系统吞吐量。</li></ul></li><li><p>有哪几种I/O控制方式？各适用于何种场合？</p><ul><li><strong>程序 I/O 方式、中断驱动 I/O 控制方式、DMA I/O 控制方式、I/O 通道控制方式</strong>。</li><li><strong>程序 I/O 方式（使用轮询的可编程 I/O 方式）</strong>，以字（符）为单位进行I/O，适用于早期的计算机系统中，并且是无中断的计算机系统。</li><li><strong>中断驱动 I/O 控制方式（使用中断的可编程 I/O 方式）</strong>，以字（节）为单位进行I/O，是普遍用于现代的计算机系统中。</li><li><strong>DMA I/O 控制方式（直接存储器访问方式）</strong>，数据传输基本单位是<strong>数据块</strong>，适用于I/O设备为块设备时在和主机进行数据交换的一种I/O控制方式。</li><li>当I/O设备和主机进行数据交换是<strong>一组数据块</strong>时通常采用<strong>I/O通道控制方式</strong>（DMA方式的发展），但此时要求系统必须配置相应的通道及通道控制器。</li></ul></li><li><p>试说明DMA的工作流程。</p><ul><li>DMA是Direct Memory Access的缩写，意为存储器直接访问。可以不通过CPU而在DMA控制器的控制下，高速地与I/O设备和存储器之间交换数据。</li><li>CPU需要访问外存时便发送一条访问命令给DMA的<strong>命令寄存器CR</strong>、一个内存地址码给DMA的内存<strong>地址寄存器MAR</strong>、本次要传送的字（节）数给DMA的<strong>数据计数器DC</strong>、外存地址给DMA的<strong>I/O控制逻辑</strong>。</li><li>CPU启动DMA控制器后转向其他处理。</li><li>DMA控制器负责控制数据在内存与外设之间传送。每传送一个字（节）就需挪用一个存储器周期，按MAR从内存读出或写入内存一个字（节），修改MAR和计算器DC。</li><li>当DC修改为0时，表示传送结束，由DMA向CPU发出中断请求。<br><img src="https://pic.zty.plus/DMA%E6%B5%81%E7%A8%8B.png" alt="DMA流程"></li></ul></li><li><p>为什么要引入与设备的无关性?如何实现设备的独立性？</p><ul><li>设备无关性（独立性）的基本含义是应用程序独立于具体使用的物理设备，应用程序以逻辑设备名请求使用某类设备。</li><li>引入原因：<ul><li>为了方便用户和提高OS的可适应性与可扩展性。</li><li>实现了设备独立性功能可带来两方面的好处：<ul><li>设备分配时的灵活性。</li><li>易于实现I/O重定向。</li></ul></li></ul></li><li>如何实现：<ul><li>为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中，使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件，必须在驱动程序之上设置一层<strong>设备独立性软件</strong>，执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件<strong>提供统一接口</strong>，从而实现设备的独立性。</li></ul></li></ul></li><li><p>与设备的无关的软件中，包括了哪些公有操作的软件?</p><ul><li>设备驱动程序的统一接口</li><li>缓冲管理</li><li>差错控制</li><li>对独立设备的分配与回收</li><li>独立于设备的逻辑数据块</li></ul></li><li><p>在考虑到设备的独立性时，应如何分配独占设备？</p><ul><li>进程以逻辑设备名提出I/O请求。</li><li>根据逻辑设备表获得I/O请求的逻辑设备对应物理设备在系统设备表中的指针。</li><li>检索系统设备表，找到属于请求类型、空闲可用且分配安全设备的设备控制表，将对应设备分配给请求进程。如果未找到安全可用的空闲设备，则把请求进程的进程控制块挂到相应类型设备的等待队列上等待唤醒和分配。</li><li>到设备控制表中找出与其相连接的控制器的控制器控制表，根据状态字段判断是否忙 碌，忙则等待；否则将该控制器分配给进程。</li><li>到该控制器的控制器控制表中找出与其相连接的通道的通道控制表，判断通道是否忙 碌，忙则等待；否则将该通道分配给进程。</li><li>只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功，然后便可启 动设备进行数据传送。</li></ul></li><li><p>何谓设备虚拟？实现设备虚拟式所依赖的关键技术是什么？</p><ul><li>通过虚拟技术可将一台独占设备变换成若干台逻辑设备，供若干个用户（进程）同时使用，通常把这种经过虚拟技术处理后的设备称为虚拟设备。</li><li>其实现所依赖的关键技术是SPOOLING技术。</li></ul></li><li><p>在实现后台打印时，SPOOLing 系统应为请求I/O的进程提供哪些服务？</p><ul><li>由输出进程在输出井中为之申请一空闲盘块区，并将要打印的数据送入其中；</li><li>输出进程再为用户进程申请一张空白的用户打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。</li><li>一旦打印机空闲，输出进程便从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据从输出井传送到内存缓冲区，再由打印机进行打印。</li></ul></li><li><p>假脱机系统向用户提供共享打印机的基本思想是什么？</p><ul><li>对每个用户而言，系统并非及时执行其程序输出数据的真实打印操作，而只是即时将数据输出到缓冲区，这时的数据并未真正被打印，只是让用户感觉系统已为他打印；</li><li>真正的打印操作，是在打印机空闲且该打印任务在等待队列中已排到队首时进行的；以上过程是对用户屏蔽的，用户是不可见的。</li></ul></li><li><p>引入缓冲的主要原因是什么？</p><ul><li>缓和CPU与I/O设备之间速度不匹配的矛盾；</li><li>减少对CPU的中断频率，放宽对中断响应时间的限制；</li><li>解决数据粒度（数据单元大小）不匹配的问题；</li><li>提高CPU和I/O设备之间的并行性。</li></ul></li><li><p>在单缓冲情况下，为什么系统对一块数据的处理时间为$Max(C,T)+M$？</p><ul><li>在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T；</li><li>操作系统将缓冲区数据传送给用户区的时间为M；</li><li>而CPU对这一块数据进行计算得时间为C。</li><li>在单缓冲情况下，由于<strong>设备的输入操作</strong>和<strong>CPU的处理操作</strong>可以<strong>并行</strong>，所以系统对每一整块数据的处理时间为 $Max(C,T)+M$。</li></ul></li><li><p>为什么在双缓冲情况下，系统对一块数据的处理时间为$Max(C,T)$？</p><ul><li>该方式又称<strong>缓冲对换</strong>方式，在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。</li><li>此时操作系统可以从第一缓冲区移出数据，并送入用户进程。</li><li>接着由CPU对数据进行计算。</li><li>在双缓冲区中，不仅<strong>设备的输入操作</strong>和<strong>CPU的处理操作</strong>可以并行，<strong>设备的输入操作</strong>和<strong>数据的传送操作</strong>也可以并行，因此耗时大约为$Max(C,T)$。考虑到M是内存中数据块的“搬家”耗时，非常短暂可以省略，因此<strong>近似地</strong>认为是：$Max(C,T)$。</li></ul></li><li><p>试绘图说明把多缓冲用于输出时的情况。<br><img src="https://pic.zty.plus/%E5%8F%8C%E7%BC%93%E5%86%B2.png" alt="双缓冲"></p></li><li><p>试说明收容输入工作缓冲区和提取输出工作缓冲区的工作情况。</p><ul><li>收容输入工作缓冲区的工作情况为：<ul><li>在输入进程需要输入数据时，调用GetBuf（EmptyQueue)过程，从EmptyQueue队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区Hin。</li><li>然后把数据输入其中，装满后再调用PutBuf（InputQueue,Hin)过程，将该缓冲区挂在输入队列InputQueue的队尾。</li></ul></li><li>提取输出工作缓冲区的工作情况为：<ul><li>当要输出数据时，调用GetBuf（OutputQueue)过程，从输出队列的队首取得一装满输出数据的缓冲区作为提取输出工作缓冲区Sout。</li><li>在数据提取完后，再调用PutBuf(EmptyQueue,Sout)过程，将该缓冲区挂到空缓冲队列EmptyQueue的队尾。</li></ul></li></ul></li><li><p>何谓安全分配方式和不安全分配方式？</p><ul><li>安全分配方式是指每当进程发出I/0请求后，便进入阻塞状态，直到其I/0操作完成时才被唤醒。<ul><li>在采用这种分配策略时，一旦进程已获得某种设备资源后便阻塞，使它不可能再请求任何资源，而在它运行时又不保持任何资源。这种分配方式已经摒弃了造成死锁的“<strong>请求和保持</strong>”条件，分配是安全的。缺点是进程进展缓慢，CPU与I/0设备<strong>串行</strong>工作。</li></ul></li><li>不安全分配方式是指进程发出I/0请求后仍继续执行，需要时又可发出第二个I/0请求、第三个I/0请求。仅当进程请求的设备已被另一个进程占有时，进程才进入阻塞状态。<ul><li>优点是一个进程可同时操作多个设备，进程推进迅速。缺点是分配不安全，可能具有“<strong>请求和保持</strong>”条件，可能造成死锁。因此，在设备分配程序中需增加一个功能，用于对本次的设备分配是否会发生死锁进行安全性计算，仅当计算结果表明分配安全的情况下才进行分配。</li></ul></li></ul></li><li><p>磁盘访问时间由哪几部分组成？每部分时间应如何计算？</p><ul><li>磁盘访问时间由<strong>寻道时间$T_s$</strong>、<strong>旋转延迟时间$T_\tau$</strong>、<strong>传输时间$T_t$</strong> 三部分组成。<ul><li>$T_s$是<strong>启动磁臂时间 s</strong> 与<strong>磁头移动 n 条磁道的时间</strong>和，即$T_s=m×n+s$。</li><li>$T<em>\tau$是指定<strong>扇区移动到磁头下面所经历的时间</strong>，即$T</em>\tau=1/2r$。<ul><li>硬盘$15000r/min$时，每转需时$4ms$$T<em>r$为$2ms$；软盘$300$或$600r/min$时$T</em>\tau$为$50$~$100ms$。</li></ul></li><li>$T_t$是指<strong>数据从磁盘读出或向磁盘写入经历的时间</strong>，即$T_t=b/rN$。<ul><li>$T<em>t$的大小与每次读/写的字节数 <strong>b</strong> 和旋转速度 <strong>r</strong> 有关，<strong>N</strong> 为一条磁道上的字节数，其中当一次读/写的字节数相当于半条磁道上的字节数时 $T</em>\tau=T_t$。</li></ul></li></ul></li><li>因此访问时间：$T_a=T_s+\frac{1}{2r}+\frac{b}{rN}$</li></ul></li><li><p>目前常用的磁盘调度算法有哪几种？每种算法优先考虑的问题是什么？</p><ul><li>目前常用的磁盘调度算法有<strong>先来先服务</strong>（FCFS）、<strong>最短寻道时间优先</strong>（SSTF）及<strong>扫描</strong>（SCAN）等算法。<ul><li>先来先服务算法优先考虑<strong>进程请求访问磁盘的先后次序</strong>。</li><li>最短寻道时间优先（Shortest Seek Time First）算法优先考虑<strong>要求访问的磁道与当前磁头所在磁道距离是否最近</strong>。</li><li>扫描算法考虑欲访问的磁道与当前磁道间的距离，更优先<strong>考虑磁头当前的移动方向</strong>。</li></ul></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;西安电子科技大学出版社出版的&lt;strong&gt;计算机操作系统（第四版）&lt;/strong&gt;课后习题整理&lt;/li&gt;
&lt;li&gt;作者：汤小丹 梁红兵 哲凤屏 汤子瀛&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第一章-操作系统引论&quot;&gt;&lt;a href=&quot;#第一章-操作系统引论&quot; class=&quot;headerlink&quot; title=&quot;第一章 操作系统引论&quot;&gt;&lt;/a&gt;第一章 操作系统引论&lt;/h3&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统-课后习题" scheme="http://tianyuzhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://tianyuzhou.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://tianyuzhou.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-30T12:38:07.000Z</published>
    <updated>2021-02-17T13:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="分区、分段、段页式"><a href="#分区、分段、段页式" class="headerlink" title="分区、分段、段页式"></a>分区、分段、段页式</h3><ul><li><p>操作系进行内存管理的原因</p><ul><li>划分内存而满足多道程序的需求。</li><li>内存需要被高效地分配而能够装入尽可能多的进程。</li></ul></li><li><p>分类</p><ul><li>连续：分区</li><li>离散：分段、分页</li></ul></li></ul><span id="more"></span><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><ul><li>系统初始启动时将内存划分为<strong>数目固定</strong>、<strong>尺寸固定</strong>的多个分区。</li><li>这些分区的尺寸可以相等也可以不等。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><em>特点</em></h4><ul><li>如果一个程序太大而不能进入分区需要<strong>程序员</strong>使用<a href="http://c.biancheng.net/cpp/html/2609.html">覆盖技术</a>（早期计算机系统）设计程序。</li><li>内存使用不够高效。无论程序多小必须占据整个分区，这被称为内零头（内部碎片）。</li><li>以上问题虽然可以通过大小不相等的分区设计加上算法减小影响，但是不能根治问题。</li><li>优点<ul><li>实现简单。</li><li>系统开销小。</li></ul></li><li>缺点<ul><li>存在内零头，存储利用率不高。</li><li>分区尺寸固定，系统无法运行大程序。</li><li>分区数目固定，活动的进程数目受限。</li></ul></li></ul><h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><ul><li>分区的大小和数量多样。</li><li>进程可以分配到精确的所需的内存大小。</li><li>会在内存中产生很多“小空隙”，称为外零头。</li><li>必须使用<strong>紧凑技术</strong>，调整进程使它们相邻，从而拼接所有较小的空闲内存形成一块较大的。</li><li>动态分区消除了内零头，却产生了外零头。</li></ul><h3 id="简单分页"><a href="#简单分页" class="headerlink" title="简单分页"></a>简单分页</h3><ul><li>内存被分为大小相等的块，每一个进程被分成和内存块相等大小的块。</li><li>这些进程的块，被称为页而内存的块被称为页帧（页框）。</li><li>没有外零头，仅有很少的内零头出现在进程的最后一页。</li></ul><h4 id="分页系统地址转换"><a href="#分页系统地址转换" class="headerlink" title="分页系统地址转换"></a><em>分页系统地址转换</em></h4><ul><li>根据逻辑地址及页大小求出页号和页内偏移量。</li><li>用页号检索页表，查找页对应的页框号。</li><li>根据页框号、页内偏移以及页框尺寸求出物理地址。</li></ul><h3 id="简单分段"><a href="#简单分段" class="headerlink" title="简单分段"></a>简单分段</h3><ul><li>基于模块化设计时，程序员根据需要将<strong>进程</strong>分割成许多大小不一的<strong>段</strong>，系统则将<strong>物理内存</strong>动太划分成许多尺寸不一定相等的<strong>部分</strong>。</li><li>当一个进程装入物理内存时，系统将该进程的每个段独立分配一个分区；同一进程的多个段<strong>不必</strong>存放在<strong>连续的</strong>多个分区中。</li><li>没有内部碎片，比较与动态分区，内存利用率更高，开销小。</li></ul><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><h4 id="区别和对比"><a href="#区别和对比" class="headerlink" title="区别和对比"></a><em>区别和对比</em></h4><ul><li>页面是信息的物理单位；在特定的系统中，其大小是固定不变的，不随进程的不同而不同。</li><li>段是信息的逻辑单位，其长度不定；即使是属于同一进程的两个段长度也可能不等。</li><li>分页活动源于系统管理物理内存的需要，在<strong>系统内部</strong>进行，由系统实施，用户看不见。</li><li>分段活动源于用户进行模块化程序设计的需要，在<strong>系统外部</strong>进行，由用户实施，用户是知道的。</li><li>在分页系统中，逻辑地址是一维的。</li><li>在分段系统中，逻辑地址是二维或多维的。<ul><li><a href="https://blog.csdn.net/qq_32534441/article/details/88980842?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.pc_relevant_is_cache&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.pc_relevant_is_cache">怎样理解这里的一维和二维?</a></li></ul></li></ul><h4 id="段页式为什么存在"><a href="#段页式为什么存在" class="headerlink" title="段页式为什么存在"></a><em>段页式为什么存在</em></h4><ul><li>分页系统中，内零头得到了有效的抑制，外零头则被完全消除；因此使用分页技术可以提高物理内存的利用率。</li><li>分段系统中，动态数据结构、程序和数据共享、程序和数据保护等问题得到了妥善的解决；因此，分段技术有利于模块化程序设计。</li><li>段页技术汲取了分页技术和分段技术的上述优点。</li></ul><h4 id="如何划分"><a href="#如何划分" class="headerlink" title="如何划分"></a><em>如何划分</em></h4><ul><li>在段页存储管理系统当中，每个进程均被编程人员分割成多个<strong>段</strong>，每个段又被系统分割成多个<strong>页</strong>。</li><li>相应的，物理内存被系统划分成多个<strong>页框（页帧）</strong>。</li><li>当一个进程装入物理内存时，系统为该进程的每个段的各页面独立地分配一个<strong>页框</strong>；一个进程的同一段的多个页面不必存放在连续的多个页框中。</li></ul><h3 id="虚拟内存分页"><a href="#虚拟内存分页" class="headerlink" title="虚拟内存分页"></a>虚拟内存分页</h3><ul><li>与简单分页相比，不需要将进程所有的页装入主存。</li><li>优点<ul><li>没有外部碎片。</li><li>巨大的虚拟内存空间。</li><li>更高程度的多道程序设计。</li></ul></li><li>缺点<ul><li>复杂的内存管理开销。</li></ul></li></ul><h3 id="虚拟内存分段"><a href="#虚拟内存分段" class="headerlink" title="虚拟内存分段"></a>虚拟内存分段</h3><ul><li>与简单分段相比，不需要进程所有的段都装入主存。</li><li>优点<ul><li>具有虚拟内存分段的三个优点，并支持保护和共享。</li></ul></li><li>缺点<ul><li>复杂的内存管理开销。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;分区、分段、段页式&quot;&gt;&lt;a href=&quot;#分区、分段、段页式&quot; class=&quot;headerlink&quot; title=&quot;分区、分段、段页式&quot;&gt;&lt;/a&gt;分区、分段、段页式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作系进行内存管理的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;划分内存而满足多道程序的需求。&lt;/li&gt;
&lt;li&gt;内存需要被高效地分配而能够装入尽可能多的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续：分区&lt;/li&gt;
&lt;li&gt;离散：分段、分页&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分区、分段、段页式" scheme="http://tianyuzhou.github.io/tags/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E6%AE%B5%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的基本概念</title>
    <link href="http://tianyuzhou.github.io/2020/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://tianyuzhou.github.io/2020/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-09-27T11:36:43.000Z</published>
    <updated>2021-02-17T13:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合</li></ul><h3 id="OS的功能性需求"><a href="#OS的功能性需求" class="headerlink" title="OS的功能性需求"></a>OS的功能性需求</h3><ul><li>计算机用户需要的<strong>用户命令</strong><ul><li>由OS实现的所有用户命令所构成的集合常被人们称为OS的<strong>Interface（用户接口）</strong>，有时也称为<strong>命令接口</strong>。<span id="more"></span></li></ul></li><li>应用软件需要的<strong>System Call（系统调用）</strong><ul><li>由OS实现的所有系统调用所构成的集合常被人们称为<strong>程序接口</strong>或<strong>应用编程接口（API）</strong>。</li></ul></li></ul><p><img src="https://pic.zty.plus/20190814215620755.png" alt="操作系统"></p><ul><li>体现的作用：<ol><li>OS作为用户与计算机系统之间的接口。</li><li>OS作为计算机系统资源的管理者。</li><li>OS实现对计算机资源的抽象。</li></ol></li></ul><h3 id="OS的非功能性需求"><a href="#OS的非功能性需求" class="headerlink" title="OS的非功能性需求"></a>OS的非功能性需求</h3><ul><li>性能、安全、可靠性、可扩展性、可移植性…</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="作业和作业步"><a href="#作业和作业步" class="headerlink" title="作业和作业步"></a>作业和作业步</h4><ul><li>Job（作业）：计算机用户在一次上机过程中要求计算机系统为其所作工作的集合。</li><li>作业步：作业中每项相对独立的工作。</li><li>作业的基本类型：<ul><li>Off-line Job（脱机作业）：计算机用户不能在此类作业被计算机系统处理时改变已定义好的作业步。</li><li>On-line Job（联机作业）：计算机用户可以在此类作业被计算机系统处理时随时改变其<strong>作业步</strong>。</li></ul></li></ul><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul><li>Thread（线程）：程序的一次相对独立的<strong>运行过程</strong>。在现代OS中，线程是<strong>系统调度的最小单位</strong>。</li><li>Process（进程）：<strong>系统分配资源的基本对象</strong>。在现代OS中，进程仅仅是系统中<strong>拥有资源的最小实体</strong>。不过，在传统OS中，进程同时也是系统调度的最小单位。</li></ul><h4 id="虚拟存储和文件"><a href="#虚拟存储和文件" class="headerlink" title="虚拟存储和文件"></a>虚拟存储和文件</h4><ul><li>Virtual Memory（虚拟存储）：进程的逻辑地址空间。它是现代OS对计算机系统中<strong>多级物理存储体系</strong>进行高度抽象的结果。</li><li>File（文件）：命名了的字节流。它是线代OS对计算机系统中种类繁多的<strong>外部设备</strong>进行高度抽象的结果。</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;OS的功能性需求&quot;&gt;&lt;a href=&quot;#OS的功能性需求&quot; class=&quot;headerlink&quot; title=&quot;OS的功能性需求&quot;&gt;&lt;/a&gt;OS的功能性需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;计算机用户需要的&lt;strong&gt;用户命令&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;由OS实现的所有用户命令所构成的集合常被人们称为OS的&lt;strong&gt;Interface（用户接口）&lt;/strong&gt;，有时也称为&lt;strong&gt;命令接口&lt;/strong&gt;。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="http://tianyuzhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python+Selenium某校的自动打卡脚本</title>
    <link href="http://tianyuzhou.github.io/2020/09/03/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    <id>http://tianyuzhou.github.io/2020/09/03/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/</id>
    <published>2020-09-03T12:52:03.000Z</published>
    <updated>2021-02-17T13:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>使用selenium库</li><li>百度OCR API识别验证码</li><li>开启QQ邮箱SMTP服务，邮件提醒打卡状态</li><li>阿里云服务器Crontab定时启动</li><li>本脚本仅用于个人偷懒使用，并确保填写信息真实<span id="more"></span><h2 id="可能需要用到的库"><a href="#可能需要用到的库" class="headerlink" title="可能需要用到的库"></a>可能需要用到的库</h2></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br></pre></td></tr></table></figure><h2 id="获取登陆界面的验证码"><a href="#获取登陆界面的验证码" class="headerlink" title="获取登陆界面的验证码"></a>获取登陆界面的验证码</h2><ol><li>保存原始验证码<code>code.png</code></li><li>由于原视验证码较模糊，转换为灰度模式，处理后保存<code>code_process.png</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_code</span>(<span class="params">driver</span>):</span><br><span class="line">    png = driver.find_element_by_id(<span class="string">&#x27;code-box&#x27;</span>)</span><br><span class="line">    png.screenshot(<span class="string">&#x27;code.png&#x27;</span>)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&#x27;code.png&#x27;</span>)</span><br><span class="line">    img = img.convert(<span class="string">&#x27;L&#x27;</span>)  <span class="comment"># P模式转换为L模式(灰度模式默认阈值127)</span></span><br><span class="line">    count = <span class="number">185</span>  <span class="comment"># 设定阈值</span></span><br><span class="line">    table = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; count:</span><br><span class="line">            table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            table.append(<span class="number">1</span>)</span><br><span class="line">    img = img.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    img.save(<span class="string">&#x27;code_process.png&#x27;</span>)  <span class="comment"># 保存处理后的验证码</span></span><br></pre></td></tr></table></figure><h2 id="调用百度OCR-文字识别API-识别验证码"><a href="#调用百度OCR-文字识别API-识别验证码" class="headerlink" title="调用百度OCR(文字识别API)识别验证码"></a>调用百度OCR(文字识别API)识别验证码</h2><ol><li>验证码只有英文，并且只有4位。</li><li>识别过后可能会存在空格，使用正则表达式保留需要的元素返回。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">code_rec</span>():</span><br><span class="line">    APP_ID = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    API_KEY = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    SECRET_KEY = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_file_content</span>(<span class="params">file_path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line">    image = get_file_content(file_path=<span class="string">&#x27;code_process.png&#x27;</span>)</span><br><span class="line">    options = &#123;<span class="string">&#x27;language_type&#x27;</span>: <span class="string">&#x27;ENG&#x27;</span>, &#125;  <span class="comment"># 识别语言类型，默认为&#x27;CHN_ENG&#x27;中英文混合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  调用通用文字识别</span></span><br><span class="line">    result = client.basicGeneral(image, options)  <span class="comment"># 高精度接口 basicAccurate</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> result[<span class="string">&#x27;words_result&#x27;</span>]:</span><br><span class="line">        captcha = (word[<span class="string">&#x27;words&#x27;</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;验证码识别结果：&#x27;</span> + captcha)</span><br><span class="line">        captcha_list = re.findall(<span class="string">&#x27;[a-zA-Z]&#x27;</span>, captcha, re.S)[:<span class="number">4</span>]</span><br><span class="line">        captcha_2 = <span class="string">&#x27;&#x27;</span>.join(captcha_list)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;验证码去杂结果：&#x27;</span> + captcha_2)</span><br><span class="line">        <span class="keyword">return</span> captcha_2</span><br></pre></td></tr></table></figure><h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><ol><li>获取登陆界面表单元素</li><li>填入相应数据</li><li>提交</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">driver, captcha, stu_dic</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># driver = webdriver.Chrome()</span></span><br><span class="line">        stu_id = driver.find_element_by_name(<span class="string">&#x27;txtUid&#x27;</span>)</span><br><span class="line">        stu_pw = driver.find_element_by_name(<span class="string">&#x27;txtPwd&#x27;</span>)</span><br><span class="line">        code = driver.find_element_by_name(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">        stu_id.send_keys(stu_dic[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">        stu_pw.send_keys(stu_dic[<span class="string">&#x27;pw&#x27;</span>])</span><br><span class="line">        code.send_keys(captcha)</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;Submit&#x27;</span>).click()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆表单提交成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆表单提交失败！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="测试元素是否存在-判断登陆结果"><a href="#测试元素是否存在-判断登陆结果" class="headerlink" title="测试元素是否存在(判断登陆结果)"></a>测试元素是否存在(判断登陆结果)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法必须要继承自unittest.TestCase</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisitSogouByIE</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 启动谷歌浏览器</span></span><br><span class="line">        self.driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isElementPresent</span>(<span class="params">self, by, value, driver</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            driver.find_element(by=by, value=value)</span><br><span class="line">        <span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;没有找到指定元素！&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="填写并提交数据表单"><a href="#填写并提交数据表单" class="headerlink" title="填写并提交数据表单"></a>填写并提交数据表单</h2><ol><li>Xpath语法或其他方法定位到对应填写入口</li><li>获取对应数据并填入表单提交</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub_form</span>(<span class="params">driver</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        driver.find_element_by_xpath(<span class="string">&quot;//div[@id=&#x27;platfrom2&#x27;]/a&quot;</span>).click()</span><br><span class="line">        select_1 = driver.find_element_by_name(<span class="string">&#x27;FaProvince&#x27;</span>).get_attribute(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        select1 = Select(driver.find_element_by_name(<span class="string">&#x27;Province&#x27;</span>))</span><br><span class="line">        select1.select_by_value(select_1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;行政区代码&quot;</span> + select_1)</span><br><span class="line">        select_2 = driver.find_element_by_name(<span class="string">&#x27;FaCity&#x27;</span>).get_attribute(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        select2 = Select(driver.find_element_by_name(<span class="string">&#x27;City&#x27;</span>))</span><br><span class="line">        select2.select_by_value(select_2)</span><br><span class="line">        select_3 = driver.find_element_by_name(<span class="string">&#x27;FaCounty&#x27;</span>).get_attribute(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        select3 = Select(driver.find_element_by_name(<span class="string">&#x27;County&#x27;</span>))</span><br><span class="line">        select3.select_by_value(select_3)</span><br><span class="line">        ck_cls = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;form1&quot;]/div[1]/div[5]/div[3]/div/div/label&#x27;</span>)</span><br><span class="line">        js = <span class="string">&quot;var q=document.documentElement.scrollTop=10000&quot;</span></span><br><span class="line">        driver.execute_script(js)</span><br><span class="line">        <span class="comment"># ActionChains(driver).send_keys(Keys.END).perform()</span></span><br><span class="line">        ck_cls.click()</span><br><span class="line">        save_form = driver.find_element_by_class_name(<span class="string">&#x27;save_form&#x27;</span>)</span><br><span class="line">        save_form.click()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;信息表单提交成功！&quot;</span>)</span><br><span class="line">        driver.quit()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> erro:</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(erro)</span><br><span class="line">        already_text = driver.find_element_by_xpath(</span><br><span class="line">            <span class="string">&quot;//*[@class=&#x27;layui-m-layercont&#x27;]&quot;</span>).text</span><br><span class="line">        <span class="keyword">if</span> already_text == <span class="string">&#x27;当前采集日期已登记！&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(already_text)</span><br><span class="line">            driver.quit()</span><br><span class="line">            <span class="keyword">return</span> already_text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;提交失败！&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(already_text)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="邮件提醒打卡状态"><a href="#邮件提醒打卡状态" class="headerlink" title="邮件提醒打卡状态"></a>邮件提醒打卡状态</h2><ol><li>利用QQ邮箱或其他SMTP服务或自己服务器搭建的邮件服务发送邮件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_email</span>(<span class="params">text, stu_dic</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        email_from = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        email_to = stu_dic[<span class="string">&#x27;email_to&#x27;</span>]  <span class="comment"># 接收邮箱</span></span><br><span class="line">        hostname = <span class="string">&#x27;smtp.qq.com&#x27;</span>  <span class="comment"># QQ邮箱的smtp服务器地址</span></span><br><span class="line">        login = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 发送邮箱的用户名</span></span><br><span class="line">        password = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 发送邮箱的密码，即开启smtp服务得到的授权码。</span></span><br><span class="line">        subject = <span class="string">&#x27;打卡状态&#x27;</span>  <span class="comment"># 邮件主题</span></span><br><span class="line">        <span class="comment"># text = &quot;恭喜您！打卡成功！&quot;  # 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">        smtp = SMTP_SSL(hostname)  <span class="comment"># SMTP_SSL默认使用465端口</span></span><br><span class="line">        smtp.login(login, password)</span><br><span class="line"></span><br><span class="line">        msg = MIMEText(text, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(subject, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        msg[<span class="string">&#x27;from&#x27;</span>] = email_from</span><br><span class="line">        msg[<span class="string">&#x27;to&#x27;</span>] = email_to</span><br><span class="line"></span><br><span class="line">        smtp.sendmail(email_from, email_to, msg.as_string())</span><br><span class="line">        smtp.quit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发送成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发送失败！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><ol><li>程序运行成功邮件提醒</li><li>程序运行失败异常处理及邮件提醒</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        chrome_options = Options()</span><br><span class="line">        chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">        chrome_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line">        chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">        stu = [</span><br><span class="line">            &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;xxxxx&#x27;</span>, <span class="string">&#x27;pw&#x27;</span>: <span class="string">&#x27;xxxxx&#x27;</span>, <span class="string">&#x27;email_to&#x27;</span>: <span class="string">&#x27;xxxxx@foxmail.com&#x27;</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">for</span> stu_dic <span class="keyword">in</span> stu:</span><br><span class="line">            test = VisitSogouByIE()  <span class="comment"># 实例化对象</span></span><br><span class="line">            <span class="comment"># driver = webdriver.Chrome(options=chrome_options,executable_path=&#x27;/usr/local/bin/chromedriver&#x27;)  # 实例化对象</span></span><br><span class="line">            driver = webdriver.Chrome(options=chrome_options)</span><br><span class="line">            driver.get(<span class="string">&#x27;http://xsc.sicau.edu.cn/SPCP/Web/&#x27;</span>)</span><br><span class="line">            driver.implicitly_wait(<span class="number">20</span>)</span><br><span class="line">            get_code(driver)</span><br><span class="line">            captcha = code_rec()</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(captcha) &lt; <span class="number">4</span>:</span><br><span class="line">                        driver.refresh()</span><br><span class="line">                        time.sleep(<span class="number">2</span>)</span><br><span class="line">                        get_code(driver)</span><br><span class="line">                        captcha = code_rec()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        login(driver, captcha, stu_dic)</span><br><span class="line">                        time.sleep(<span class="number">5</span>)</span><br><span class="line">                        is_exist = test.isElementPresent(</span><br><span class="line">                            driver=driver, by=<span class="string">&#x27;id&#x27;</span>, value=<span class="string">&#x27;platfrom2&#x27;</span>)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> is_exist:</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">not</span> test.isElementPresent(driver=driver, by=<span class="string">&#x27;id&#x27;</span>, value=<span class="string">&#x27;layui-m-layer0&#x27;</span>):</span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                            driver.back()</span><br><span class="line">                            time.sleep(<span class="number">2</span>)</span><br><span class="line">                            driver.refresh()</span><br><span class="line">                            time.sleep(<span class="number">2</span>)</span><br><span class="line">                            get_code(driver)</span><br><span class="line">                            captcha = code_rec()</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;登陆失败！&quot;</span>)</span><br><span class="line">                        <span class="keyword">elif</span> is_exist:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;登陆成功！&quot;</span>)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> erro:</span><br><span class="line">                    <span class="built_in">print</span>(erro)</span><br><span class="line">                    captcha = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            is_sub = sub_form(driver)</span><br><span class="line">            <span class="keyword">if</span> is_sub:</span><br><span class="line">                text = <span class="string">&quot;恭喜您！打卡成功！&quot;</span></span><br><span class="line">                <span class="keyword">if</span> is_sub == <span class="string">&#x27;当前采集日期已登记！&#x27;</span>:</span><br><span class="line">                    text = is_sub</span><br><span class="line">                send_email(text, stu_dic)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> is_sub:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;打卡失败！稍后重试！&quot;</span>)</span><br><span class="line">                text = <span class="string">&quot;打卡失败！稍后重试！&quot;</span></span><br><span class="line">                send_email(text, stu_dic)</span><br><span class="line">        text = <span class="string">&quot;程序运行结束，所有STU均已操作一遍!&quot;</span></span><br><span class="line">        send_email(text, stu[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> E:</span><br><span class="line">        me = &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="string">&#x27;pw&#x27;</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="string">&#x27;email_to&#x27;</span>: <span class="string">&#x27;xxxx@foxmail.com&#x27;</span>&#125;</span><br><span class="line">        <span class="built_in">print</span>(E)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序意外终止！&quot;</span>)</span><br><span class="line">        text = <span class="string">&quot;程序意外终止！&quot;</span></span><br><span class="line">        send_email(text,me)</span><br></pre></td></tr></table></figure><p>写得比较匆忙有的地方还可以改进，已经开学了，不用打卡了，代码放出来做个记录，顺便水一篇博客。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;使用selenium库&lt;/li&gt;
&lt;li&gt;百度OCR API识别验证码&lt;/li&gt;
&lt;li&gt;开启QQ邮箱SMTP服务，邮件提醒打卡状态&lt;/li&gt;
&lt;li&gt;阿里云服务器Crontab定时启动&lt;/li&gt;
&lt;li&gt;本脚本仅用于个人偷懒使用，并确保填写信息真实</summary>
    
    
    
    <category term="脚本" scheme="http://tianyuzhou.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="Python自动打卡" scheme="http://tianyuzhou.github.io/tags/Python%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>汇编算数指令</title>
    <link href="http://tianyuzhou.github.io/2020/06/07/%E6%B1%87%E7%BC%96%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4/"/>
    <id>http://tianyuzhou.github.io/2020/06/07/%E6%B1%87%E7%BC%96%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4/</id>
    <published>2020-06-07T13:59:07.000Z</published>
    <updated>2021-02-17T13:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul><li>80×86的算数运算指令包括二进制运算和十进制运算指令。算数指令用来执行算数运算，它们中有双操作数指令，也有单操作数指令。</li><li>如前所述，双操作数指令的两个操作数中除<strong>源操作数为立即数</strong>的情况外，必须有一个操作数在寄存器中。单操作数指令不允许使用立即数方式。算数指令的寻址方式均遵循这一原则。<span id="more"></span></li></ul><h2 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h2><h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><ul><li><p>ADD 加法</p><ul><li>格式：ADD DST,SRC</li><li>DST&lt;–DST+SRC</li></ul></li><li><p>ADC 带进位的加法</p><ul><li>格式：ADC DST,SRC</li><li>DST&lt;–DST+SRC+CF</li></ul></li><li><p>INC 加一</p><ul><li>格式：INC OPR</li><li>OPR&lt;–OPR+1</li></ul></li></ul><h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><ul><li><p>SUB 减法</p><ul><li>格式：SUB DST,SRC</li><li>DST&lt;–DST-SRC</li></ul></li><li><p>SBB 带借位的减法</p><ul><li>格式：SBB DST,SRC</li><li>DST&lt;–DST-SRC-CF</li></ul></li><li><p>DEC 减一</p><ul><li>格式：DEC OPR</li><li>OPR&lt;–OPR-1</li></ul></li><li><p>NEG 求补</p><ul><li>格式：NEG OPR</li><li>OPR&lt;-(-OPR)</li></ul></li><li><p>CMP 比较</p><ul><li>格式：CMP OPR1, OPR2</li><li>OPR1-OPR2<ul><li>类似SUB但不保存结果，只是根据结果设置标志位</li><li>CMP后往往跟着一条条件转移指令</li></ul></li></ul></li></ul><h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><ul><li><p>MUL 无符号数乘法</p><ul><li>格式：MUL SRC</li><li>字节操作：AX&lt;-AL*SRC</li><li>字操作：DX,AX&lt;-AX*SRC<ul><li>DX放高位字，AX放低位字</li></ul></li></ul></li><li><p>IMUL 带符号数乘法</p><ul><li>格式：IMUL SRC</li><li>字节操作：AX&lt;-AL*SRC</li><li>字操作：DX,AX&lt;-AX*SRC<ul><li>DX放高位字，AX放低位字</li></ul></li></ul></li></ul><h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><ul><li><p>DIV 无符号数除法</p><ul><li>格式：DIV SRC</li><li>字节操作：AL&lt;-AX/SRC的商</li><li>字节操作：AH&lt;-AX/SRC的余数</li><li>字操作：AX&lt;-(DX,AX)/SRC的商</li><li>字操作：DX&lt;-(DX,AX)/SRC的余数</li></ul></li><li><p>IDIV 无符号数除法</p><ul><li>格式：IDIV SRC</li><li>字节操作：AL&lt;-AX/SRC的商</li><li>字节操作：AH&lt;-AX/SRC的余数</li><li>字操作：AX&lt;-(DX,AX)/SRC的商</li><li>字操作：DX&lt;-(DX,AX)/SRC的余数</li></ul></li></ul><p>其他指令：<a href="https://blog.csdn.net/gzfqh/article/details/341691" title="8086指令">指令手册</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;80×86的算数运算指令包括二进制运算和十进制运算指令。算数指令用来执行算数运算，它们中有双操作数指令，也有单操作数指令。&lt;/li&gt;
&lt;li&gt;如前所述，双操作数指令的两个操作数中除&lt;strong&gt;源操作数为立即数&lt;/strong&gt;的情况外，必须有一个操作数在寄存器中。单操作数指令不允许使用立即数方式。算数指令的寻址方式均遵循这一原则。</summary>
    
    
    
    <category term="学习笔记" scheme="http://tianyuzhou.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="80×86汇编语言" scheme="http://tianyuzhou.github.io/tags/80%C3%9786%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
